<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-content">
    <meta name="theme-color" content="#000000">
    <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <script>
        // Preload light mode as early as possible to keep bars white if saved
        (function () {
            try {
                const savedTheme = localStorage.getItem('theme');
                const themeMeta = document.querySelector('meta[name="theme-color"]');
                const appleMeta = document.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
                if (savedTheme === 'light') {
                    document.documentElement.classList.add('light-mode-preload');
                    document.documentElement.style.backgroundColor = '#ffffff';
                    document.documentElement.setAttribute('data-force-light', '1');
                    if (themeMeta) themeMeta.setAttribute('content', '#ffffff');
                    if (appleMeta) appleMeta.setAttribute('content', 'default');
                } else {
                    document.documentElement.removeAttribute('data-force-light');
                }
            } catch (e) { }
        })();
    </script>
    <script>
        // Update theme-color immediately based on localStorage
        (function() {
            try {
                const savedTheme = localStorage.getItem('theme');
                const themeColorMeta = document.querySelector('meta[name="theme-color"]');
                const appleStatusBarMeta = document.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
                
                if (savedTheme === 'light' && themeColorMeta && appleStatusBarMeta) {
                    themeColorMeta.setAttribute('content', '#ffffff');
                    appleStatusBarMeta.setAttribute('content', 'default');
                }
            } catch(e) {}
        })();
    </script>
    <title>InfiNet AI - Uncensored Fine-Tuned Models with No Filters</title>
    <meta name="description" content="Experience unrestricted AI conversations with InfiNet AI. Free AI chat with no filters, no limitations. Chat with advanced AI models including Coder and Thinker. Start chatting now!">
    <meta name="keywords" content="AI chat, uncensored AI, free AI, AI assistant, chatbot, AI conversation, InfiNet AI, AI models, Coder AI, Thinker AI, unrestricted AI, AI platform">
    <meta name="author" content="InfiNet Services">
    <meta name="robots" content="index, follow">
    <meta name="googlebot" content="index, follow">
    <link rel="canonical" href="https://ai.infinet.services/">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://ai.infinet.services/">
    <meta property="og:title" content="Uncensored InfiNet AI - Free AI Chat with No Filters">
    <meta property="og:description" content="Experience unrestricted AI conversations with InfiNet AI. Free AI chat with no filters, no limitations. Chat with advanced AI models including Coder and Thinker.">
    <meta property="og:image" content="https://ai.infinet.services/ghost.JPG">
    <meta property="og:site_name" content="InfiNet AI">
    <meta property="og:locale" content="en_US">
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://ai.infinet.services/">
    <meta name="twitter:title" content="Uncensored InfiNet AI - Free AI Chat with No Filters">
    <meta name="twitter:description" content="Experience unrestricted AI conversations with InfiNet AI. Free AI chat with no filters, no limitations.">
    <meta name="twitter:image" content="https://ai.infinet.services/ghost.JPG">
    
    <!-- Favicon and Icons -->
    <link rel="icon" type="image/png" href="/ghost.PNG">
    <link rel="shortcut icon" type="image/png" href="/ghost.PNG">
    <!-- Apple Touch Icon - Primary reference (Safari looks for this first) -->
    <!-- Using trans.PNG for Safari Web App banner (served via /apple-touch-icon.png route) -->
    <!-- Safari fallback without query param -->
    <link rel="apple-touch-icon-precomposed" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <!-- Versioned icons for cache busting -->
    <link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon.png">
    <link rel="icon" type="image/jpeg" sizes="32x32" href="/ghost.JPG">
    <link rel="icon" type="image/jpeg" sizes="16x16" href="/ghost.JPG">
    <link rel="icon" type="image/x-icon" href="/ghost.JPG">
    <link rel="manifest" href="/manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="InfiNet AI">
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- Structured Data for SEO -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Uncensored InfiNet AI",
        "url": "https://ai.infinet.services",
        "description": "Experience unrestricted AI conversations with InfiNet AI. Free AI chat with no filters, no limitations.",
        "applicationCategory": "ChatApplication",
        "operatingSystem": "Web",
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "featureList": [
            "Uncensored AI conversations",
            "Multiple AI models (Coder & Thinker)",
            "Free tier with 10,000 tokens",
            "No filters or limitations",
            "Real-time chat interface"
        ],
        "aggregateRating": {
            "@type": "AggregateRating",
            "ratingValue": "5",
            "ratingCount": "1"
        }
    }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #000000;
            --bg-secondary: #0a0a0a;
            --bg-tertiary: #1a1a1a;
            --accent: #e5ff3a;
            --accent-hover: #b8cc2e;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --text-muted: #888888;
            --border: #333333;
            --border-light: #222222;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            display: flex;
        }

        /* Keep the very top white on mobile in light mode (behind header/content) */
        .top-safe-area {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 200px;
            background: #ffffff;
            z-index: 0;
            pointer-events: none;
            display: none;
        }

        /* Chrome Native Install Banner */
        .chrome-install-banner {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #ffffff;
            border-top: 1px solid #e0e0e0;
            padding: 12px 16px;
            display: none;
            align-items: center;
            gap: 12px;
            z-index: 10000;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        }

        .chrome-install-banner.show {
            display: flex;
        }

        .chrome-install-banner-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            overflow: hidden;
            flex-shrink: 0;
        }

        .chrome-install-banner-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .chrome-install-banner-text {
            flex: 1;
            min-width: 0;
        }

        .chrome-install-banner-title {
            font-size: 14px;
            font-weight: 600;
            color: #202124;
            margin-bottom: 2px;
        }

        .chrome-install-banner-subtitle {
            font-size: 12px;
            color: #5f6368;
        }

        .chrome-install-banner-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }

        .chrome-install-btn {
            background: #1a73e8;
            color: #ffffff;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            white-space: nowrap;
        }

        .chrome-install-btn:hover {
            background: #1765cc;
        }

        .chrome-install-close {
            background: transparent;
            border: none;
            color: #5f6368;
            cursor: pointer;
            padding: 4px;
            font-size: 20px;
            line-height: 1;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chrome-install-close:hover {
            color: #202124;
        }

        body.light-mode .chrome-install-banner {
            background: #ffffff;
            border-top-color: #e0e0e0;
        }

        @media (prefers-color-scheme: dark) {
            .chrome-install-banner {
                background: #202124;
                border-top-color: #3c4043;
            }

            .chrome-install-banner-title {
                color: #e8eaed;
            }

            .chrome-install-banner-subtitle {
                color: #9aa0a6;
            }

            .chrome-install-close {
                color: #9aa0a6;
            }

            .chrome-install-close:hover {
                color: #e8eaed;
            }
        }


        html {
            background-color: #000000;
        }

        /* Preload helper to keep background white before JS finishes */
        html.light-mode-preload {
            background-color: #ffffff !important;
        }

        html.light-mode-preload body,
        html[data-force-light] body {
            background-color: #ffffff !important;
            color: #000000 !important;
        }

        /* Force white tops for light mode (CSS-only, no JS dependency) */
        body.light-mode html,
        body.light-mode {
            background: #ffffff !important;
            color: #000000 !important;
        }

        body.light-mode .top-safe-area {
            display: block;
        }

        /* Web App view (standalone mode) - Mobile only */
        @media (max-width: 768px) {
            @media (display-mode: standalone) {
                /* Fix header being hidden behind status bar in Web App - both dark and light mode with same positioning */
                .chat-header {
                    padding: 0.75rem 1rem !important;
                    padding-top: calc(0.75rem + env(safe-area-inset-top) - 5mm) !important;
                    padding-bottom: 0.75rem !important;
                    padding-left: 1rem !important;
                    padding-right: 1rem !important;
                }
                
                /* Move sidebar header 5mm down in web app mobile */
                .sidebar-header {
                    margin-top: 5mm !important;
                }
                
                /* Move sidebar bottom sections 5mm down in web app mobile */
                .sidebar-footer,
                .sidebar-socials {
                    margin-top: 5mm !important;
                }
                
                body.light-mode .chat-header {
                    padding: 0.75rem 1rem !important;
                    padding-top: calc(0.75rem + env(safe-area-inset-top) - 5mm) !important;
                    padding-bottom: 0.75rem !important;
                    padding-left: 1rem !important;
                    padding-right: 1rem !important;
                }
                
                /* Ensure top bar area is white in light mode for Web App */
                body.light-mode .top-safe-area {
                    display: block !important;
                    background: #ffffff !important;
                    height: calc(env(safe-area-inset-top) + 200px) !important;
                    z-index: 0 !important;
                }
                
                /* Ensure html and body background is white in light mode for Web App */
                body.light-mode html,
                body.light-mode {
                    background: #ffffff !important;
                    background-color: #ffffff !important;
                }
                
                /* Ensure main content background is white in light mode for Web App */
                body.light-mode .main-content {
                    background: #ffffff !important;
                    background-color: #ffffff !important;
                }
            }
        }

        /* Header should be solid white in light mode (no translucency) */
        body.light-mode .chat-header {
            background: #ffffff !important;
            backdrop-filter: none !important;
            padding: 1rem 1.5rem !important;
            padding-top: 1rem !important;
            padding-bottom: 1rem !important;
        }

        body.light-mode html {
            background-color: #ffffff !important;
        }
        @media (max-width: 768px) {
            body {
                height: auto !important;
                min-height: 100dvh;
                overflow-y: auto !important;
                overflow-x: hidden;
                position: relative;
                display: block;
                background: var(--bg-primary);
            }
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background: #121212;
            border-right: none;
            display: flex;
            flex-direction: column;
            height: 100vh;
            transition: transform 0.3s ease;
            position: fixed;
            left: 0;
            top: 0;
            z-index: 100;
            transform: translateX(-100%);
        }

        .sidebar.sidebar-open {
            transform: translateX(0);
        }

        .sidebar.mobile-hidden {
            transform: translateX(-100%);
        }

        /* Hide expanded cards when sidebar is hidden */
        .sidebar.mobile-hidden .info-card-expanded {
            display: none !important;
            opacity: 0 !important;
            visibility: hidden !important;
        }

        /* Mobile Sidebar Overlay */
        .sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 99;
        }

        .sidebar-overlay.show {
            display: block;
        }

        /* Sidebar Bot Handle */
        .sidebar-handle {
            position: absolute;
            right: -45px;
            top: 80px;
            width: 60px;
            height: 80px;
            cursor: pointer;
            z-index: 101;
            transition: all 0.3s ease;
            filter: drop-shadow(0 4px 8px rgba(229, 255, 58, 0.4));
        }

        .sidebar-handle svg {
            width: 100%;
            height: 100%;
            transition: all 0.3s ease;
        }

        .sidebar-handle:hover {
            right: -50px;
            filter: drop-shadow(0 6px 15px rgba(229, 255, 58, 0.7));
            animation: botBounce 0.6s ease-in-out infinite;
        }

        .sidebar-handle:hover svg {
            transform: scale(1.1);
        }

        .sidebar-handle:hover .bot-head {
            animation: botPeek 0.8s ease-in-out infinite;
        }

        .sidebar-handle:hover .bot-hand-left {
            animation: handWave 0.5s ease-in-out infinite;
            transform-origin: top center;
        }

        .sidebar-handle:hover .bot-hand-right {
            animation: handWave 0.5s ease-in-out infinite 0.25s;
            transform-origin: top center;
        }

        .sidebar-handle:hover .bot-eye {
            animation: eyeBlink 2s ease-in-out infinite;
        }

        @keyframes botBounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-5px);
            }
        }

        @keyframes botPeek {

            0%,
            100% {
                transform: translateX(0);
            }

            50% {
                transform: translateX(3px);
            }
        }

        @keyframes handWave {

            0%,
            100% {
                transform: rotate(0deg);
            }

            50% {
                transform: rotate(15deg);
            }
        }

        @keyframes eyeBlink {

            0%,
            90%,
            100% {
                transform: scaleY(1);
            }

            95% {
                transform: scaleY(0.1);
            }
        }

        .sidebar.sidebar-open .sidebar-handle {
            right: -45px;
        }

        /* Sidebar Hint Text */
        .sidebar-hint {
            position: absolute;
            right: -33px;
            top: 165px;
            font-size: 0.75rem;
            color: #e5ff3a;
            white-space: nowrap;
            pointer-events: none;
            z-index: 102;
            opacity: 0.9;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            animation: hintJump 1.2s ease-in-out infinite;
            transition: opacity 0.3s ease;
        }

        .sidebar.sidebar-open .sidebar-hint,
        .sidebar-hint.hidden {
            opacity: 0;
            pointer-events: none;
        }

        @keyframes hintJump {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-8px);
            }
        }

        @media (max-width: 768px) {
            .sidebar-hint {
                font-size: 0.75rem;
                right: -33px;
                top: 160px;
            }
        }

        .sidebar-header {
            padding: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .sidebar-header img {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            transform: scale(1.5);
            object-fit: cover;
            object-position: center;
            overflow: hidden;
        }

        .sidebar-header h1 {
            font-size: 1.25rem;
            color: var(--accent);
            font-weight: 700;
            margin: 0;
            margin-left: 3mm;
            line-height: 1.3;
        }

        .sidebar-actions {
            padding: 1rem;
        }

        .btn-new-chat {
            width: 100%;
            padding: 0.75rem;
            background: var(--accent);
            color: var(--bg-primary);
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.95rem;
        }

        .btn-new-chat:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
        }

        .sidebar-conversations {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .sidebar-info-cards {
            padding: 0.4rem 0.5rem;
            border-top: none;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .sidebar-info-cards .info-card {
            padding: 0.6rem 0.75rem;
            margin: 0;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 12px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            z-index: 1;
        }

        .sidebar-info-cards .info-card:hover,
        .sidebar-info-cards .info-card.expanded-active {
            z-index: 1001;
        }

        .sidebar-info-cards .info-card:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .sidebar-info-cards .info-card:active {
            transform: scale(0.98);
        }

        .sidebar-info-cards .info-card h4 {
            font-size: 0.85rem;
            margin-bottom: 0.3rem;
            color: var(--accent);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .sidebar-info-cards .info-card p {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin: 0;
        }

        .sidebar-info-cards .info-card .lock-icon {
            width: 14px;
            height: 14px;
            flex-shrink: 0;
            fill: currentColor;
        }

        .conversation-item {
            padding: 0.75rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 0.25rem;
            transition: all 0.2s;
            color: var(--text-secondary);
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            position: relative;
        }

        .conversation-item:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .conversation-item.active {
            background: var(--bg-tertiary);
            color: var(--accent);
        }

        .conversation-item-content {
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .conversation-delete-btn {
            opacity: 0;
            transition: opacity 0.2s;
            padding: 0.25rem;
            background: transparent;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            border-radius: 4px;
            flex-shrink: 0;
        }

        .conversation-item:hover .conversation-delete-btn {
            opacity: 1;
        }

        .conversation-delete-btn:hover {
            color: #ff4444;
            background: rgba(255, 68, 68, 0.1);
        }

        .conversation-delete-btn svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
        }

        .sidebar-footer {
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .sidebar-footer a {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.85rem;
            padding: 0.5rem;
            border-radius: 6px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .sidebar-footer a .sidebar-icon {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
            fill: currentColor;
        }

        .sidebar-footer a:hover {
            color: var(--accent);
            background: var(--bg-tertiary);
        }

        .sidebar-socials {
            padding: 0.75rem 1rem calc(3rem + 1cm);
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .sidebar-socials .sidebar-cta-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5mm;
        }

        .sidebar-socials .sidebar-cta {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.4rem;
            padding: 0.65rem 1.5rem;
            border-radius: 8px;
            border: 1px solid #e5ff3a;
            background: #e5ff3a;
            color: #000000;
            transition: all 0.2s;
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 600;
            line-height: 1;
            white-space: nowrap;
        }

        .sidebar-socials .sidebar-cta:hover {
            color: #000000;
            border-color: #b8cc2e;
            background: #b8cc2e;
        }

        .sidebar-socials .sidebar-cta svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
            flex-shrink: 0;
        }

        .sidebar-socials .sidebar-link-text {
            color: #e5ff3a;
            font-weight: bold;
            text-decoration: none;
            font-size: 0.85rem;
            transition: opacity 0.2s;
        }

        .sidebar-socials .sidebar-link-text:hover {
            opacity: 0.8;
        }

        .sidebar-socials .sidebar-links-wrapper {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            justify-content: center;
        }

        /* Main Chat Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-primary);
            background-color: #000000;
            height: 100vh;
            overflow: hidden;
        }

        @media (max-width: 768px) {
            .main-content {
                height: auto !important;
                min-height: 100dvh;
                overflow: visible !important;
                overflow: visible !important;
                flex: none;
                display: block;
            }
        }

        .chat-header {
            padding: 1rem 1.5rem;
            border-bottom: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-primary);
            position: relative;
            z-index: 10;
        }

        @media (max-width: 768px) {
            .chat-header {
                position: sticky;
                top: 0;
                z-index: 900;
                background: rgba(0, 0, 0, 0.8);
                backdrop-filter: blur(10px);
                border-bottom: 1px solid var(--border);
            }

            body.light-mode .chat-header {
                background: #ffffff !important;
                backdrop-filter: none !important;
                padding: 0.75rem 1rem !important;
                padding-top: calc(0.75rem + env(safe-area-inset-top) - 5mm) !important;
                padding-bottom: 0.75rem !important;
            }
        }

        .chat-header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        /* Model Toggle Switch */
        .model-toggle-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .model-toggle-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 500;
            white-space: nowrap;
        }

        .model-toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
            background: var(--border);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            flex-shrink: 0;
        }

        .model-toggle-switch.active {
            background: var(--accent);
        }

        .model-toggle-switch::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffffff;
            top: 3px;
            left: 3px;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .model-toggle-switch.active::after {
            left: 23px;
        }

        body.light-mode .model-toggle-switch.active {
            background: var(--accent);
        }

        body.light-mode .model-toggle-switch::after {
            background: #ffffff;
        }

        .chat-header-right {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }

        .header-btn {
            padding: 0.5rem 1rem;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .header-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .header-btn.primary {
            background: var(--accent);
            color: var(--bg-primary);
            border-color: var(--accent);
        }

        .header-btn.primary:hover {
            background: var(--accent-hover);
        }

        .header-btn.primary[style*="border-radius: 50%"]:hover {
            opacity: 0.9;
            transform: scale(1.05);
        }

        .header-btn.primary[style*="border-radius: 50%"] {
            transition: all 0.2s;
        }

        .tokens-badge {
            padding: 0.5rem 1rem;
            background: rgba(229, 255, 58, 0.1);
            border: 1px solid var(--accent);
            border-radius: 8px;
            color: var(--accent);
            font-size: 0.85rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transform: translateX(-3mm);
        }

        .tokens-badge svg {
            width: 16px;
            height: 16px;
            fill: var(--accent);
        }

        .theme-toggle {
            padding: 0.5rem;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-secondary);
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .theme-toggle:hover {
            border-color: var(--accent);
            color: var(--accent);
            background: var(--bg-tertiary);
        }

        .theme-toggle svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        /* Light Mode Styles */
        body.light-mode {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --bg-tertiary: #e8e8e8;
            --text-primary: #000000;
            --text-secondary: #333333;
            --text-muted: #666666;
            --border: #d0d0d0;
            --border-light: #e0e0e0;
            --accent: #000000;
            --accent-hover: #333333;
        }

        body.light-mode .sidebar {
            background: #f8f8f8;
        }

        body.light-mode .sidebar-hint {
            color: #000000;
        }

        body.light-mode .chat-header {
            background: #ffffff !important;
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
            z-index: 10 !important;
            position: relative !important;
            padding: 1rem 1.5rem !important;
            padding-top: 1rem !important;
            padding-bottom: 1rem !important;
            min-height: auto !important;
            height: auto !important;
        }
        
        /* Override for mobile - ensure mobile light mode header matches dark mode */
        @media (max-width: 768px) {
            body.light-mode .chat-header {
                padding: 0.75rem 1rem !important;
                padding-top: calc(0.75rem + env(safe-area-inset-top)) !important;
                padding-bottom: 0.75rem !important;
                padding-left: 1rem !important;
                padding-right: 1rem !important;
                min-height: auto !important;
                height: auto !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                width: 100% !important;
            }
        }
        
        body.light-mode .main-content {
            background: #ffffff !important;
            background-color: #ffffff !important;
        }
        
        body.light-mode body {
            background: #ffffff !important;
        }

        body.light-mode .chat-footer {
            background: #ffffff;
            padding: 2rem 1.5rem !important;
            padding-top: 2rem !important;
            padding-bottom: 2rem !important;
            min-height: auto !important;
            height: auto !important;
        }

        body.light-mode .chat-input-area {
            background: transparent;
        }


        body.light-mode .message-content {
            background: var(--bg-secondary);
        }

        body.light-mode .chat-input {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        body.light-mode h1,
        body.light-mode h2,
        body.light-mode h3,
        body.light-mode .sidebar-header h1,
        body.light-mode .welcome-screen h2,
        body.light-mode .tokens-badge,
        body.light-mode .message-avatar,
        body.light-mode a {
            color: var(--accent) !important;
        }
        
        body.light-mode .welcome-screen {
            margin-top: -1cm !important;
            padding-top: 2rem !important;
        }
        
        body.light-mode .chat-messages {
            padding-top: 2rem !important;
            background-color: transparent !important;
        }

        body.light-mode .tokens-badge {
            border-color: var(--accent);
            background: rgba(0, 0, 0, 0.05);
        }

        body.light-mode .btn-new-chat,
        body.light-mode .send-btn,
        body.light-mode .header-btn.primary {
            background: var(--accent) !important;
            color: #ffffff !important;
        }

        /* Don't override background when profile picture is present */
        body.light-mode .header-btn.primary.has-profile-picture,
        body.light-mode .header-btn.primary[style*="background-image"] {
            background-color: transparent !important;
            background: transparent !important;
        }

        body.light-mode .btn-new-chat:hover,
        body.light-mode .send-btn:hover:not(:disabled),
        body.light-mode .header-btn.primary:hover {
            background: var(--accent-hover) !important;
        }

        /* Preserve profile picture on hover - don't change background */
        body.light-mode .header-btn.primary.has-profile-picture:hover,
        body.light-mode .header-btn.primary[style*="background-image"]:hover {
            background-color: transparent !important;
            background: transparent !important;
            opacity: 0.9;
        }

        body.light-mode .message.user .message-content {
            background: rgba(0, 0, 0, 0.05);
            border-color: var(--accent);
        }

        /* 3D Effects for Web Button in Light Mode */
        body.light-mode .sidebar-socials .sidebar-cta {
            /* 3D Effect for Light Mode */
            box-shadow: 
                0 4px 6px rgba(0, 0, 0, 0.1),
                0 2px 4px rgba(0, 0, 0, 0.06),
                inset 0 1px 0 rgba(255, 255, 255, 0.5),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
            transform: translateY(0);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            border: none !important;
            padding: 0.65rem 1.5rem !important;
            font-size: 0.9rem !important;
        }

        body.light-mode .sidebar-socials .sidebar-cta::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 8px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.3) 0%, rgba(255, 255, 255, 0) 50%, rgba(0, 0, 0, 0.05) 100%);
            pointer-events: none;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        body.light-mode .sidebar-socials .sidebar-cta:hover {
            color: #000000;
            border: none !important;
            background: #b8cc2e;
            transform: translateY(-2px) scale(1.02);
            box-shadow: 
                0 8px 12px rgba(0, 0, 0, 0.15),
                0 4px 6px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.6),
                inset 0 -2px 0 rgba(0, 0, 0, 0.15);
        }

        body.light-mode .sidebar-socials .sidebar-cta:hover::before {
            opacity: 0.8;
        }

        body.light-mode .sidebar-socials .sidebar-cta:active {
            transform: translateY(0) scale(0.98);
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.1),
                0 1px 2px rgba(0, 0, 0, 0.06),
                inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        body.light-mode .sidebar-socials .sidebar-cta:active::before {
            opacity: 0.6;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 2rem;
            padding-top: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            min-height: 0;
            position: relative;
            overflow-x: hidden;
            background-color: transparent;
        }

        /* Connected Particles Network Container */
        .particles-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 0;
            pointer-events: none;
        }

        .particles-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Ensure messages are above the particles */
        .chat-messages > *:not(.particles-container) {
            position: relative;
            z-index: 1;
        }

        .scroll-to-bottom-btn {
            position: fixed;
            bottom: calc(7rem + 94px);
            right: 2rem;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: #e5ff3a;
            border: none;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transition: opacity 0.3s ease, transform 0.3s ease;
            z-index: 100;
            opacity: 0;
            transform: scale(0.8);
        }

        .scroll-to-bottom-btn.show {
            display: flex;
            opacity: 1;
            transform: scale(1);
        }

        .scroll-to-bottom-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        }

        .scroll-to-bottom-btn:active {
            transform: scale(0.95);
        }

        .scroll-to-bottom-btn svg {
            width: 30px;
            height: 30px;
            fill: #000000;
        }

        @media (max-width: 768px) {
            .scroll-to-bottom-btn {
                bottom: 234px;
                right: 1rem;
                width: 44px;
                height: 44px;
            }

            .scroll-to-bottom-btn svg {
                width: 26px;
                height: 26px;
            }
        }

        @media (max-width: 768px) {
            .chat-messages {
                flex: none;
                overflow: visible;
                height: auto;
                padding-bottom: 120px;
                /* Space for fixed input */
            }
        }

        .message {
            display: flex;
            gap: 1rem;
            max-width: 85%;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .message-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            font-weight: bold;
            color: var(--accent);
            border: 1px solid var(--border);
        }

        .message.user .message-avatar {
            background: var(--accent);
            color: var(--bg-primary);
            border-color: var(--accent);
        }

        /* Fallback styling when no profile picture is available */
        .message-avatar.no-photo {
            background: var(--bg-tertiary);
            color: var(--accent);
            border: 1px solid var(--accent);
        }

        body.light-mode .message-avatar.no-photo {
            background: var(--bg-secondary);
            color: var(--accent);
            border-color: var(--accent);
        }

        .message-content {
            background: var(--bg-tertiary);
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            border: 1px solid var(--border);
            line-height: 1.6;
            color: var(--text-primary);
            position: relative;
            max-width: 100%;
            word-wrap: break-word;
            overflow-wrap: break-word;
            overflow-x: hidden;
        }
        
        .message-content * {
            max-width: 100%;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        /* Ensure ordered lists display numbers correctly */
        .message-content ol {
            list-style-type: decimal !important;
            counter-reset: list-counter;
        }
        
        .message-content ol li {
            display: list-item !important;
            list-style-position: outside;
        }
        
        /* Code block container (ChatGPT style) */
        .code-block-container {
            margin: 1rem 0;
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            position: relative;
        }
        
        .code-block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0.75rem;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .code-block-language {
            font-weight: 500;
            text-transform: uppercase;
        }
        
        .code-block-copy-btn {
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            transition: all 0.2s ease;
        }
        
        .code-block-copy-btn:hover {
            background: var(--bg-tertiary);
            color: var(--accent);
            border-color: var(--accent);
        }
        
        .code-block-copy-btn svg {
            width: 14px;
            height: 14px;
        }
        
        .code-block-content {
            padding: 0;
            overflow-x: auto;
            background: var(--bg-secondary);
            max-width: 100%;
        }
        
        .code-block-content pre {
            margin: 0;
            padding: 1rem;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            color: var(--text-primary);
            white-space: pre;
            word-wrap: normal;
            overflow-x: auto;
            max-width: 100%;
            background: transparent;
        }
        
        .code-block-content pre.hljs {
            padding: 1rem;
            background: transparent;
        }
        
        .code-block-content code {
            font-family: 'Courier New', Courier, monospace;
            background: transparent;
            padding: 0;
            border-radius: 0;
            font-size: inherit;
        }
        
        /* Highlight.js styles override for dark theme */
        .message-content .hljs {
            background: var(--bg-secondary) !important;
            color: var(--text-primary) !important;
        }
        
        /* Ensure code blocks don't break layout */
        .code-block-content pre code {
            display: block;
            overflow-x: auto;
            white-space: pre;
        }
        
        
        /* Light mode code blocks */
        body.light-mode .code-block-container {
            background: #f5f5f5;
            border-color: #e0e0e0;
        }
        
        body.light-mode .code-block-header {
            background: #e8e8e8;
            border-bottom-color: #d0d0d0;
        }
        
        body.light-mode .code-block-content {
            background: #fafafa;
        }

        .message.user .message-content {
            background: rgba(229, 255, 58, 0.1);
            border-color: var(--accent);
            padding: 0.25rem 0.75rem;
        }

        .message-copy-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.4rem 0.6rem;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            z-index: 10;
        }

        .message-content:hover .message-copy-btn {
            opacity: 1;
        }

        .message-copy-btn:hover {
            background: var(--bg-tertiary);
            color: var(--accent);
            border-color: var(--accent);
        }

        .message-copy-btn svg {
            width: 16px;
            height: 16px;
        }


        /* Open WebUI-style markdown rendering */
        .message-content p {
            margin: 0.75rem 0;
            line-height: 1.7;
            color: var(--text-primary);
        }
        
        .message-content p:first-child {
            margin-top: 0;
        }
        
        .message-content p:last-child {
            margin-bottom: 0;
        }
        
        .message-content h1,
        .message-content h2,
        .message-content h3,
        .message-content h4,
        .message-content h5,
        .message-content h6 {
            font-weight: 600;
            margin: 1.5rem 0 0.75rem 0;
            line-height: 1.4;
            color: var(--text-primary);
        }
        
        .message-content h1 {
            font-size: 1.75rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.5rem;
        }
        
        .message-content h2 {
            font-size: 1.5rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.5rem;
        }
        
        .message-content h3 {
            font-size: 1.25rem;
        }
        
        .message-content h4 {
            font-size: 1.1rem;
        }
        
        .message-content h5 {
            font-size: 1rem;
        }
        
        .message-content h6 {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        
        .message-content ul,
        .message-content ol {
            margin: 0.75rem 0;
            padding-left: 2rem;
            line-height: 1.7;
        }
        
        .message-content ul {
            list-style-type: disc;
        }
        
        .message-content ol {
            list-style-type: decimal;
        }
        
        .message-content ul ul,
        .message-content ol ol,
        .message-content ul ol,
        .message-content ol ul {
            margin: 0.25rem 0;
        }
        
        .message-content li {
            margin: 0.25rem 0;
            line-height: 1.7;
        }
        
        .message-content li > p {
            margin: 0.5rem 0;
        }
        
        .message-content blockquote {
            margin: 1rem 0;
            padding: 0.5rem 1rem;
            border-left: 4px solid var(--accent);
            background: var(--bg-secondary);
            border-radius: 4px;
            color: var(--text-secondary);
        }
        
        .message-content blockquote p {
            margin: 0.5rem 0;
        }
        
        .message-content blockquote p:first-child {
            margin-top: 0;
        }
        
        .message-content blockquote p:last-child {
            margin-bottom: 0;
        }
        
        .message-content table {
            border-collapse: collapse;
            margin: 1rem 0;
            width: 100%;
            overflow-x: auto;
            display: block;
        }
        
        .message-content table thead {
            background: var(--bg-secondary);
        }
        
        .message-content table th,
        .message-content table td {
            border: 1px solid var(--border);
            padding: 0.5rem 0.75rem;
            text-align: left;
        }
        
        .message-content table th {
            font-weight: 600;
        }
        
        .message-content table tbody tr:nth-child(even) {
            background: var(--bg-secondary);
        }
        
        .message-content hr {
            border: none;
            border-top: 1px solid var(--border);
            margin: 1.5rem 0;
        }
        
        .message-content a {
            color: var(--accent);
            text-decoration: underline;
            text-decoration-color: rgba(229, 255, 58, 0.3);
            transition: text-decoration-color 0.2s;
        }
        
        .message-content a:hover {
            text-decoration-color: var(--accent);
        }
        
        .message-content img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 1rem 0;
        }
        
        .message-content pre {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            overflow-x: auto;
            margin: 1rem 0;
            line-height: 1.5;
        }
        
        .message-content pre code {
            background: transparent;
            padding: 0;
            border: none;
            font-size: 0.9rem;
        }
        
        .message-content code {
            background: var(--bg-secondary);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-size: 0.9em;
            font-family: 'Courier New', Courier, monospace;
            border: 1px solid var(--border);
        }
        
        .message-content strong {
            font-weight: 600;
        }
        
        .message-content em {
            font-style: italic;
        }
        
        .message-content del {
            text-decoration: line-through;
            opacity: 0.7;
        }
        
        /* Inline code styling (backticks) */
        .message-content .inline-code,
        .inline-code {
            background: rgba(229, 255, 58, 0.2);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
            color: var(--text-primary);
        }
        

        .chat-input-area {
            padding: 1.5rem;
            background: transparent;
            position: relative;
            border-top: none;
            flex-shrink: 0;
        }

        @media (max-width: 768px) {
            .chat-input-area {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                z-index: 1000;
                padding-bottom: max(1.5rem, env(safe-area-inset-bottom));
                border-top: none;
            }
        }

        .chat-input-area::before {
            display: none;
        }

        .chat-input-area::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: calc(1.5rem + 28px);
            background: transparent;
            z-index: 0;
        }

        .input-container {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
            background: #121212;
            border-radius: 24px;
            padding: 0.5rem 0.75rem;
            border: 2px solid var(--border);
            position: relative;
            transform: translateY(0);
            z-index: 2;
        }
        
        /* Force desktop styles to override mobile !important styles */
        @media (min-width: 769px) {
            .main-content {
                height: 100vh !important;
                overflow: hidden !important;
            }
            
            .chat-header {
                padding: 1rem 1.5rem !important;
                padding-top: 1rem !important;
                padding-bottom: 1rem !important;
                min-height: auto !important;
                height: auto !important;
            }
            
            .chat-footer {
                position: relative !important;
                bottom: auto !important;
                top: auto !important;
                left: auto !important;
                right: auto !important;
                width: auto !important;
                transform: none !important;
                display: flex !important;
                margin: 0 auto !important;
                padding: 2rem 1.5rem !important;
                padding-top: 2rem !important;
                padding-bottom: 2rem !important;
                padding-left: 1.5rem !important;
                padding-right: 1.5rem !important;
                visibility: visible !important;
                opacity: 1 !important;
                min-height: auto !important;
                height: auto !important;
            }
            
            .chat-input-area {
                position: relative !important;
                bottom: auto !important;
                top: auto !important;
                left: auto !important;
                right: auto !important;
                width: auto !important;
                z-index: auto !important;
                transform: none !important;
                visibility: visible !important;
                opacity: 1 !important;
                flex-shrink: 0 !important;
            }
            
            .input-container {
                position: relative !important;
                transform: translateY(0) !important;
                margin-bottom: 0 !important;
                margin-top: 0 !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            .footer-center {
                display: flex !important;
                visibility: visible !important;
                opacity: 1 !important;
                min-height: auto !important;
                height: auto !important;
                flex-shrink: 0 !important;
            }
            
            .chat-messages {
                padding-bottom: 2rem !important;
                padding-top: 2rem !important;
            }
            
            .welcome-screen {
                margin-top: 0 !important;
                padding-top: 2rem !important;
            }
            
            .chat-header {
                position: relative !important;
                z-index: 10 !important;
            }
            
            /* Desktop light mode welcome screen - move down 10mm total */
            body.light-mode .welcome-screen {
                margin-top: calc(-1cm + 10mm) !important;
            }
        }

        body.light-mode .input-container {
            background: #f8f8f8;
            border-color: var(--border);
        }

        .input-left-controls {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            flex-shrink: 0;
        }

        .input-right-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-shrink: 0;
        }

        .chat-input-wrapper {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
        }

        .chat-input {
            flex: 1;
            padding: 0.875rem 1rem 0.875rem 3.5rem;
            background: #000000;
            border: none;
            border-radius: 24px;
            color: var(--text-primary);
            font-size: 0.95rem;
            font-family: inherit;
            resize: none;
            min-height: 44px;
            max-height: 200px;
            transition: all 0.2s;
            line-height: 1.5;
            width: 100%;
        }

        .chat-input:focus {
            outline: none;
        }

        .input-ghost-icon {
            position: absolute;
            left: 0.75rem;
            top: 50%;
            transform: translateY(-50%) scale(1.5);
            width: 32px;
            height: 32px;
            border-radius: 4px;
            object-fit: cover;
            object-position: center;
            pointer-events: none;
            z-index: 1;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            overflow: hidden;
        }

        .chat-input-area {
            padding: 1rem 1.5rem;
            background: transparent;
            position: relative;
        }


        .chat-input::placeholder {
            color: var(--text-muted);
        }

        /* Image to Image Button */
        .img-to-img-btn {
            padding: 0;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 50%;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .img-to-img-btn svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        .img-to-img-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
            background: var(--bg-tertiary);
        }

        /* Send Button - Circular */
        .send-btn {
            padding: 0;
            background: var(--accent);
            color: var(--bg-primary);
            border: none;
            border-radius: 50%;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .send-btn svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        .send-btn:hover:not(:disabled) {
            background: var(--accent-hover);
            transform: scale(1.05);
        }

        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        body.light-mode .send-btn {
            background: var(--accent) !important;
            color: #ffffff !important;
        }

        body.light-mode .send-btn:hover:not(:disabled) {
            background: var(--accent-hover) !important;
        }

        /* Voice recording button states */
        .send-btn.recording {
            background: #ff4444;
            animation: pulse-recording 1.5s ease-in-out infinite;
        }

        @keyframes pulse-recording {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Delete/Cancel recording button */
        .cancel-recording-btn {
            padding: 0;
            background: transparent;
            border: 1px solid #ff4444;
            border-radius: 50%;
            color: #ff4444;
            cursor: pointer;
            transition: all 0.2s;
            width: 36px;
            height: 36px;
            display: none;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .cancel-recording-btn.visible {
            display: flex;
        }

        .cancel-recording-btn:hover {
            background: rgba(255, 68, 68, 0.1);
            transform: scale(1.05);
        }

        .cancel-recording-btn svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        /* Info Cards */
        .info-cards {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            max-width: 1200px;
            margin: 1rem auto 0;
            padding: 0 1.5rem;
        }

        /* Download Buttons */
        .download-buttons {
            display: flex;
            justify-content: center;
            gap: 0.25rem;
            max-width: 1200px;
            margin: calc(-3.5rem - 3mm) auto 0;
            padding: 0 1.5rem;
        }

        .download-btn {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.3rem 0.6rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 0.7rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .download-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
            background: var(--bg-secondary);
            transform: translateY(-1px);
        }

        .download-btn .download-icon {
            width: 14px;
            height: 14px;
            fill: currentColor;
            flex-shrink: 0;
        }

        @media (max-width: 768px) {
            .download-buttons {
                gap: 0.25rem;
                padding: 0 1rem;
                margin: calc(-3.5rem - 3mm) auto 0;
            }

            .download-btn {
                padding: 0.25rem 0.5rem;
                font-size: 0.65rem;
            }

            .download-btn .download-icon {
                width: 12px;
                height: 12px;
            }
        }


        /* Footer */
        .chat-footer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem 1.5rem;
            padding-top: 2rem;
            padding-bottom: 2rem;
            position: relative;
            background: #000000;
            min-height: auto;
            height: auto;
            flex-shrink: 0;
        }

        .footer-link {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            color: var(--text-secondary);
            transition: all 0.2s;
            border-radius: 50%;
            border: 1px solid var(--border);
            background: transparent;
            text-decoration: none;
        }

        .footer-link:hover {
            color: var(--accent);
            border-color: var(--accent);
            background: var(--bg-tertiary);
            transform: scale(1.05);
        }

        .footer-link svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .footer-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
            min-height: auto;
            height: auto;
            flex-shrink: 0;
        }

        .footer-text {
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .footer-copyright {
            color: var(--text-muted);
            font-size: 0.75rem;
            margin: 0;
            margin-top: 0.5rem;
        }

        .footer-logo {
            width: 42px;
            height: 42px;
            border-radius: 6px;
            object-fit: cover;
            vertical-align: middle;
            margin-left: -1mm;
        }

        @media (max-width: 768px) {
            .chat-footer {
                padding: 1.5rem 1rem;
            }

            .footer-link {
                width: 36px;
                height: 36px;
            }

            .footer-link svg {
                width: 18px;
                height: 18px;
            }

            .footer-logo {
                width: 38px;
                height: 38px;
            }

            .footer-text {
                font-size: 0.75rem;
            }

            .footer-copyright {
                font-size: 0.7rem;
            }
        }

        .info-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.25rem;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            z-index: 1;
        }

        .info-card:hover,
        .info-card.expanded-active {
            z-index: 1001;
        }

        .info-card:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .info-card:active {
            transform: scale(0.98);
        }

        @media (max-width: 768px) {
            .info-card {
                padding: 1rem;
            }
        }

        .info-card h4 {
            color: var(--accent);
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .info-card h4 .lock-icon {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
            fill: currentColor;
        }

        .info-card p {
            color: var(--text-secondary);
            font-size: 0.8rem;
            line-height: 1.5;
            margin: 0;
        }

        body.light-mode .info-card h4 {
            color: var(--accent);
        }

        body.light-mode .info-card {
            background: var(--bg-secondary);
        }

        /* Expanded Card Overlay */
        .info-card-expanded {
            display: none;
            position: absolute;
            top: 0;
            left: calc(100% + 0.5rem);
            background: var(--bg-tertiary);
            border: 1px solid var(--accent);
            border-radius: 8px;
            padding: 0.625rem;
            z-index: 1002;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            width: 200px;
            max-width: calc(100vw - 2rem);
        }

        .sidebar-info-cards .info-card-expanded {
            left: calc(100% + 0.5rem);
        }

        @media (max-width: 768px) {
            .info-card-expanded {
                position: absolute;
                top: 0;
                left: 50%;
                transform: translateX(-50%);
                width: 180px;
                max-width: calc(100vw - 2rem);
                max-height: 60vh;
                overflow-y: auto;
                padding: 0.625rem;
                border-radius: 8px;
            }

            .info-card-expanded-header {
                gap: 0.35rem;
                margin-bottom: 0.35rem;
            }

            .info-card-expanded-header svg {
                width: 12px;
                height: 12px;
            }

            .info-card-expanded-header h5 {
                font-size: 0.75rem;
            }

            .info-card-expanded p {
                font-size: 0.65rem;
                line-height: 1.3;
            }

            .info-cards {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.5rem;
                padding: 0 0.75rem;
            }

            .info-card {
                padding: 0.75rem;
            }

            .info-card h4 {
                font-size: 0.8rem;
                margin-bottom: 0.25rem;
            }

            .info-card h4 .lock-icon {
                width: 14px;
                height: 14px;
            }

            .info-card p {
                font-size: 0.7rem;
            }
        }

        .info-card-expanded.show {
            display: block;
            animation: slideDown 0.2s ease;
            z-index: 1003;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @media (max-width: 768px) {
            .info-card-expanded.show {
                animation: fadeIn 0.2s ease;
            }
        }

        .info-card-expanded-header {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-bottom: 0.4rem;
        }

        .info-card-expanded-header svg {
            width: 14px;
            height: 14px;
            fill: var(--accent);
            flex-shrink: 0;
        }

        .info-card-expanded-header h5 {
            color: var(--accent);
            font-size: 0.8rem;
            font-weight: 600;
            margin: 0;
        }

        .info-card-expanded p {
            color: var(--text-secondary);
            font-size: 0.7rem;
            line-height: 1.4;
            margin: 0;
        }

        body.light-mode .info-card-expanded {
            background: var(--bg-secondary);
            border-color: var(--accent);
        }

        body.light-mode .info-card-expanded-header svg {
            fill: var(--accent);
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        body.light-mode ::-webkit-scrollbar-thumb {
            background: var(--accent);
        }

        body.light-mode ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-hover);
        }

        /* Welcome Message */
        .welcome-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            padding: 2rem;
            margin-top: -1cm;
            padding-top: 2rem;
        }

        .welcome-screen h2 {
            font-size: 2rem;
            color: var(--accent);
            margin-bottom: 1rem;
        }

        .welcome-screen p {
            color: var(--text-secondary);
            font-size: 1.1rem;
            max-width: 600px;
        }

        .welcome-screen.hidden {
            display: none;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                width: 280px;
                box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
                z-index: 200;
                transform: translateX(-100%);
            }

            .sidebar.sidebar-open {
                transform: translateX(0);
            }

            .sidebar.mobile-hidden {
                transform: translateX(-100%);
            }

            /* Hide expanded cards when sidebar is hidden on mobile */
            .sidebar.mobile-hidden .info-card-expanded {
                display: none !important;
                opacity: 0 !important;
                visibility: hidden !important;
            }

            .main-content {
                width: 100%;
            }

            .message {
                max-width: 95%;
            }

            /* Header Mobile Styles */
            .chat-header {
                padding: 0.75rem 1rem !important;
                padding-top: calc(0.75rem + env(safe-area-inset-top) - 5mm) !important;
                padding-bottom: 0.75rem !important;
                flex-wrap: wrap;
                gap: 0.5rem;
                position: fixed !important;
                top: 0;
                left: 0;
                right: 0;
                width: 100%;
                z-index: 150;
                background: var(--bg-primary);
                border-bottom: none;
                min-height: auto !important;
                height: auto !important;
            }
            
            body.light-mode .chat-header {
                padding: 0.75rem 1rem !important;
                padding-top: calc(0.75rem + env(safe-area-inset-top) - 5mm) !important;
                padding-bottom: 0.75rem !important;
                padding-left: 1rem !important;
                padding-right: 1rem !important;
                min-height: auto !important;
                height: auto !important;
                background: #ffffff !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                width: 100% !important;
            }

            /* Add padding to main content to account for fixed header */
            .main-content {
                padding-top: 70px;
            }

            /* Welcome screen should be centered properly */
            .welcome-screen {
                height: calc(100vh - 70px - 120px);
                min-height: auto;
                padding: 2rem 1rem;
                margin-top: -5mm;
            }

            /* Adjust light mode welcome screen to match dark mode positioning on mobile */
            body.light-mode .welcome-screen {
                padding-top: 1.5rem !important;
                margin-top: -1cm !important;
            }

            .chat-header-left {
                flex: 1;
                min-width: 0;
            }

            .chat-header-right {
                gap: 0.5rem;
                flex-wrap: wrap;
                justify-content: flex-end;
            }

            .tokens-badge {
                padding: 0.4rem 0.6rem;
                font-size: 0.7rem;
                gap: 0.3rem;
            }

            .tokens-badge svg {
                width: 14px;
                height: 14px;
            }

            .theme-toggle {
                width: 36px;
                height: 36px;
                padding: 0.4rem;
            }

            .theme-toggle svg {
                width: 18px;
                height: 18px;
            }

            .header-btn {
                padding: 0.4rem 0.7rem;
                font-size: 0.75rem;
                white-space: nowrap;
            }

            /* Input Container Mobile Styles */
            .chat-input-area {
                padding: 1rem;
                padding-bottom: calc(1rem + env(safe-area-inset-bottom));
                position: fixed !important;
                bottom: 0 !important;
                left: 0;
                right: 0;
                width: 100%;
                background: transparent;
                z-index: 50;
            }

            /* Add padding to chat messages to account for fixed input area */
            .chat-messages {
                padding-bottom: 120px;
            }

            .chat-input-area::before {
                top: calc(1rem + 0.5rem + 20px);
            }

            .chat-input-area::after {
                height: calc(1rem + 0.5rem + 20px);
            }

            .input-container {
                padding: 0.5rem;
                transform: translateY(0);
                transition: transform 0.3s ease-out;
                gap: 0.4rem;
                position: relative;
                z-index: 2;
                margin-bottom: 80px;
                /* Space for footer */
            }

            /* Pure CSS keyboard handling */
            .input-container:focus-within {
                margin-bottom: 0 !important;
            }

            .input-container:focus-within~.chat-footer {
                display: none !important;
            }

            /* Hide footer-center (domain section) when keyboard appears */
            .input-container:focus-within~.chat-footer .footer-center,
            .input-container.keyboard-visible~.chat-footer .footer-center {
                display: none !important;
            }

            .chat-footer .footer-center {
                display: flex;
            }

            /* Prevent body scroll when input is focused */
            @media (max-width: 768px) {

                html:has(.chat-input:focus),
                body:has(.chat-input:focus) {
                    overflow: hidden !important;
                    height: 100% !important;
                    position: fixed !important;
                    width: 100% !important;
                }

                /* Force input to bottom and cover any gaps */
                body:has(.chat-input:focus) .chat-input-area {
                    bottom: 0 !important;
                    padding-bottom: 1rem !important;
                    /* Remove safe-area padding to sit flush */
                }
            }

            .input-left-controls {
                gap: 0.4rem;
            }

            .img-to-img-btn {
                width: 32px;
                height: 32px;
            }

            .img-to-img-btn svg {
                width: 16px;
                height: 16px;
            }

            .model-toggle-container {
                gap: 0.25rem;
            }

            .model-toggle-label {
                font-size: 0.7rem;
            }

            .model-toggle-switch {
                width: 38px;
                height: 20px;
            }

            .model-toggle-switch::after {
                width: 16px;
                height: 16px;
                top: 2px;
                left: 2px;
            }

            .model-toggle-switch.active::after {
                left: 20px;
            }

            .chat-input {
                padding: 0.75rem 0.85rem 0.75rem 3rem;
                font-size: 0.9rem;
                min-height: 40px;
            }

            /* Prevent page scroll on input focus */
            .chat-input:focus {
                scroll-margin-top: 0;
            }

            /* Browser UI hiding - window must scroll, not internal elements */
            html {
                height: auto;
                min-height: 100%;
                overflow-y: scroll;
                -webkit-overflow-scrolling: touch;
            }

            body {
                height: auto;
                min-height: 100vh;
                min-height: calc(100vh + 200px);
                /* Body must be taller than viewport */
                overflow-y: scroll;
                -webkit-overflow-scrolling: touch;
                position: relative;
                width: 100%;
            }

            .main-content {
                min-height: 100vh;
                overflow: visible;
                position: relative;
                display: flex;
                flex-direction: column;
            }

            /* Add spacer at bottom to ensure window scrolling */
            body::after {
                content: '';
                display: block;
                height: 200px;
                width: 100%;
            }

            .chat-messages {
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                padding: 1rem;
                padding-top: 0.5rem;
            }

            /* Ensure input area stays at bottom */
            .chat-input-area {
                flex-shrink: 0;
            }

            /* Prevent iOS Safari from zooming on input focus */
            .chat-input {
                font-size: 16px !important;
            }

            /* Prevent page scroll when input is focused */
            .chat-input:focus {
                scroll-margin-top: 0;
            }

            /* Footer on mobile - keep fixed at bottom */
            .chat-footer {
                display: flex;
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                width: 100%;
                padding: 1.5rem 1rem;
                background: #000000;
                z-index: 1;
                transform: translateY(0);
                pointer-events: none;
            }

            .chat-footer * {
                pointer-events: auto;
            }

            /* Ensure sidebar overlay is above input area */
            .sidebar-overlay {
                z-index: 199;
            }


            .input-ghost-icon {
                left: 0.6rem;
                top: 50%;
                transform: translateY(-50%) scale(1.5);
                width: 28px;
                height: 28px;
                z-index: 1;
                object-fit: cover;
                object-position: center;
            }

            .send-btn {
                width: 32px;
                height: 32px;
            }

            .send-btn svg {
                width: 16px;
                height: 16px;
            }

            .cancel-recording-btn {
                width: 32px;
                height: 32px;
            }

            .cancel-recording-btn svg {
                width: 16px;
                height: 16px;
            }
        }

        /* Extra Small Mobile Screens */
        @media (max-width: 480px) {
            .chat-header {
                padding: 0.6rem 0.75rem !important;
                padding-top: calc(0.6rem + env(safe-area-inset-top) - 5mm) !important;
                padding-bottom: 0.6rem !important;
            }
            
            body.light-mode .chat-header {
                padding: 0.6rem 0.75rem !important;
                padding-top: calc(0.6rem + env(safe-area-inset-top) - 5mm) !important;
                padding-bottom: 0.6rem !important;
                padding-left: 0.75rem !important;
                padding-right: 0.75rem !important;
            }

            .chat-header-right {
                gap: 0.4rem;
            }

            .tokens-badge {
                padding: 0.35rem 0.5rem;
                font-size: 0.65rem;
            }

            .tokens-badge svg {
                width: 12px;
                height: 12px;
            }

            .header-btn {
                padding: 0.35rem 0.6rem;
                font-size: 0.7rem;
            }

            .theme-toggle {
                width: 32px;
                height: 32px;
                padding: 0.35rem;
            }

            .theme-toggle svg {
                width: 16px;
                height: 16px;
            }

            .chat-input-area {
                padding: 0.75rem;
            }

            .input-container {
                padding: 0.4rem;
            }

            .chat-input {
                padding: 0.7rem 0.75rem 0.7rem 2.75rem;
                font-size: 0.85rem;
            }

            .input-ghost-icon {
                left: 0.5rem;
                top: 50%;
                transform: translateY(-50%) scale(1.5);
                width: 24px;
                height: 24px;
                z-index: 1;
                object-fit: cover;
                object-position: center;
            }

            .model-toggle-label {
                font-size: 0.65rem;
            }
        }

        /* Auth Modal */
        .auth-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .auth-modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            width: 100%;
            max-width: 450px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        /* Install Instructions Modal */
        .install-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .install-modal-overlay.show {
            display: flex;
        }

        .install-modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            width: 100%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            padding: 2rem;
        }

        .install-modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 2rem;
            cursor: pointer;
            line-height: 1;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .install-modal-close:hover {
            background: var(--bg-tertiary);
        }

        .install-modal-content h2 {
            color: var(--accent);
            margin: 0 0 1.5rem 0;
            font-size: 1.5rem;
        }

        .install-instructions {
            margin-bottom: 1.5rem;
        }

        .install-step {
            margin-bottom: 1.5rem;
        }

        .install-step-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto 1rem;
            color: var(--accent);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .install-step-icon svg {
            width: 100%;
            height: 100%;
        }

        .install-step p {
            color: var(--text-primary);
            margin-bottom: 1rem;
            font-size: 1rem;
        }

        .install-step ol {
            color: var(--text-secondary);
            padding-left: 1.5rem;
            line-height: 1.8;
        }

        .install-step ol li {
            margin-bottom: 0.5rem;
        }

        .share-icon-inline {
            display: inline-flex;
            align-items: center;
            vertical-align: middle;
            margin: 0 4px;
            color: var(--accent);
        }

        .install-modal-close-btn {
            width: 100%;
            padding: 0.75rem;
            background: #e5ff3a;
            color: #000000;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .install-modal-close-btn:hover {
            background: #b8cc2e;
        }

        body.light-mode .install-modal-close-btn {
            background: #e5ff3a;
            color: #000000;
            /* 3D Effect for Light Mode */
            box-shadow: 
                0 4px 6px rgba(0, 0, 0, 0.1),
                0 2px 4px rgba(0, 0, 0, 0.06),
                inset 0 1px 0 rgba(255, 255, 255, 0.5),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
            transform: translateY(0);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            border: none !important;
        }

        body.light-mode .install-modal-close-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 8px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.3) 0%, rgba(255, 255, 255, 0) 50%, rgba(0, 0, 0, 0.05) 100%);
            pointer-events: none;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        body.light-mode .install-modal-close-btn:hover {
            background: #b8cc2e;
            transform: translateY(-2px) scale(1.02);
            box-shadow: 
                0 8px 12px rgba(0, 0, 0, 0.15),
                0 4px 6px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.6),
                inset 0 -2px 0 rgba(0, 0, 0, 0.15);
        }

        body.light-mode .install-modal-close-btn:hover::before {
            opacity: 0.8;
        }

        body.light-mode .install-modal-close-btn:active {
            transform: translateY(0) scale(0.98);
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.1),
                0 1px 2px rgba(0, 0, 0, 0.06),
                inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        body.light-mode .install-modal-close-btn:active::before {
            opacity: 0.6;
        }

        body.light-mode .install-modal-content {
            background: #ffffff;
            border-color: #e0e0e0;
        }

        body.light-mode .install-modal-close {
            color: #000000;
        }

        body.light-mode .install-modal-close:hover {
            background: #f0f0f0;
        }

        body.light-mode .install-modal-content h2 {
            color: var(--accent);
        }

        body.light-mode .install-step p {
            color: #000000;
        }

        body.light-mode .install-step ol {
            color: #333333;
        }

        .auth-modal-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .auth-modal-header h2 {
            color: var(--accent);
            font-size: 1.5rem;
            margin: 0;
        }

        .auth-modal-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .auth-modal-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .auth-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
        }

        .auth-tab {
            flex: 1;
            padding: 1rem;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
        }

        .auth-tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }

        .auth-tab:hover {
            color: var(--text-primary);
        }

        .auth-content {
            display: none;
            padding: 1.5rem;
        }

        .auth-content.active {
            display: block;
        }

        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .auth-form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .auth-form-group label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            font-weight: 500;
        }

        .auth-form-group input {
            padding: 0.75rem;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.95rem;
            font-family: inherit;
        }

        .auth-form-group input:focus {
            outline: none;
            border-color: var(--accent);
        }

        #register-verification-code::placeholder {
            color: #4caf50;
            opacity: 0.8;
        }

        #register-password::placeholder {
            color: #ff4444;
            opacity: 0.8;
        }

        .auth-error {
            color: #ff4444;
            font-size: 0.85rem;
            margin-top: 0.5rem;
            min-height: 1.2rem;
        }

        /* Verification Code Error Alert Card */
        .verification-code-alert {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 0.5rem;
            background: #ff4444;
            color: #ffffff;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-size: 0.85rem;
            box-shadow: 0 4px 12px rgba(255, 68, 68, 0.3);
            z-index: 1000;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .verification-code-alert.show {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .verification-code-alert-icon {
            flex-shrink: 0;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .verification-code-alert-icon svg {
            width: 100%;
            height: 100%;
            fill: currentColor;
        }

        .verification-code-alert-message {
            flex: 1;
            line-height: 1.4;
        }

        .verification-code-alert-close {
            flex-shrink: 0;
            background: transparent;
            border: none;
            color: #ffffff;
            cursor: pointer;
            padding: 0.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.8;
            transition: opacity 0.2s;
            border-radius: 4px;
        }

        .verification-code-alert-close:hover {
            opacity: 1;
            background: rgba(255, 255, 255, 0.1);
        }

        .verification-code-alert-close svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        body.light-mode .verification-code-alert {
            background: #ff4444;
            color: #000000;
            box-shadow: 0 4px 12px rgba(255, 68, 68, 0.4);
        }

        body.light-mode .verification-code-alert-close {
            color: #000000;
        }

        body.light-mode .verification-code-alert-close:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        .auth-submit-btn {
            padding: 0.75rem;
            background: var(--accent);
            color: var(--bg-primary);
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 0.5rem;
        }

        .auth-submit-btn:hover {
            background: var(--accent-hover);
        }

        .auth-divider {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin: 1.5rem 0;
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .auth-divider::before,
        .auth-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--border);
        }

        .auth-google-btn {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-weight: 500;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .auth-google-btn:hover {
            border-color: var(--accent);
            background: var(--bg-tertiary);
        }

        .auth-google-btn svg {
            width: 20px;
            height: 20px;
        }

        body.light-mode .auth-modal-content {
            background: var(--bg-secondary);
            border-color: var(--border);
        }

        body.light-mode .auth-form-group input {
            background: var(--bg-primary);
            border-color: var(--border);
        }

        body.light-mode .auth-google-btn {
            background: var(--bg-primary);
            border-color: var(--border);
        }

        /* Token Limit Modal */
        .token-limit-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1001;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .token-limit-modal.show {
            display: flex;
        }

        .token-limit-modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            width: 100%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .token-limit-modal-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .token-limit-modal-header h2 {
            color: var(--accent);
            font-size: 1.5rem;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .token-limit-modal-header h2::before {
            content: "";
            font-size: 1.8rem;
        }

        .token-limit-modal-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .token-limit-modal-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .token-limit-modal-body {
            padding: 1.5rem;
        }

        .token-limit-modal-body p {
            color: var(--text-primary);
            font-size: 1rem;
            line-height: 1.6;
            margin: 0 0 1.5rem 0;
        }

        .token-limit-modal-body .highlight {
            color: var(--accent);
            font-weight: 600;
        }

        .token-limit-modal-actions {
            display: flex;
            gap: 1rem;
            flex-direction: column;
        }

        .token-limit-btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            text-align: center;
            text-decoration: none;
            display: inline-block;
        }

        .token-limit-btn-primary {
            background: var(--accent);
            color: #000;
        }

        .token-limit-btn-primary:hover {
            background: #d4e500;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(229, 255, 58, 0.4);
        }

        .token-limit-btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .token-limit-btn-secondary:hover {
            background: var(--bg-primary);
        }

        body.light-mode .token-limit-modal-content {
            background: var(--bg-secondary);
            border-color: var(--border);
        }

        body.light-mode .token-limit-btn-primary {
            background: #000000 !important;
            color: #ffffff !important;
        }

        body.light-mode .token-limit-btn-primary:hover {
            background: #1a1a1a !important;
            color: #ffffff !important;
        }

        body.light-mode .token-limit-btn-primary:visited {
            color: #ffffff !important;
        }

        body.light-mode .token-limit-btn-primary:link {
            color: #ffffff !important;
        }
    </style>
    
    <!-- Markdown-it for Open WebUI-style markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.0.0/dist/markdown-it.min.js"></script>
    <!-- Highlight.js for syntax highlighting (like Open WebUI) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/shell.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/html.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/sql.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/typescript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/rust.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
</head>

<body>

    <!-- Chrome Native Install Banner -->
    <div class="chrome-install-banner" id="chrome-install-banner">
        <div class="chrome-install-banner-icon">
            <img src="/ghost.PNG" alt="InfiNet AI">
        </div>
        <div class="chrome-install-banner-text">
            <div class="chrome-install-banner-title">Install InfiNet AI</div>
            <div class="chrome-install-banner-subtitle">Get the full app experience</div>
        </div>
        <div class="chrome-install-banner-actions">
            <button class="chrome-install-btn" id="chrome-install-btn">Install</button>
            <button class="chrome-install-close" id="chrome-install-close" aria-label="Close"></button>
        </div>
    </div>

    <!-- Sidebar Overlay -->
    <!-- White backdrop to keep top area white on mobile light mode -->
    <div class="top-safe-area"></div>

    <div class="sidebar-overlay" id="sidebar-overlay" onclick="closeSidebar()"></div>

    <!-- Left Sidebar -->
    <aside class="sidebar" id="sidebar">
        <!-- Sidebar Hint -->
        <div class="sidebar-hint" id="sidebar-hint">Menu</div>
        <!-- Sidebar Handle -->
        <div class="sidebar-handle" onclick="toggleSidebar()" title="Open sidebar">
            <svg viewBox="0 0 60 80" xmlns="http://www.w3.org/2000/svg">
                <!-- Bot Antennas -->
                <g class="bot-antennas">
                    <line x1="22" y1="8" x2="22" y2="12" stroke="#e5ff3a" stroke-width="2" stroke-linecap="round" />
                    <circle cx="22" cy="8" r="2" fill="#e5ff3a" />
                    <line x1="38" y1="8" x2="38" y2="12" stroke="#e5ff3a" stroke-width="2" stroke-linecap="round" />
                    <circle cx="38" cy="8" r="2" fill="#e5ff3a" />
                </g>
                <!-- Bot Head (square, peeking from sidebar) -->
                <g class="bot-head">
                    <rect x="12" y="12" width="36" height="36" rx="3" fill="#e5ff3a" stroke="#121212"
                        stroke-width="2" />
                    <circle cx="24" cy="24" r="3" fill="#121212" class="bot-eye" />
                    <circle cx="36" cy="24" r="3" fill="#121212" class="bot-eye" />
                    <rect x="26" y="32" width="8" height="2" rx="1" fill="#121212" />
                </g>
                <!-- Bot Body (behind sidebar) -->
                <rect x="15" y="48" width="30" height="25" rx="5" fill="#e5ff3a" stroke="#121212" stroke-width="2" />
                <rect x="20" y="53" width="20" height="15" rx="2" fill="#121212" opacity="0.3" />
                <!-- Right Hand (hanging on edge) -->
                <g class="bot-hand-right">
                    <rect x="52" y="58" width="8" height="20" rx="4" fill="#e5ff3a" stroke="#121212" stroke-width="2" />
                    <circle cx="56" cy="60" r="2" fill="#121212" />
                </g>
            </svg>
        </div>
        <div class="sidebar-header">
            <img src="/untrans.PNG" alt="Logo" onerror="this.style.display='none'">
            <h1>Uncensored<br>InfiNet AI</h1>
        </div>

        <div class="sidebar-actions">
            <button class="btn-new-chat" onclick="newChat()">+ New Chat</button>
        </div>

        <div class="sidebar-conversations" id="conversations">
            <!-- Conversations will be added here -->
        </div>

        <!-- Info Cards in Sidebar -->
        <div class="sidebar-info-cards">
            <div class="info-card" onmouseenter="showExpandedCard('privacy')" onmouseleave="hideExpandedCard('privacy')"
                ontouchstart="toggleExpandedCard('privacy')" onclick="toggleExpandedCard('privacy')">
                <h4>
                    <svg class="lock-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"
                            fill="currentColor" />
                    </svg>
                    100% Private
                </h4>
                <p>Client-side stored conversations only</p>
                <div class="info-card-expanded" id="privacy-expanded">
                    <div class="info-card-expanded-header">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path
                                d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"
                                fill="currentColor" />
                        </svg>
                        <h5>100% Private</h5>
                    </div>
                    <p>All your conversations and generated content are entirely your property. We do not store your datayour privacy is our top priority.</p>
                </div>
            </div>
        </div>

        <div class="sidebar-footer">
             <a href="/profile" id="sidebar-profile-link" onclick="handleProfileLinkClick(event)">
                <svg class="sidebar-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path
                        d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"
                        fill="currentColor" />
                </svg>
                <span id="sidebar-profile-text">Profile</span>
            </a>
            <a href="/pricing">
                <svg class="sidebar-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path
                        d="M11.8 10.9c-2.27-.59-3-1.2-3-2.15 0-1.09 1.01-1.85 2.7-1.85 1.78 0 2.44.85 2.5 2.1h2.21c-.07-1.72-1.12-3.3-3.21-3.81V3h-3v2.16c-1.94.42-3.5 1.68-3.5 3.61 0 2.31 1.91 3.46 4.7 4.13 2.5.6 3 1.48 3 2.41 0 .69-.49 1.79-2.7 1.79-2.06 0-2.87-.92-2.98-2.1h-2.2c.12 2.19 1.76 3.42 3.68 3.83V21h3v-2.15c1.95-.37 3.5-1.5 3.5-3.55 0-2.84-2.43-3.81-4.7-4.4z"
                        fill="currentColor" />
                </svg>
                Pricing
            </a>
            <a href="/features">
                <svg class="sidebar-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"
                        fill="currentColor" />
                </svg>
                Features
            </a>
            <a href="/doc">
                <svg class="sidebar-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path
                        d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z"
                        fill="currentColor" />
                </svg>
                Documentation
            </a>
        </div>

        <div class="sidebar-socials">
            <div class="sidebar-cta-wrapper">
                <a class="sidebar-cta" href="#" id="sidebar-web-btn" onclick="handleWebAppInstall(event)" title="Add to Home Screen">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-5 14H4v-4h11v4zm0-5H4V9h11v4zm5 5h-4V9h4v9z"
                            fill="currentColor" />
                    </svg>
                    Web App
                </a>
                <div class="sidebar-links-wrapper">
                    <a href="/privacy" class="sidebar-link-text">Privacy</a>
                    <span style="color: #e5ff3a; font-size: 0.75rem;"></span>
                    <a href="/terms" class="sidebar-link-text">Terms</a>
                </div>
            </div>
        </div>
    </aside>

    <!-- Main Chat Area -->
    <main class="main-content">
        <div class="chat-header">
            <div class="chat-header-left">
                <select class="model-selector" id="model-select" style="display: none;">
                    <option value="model1">Coder</option>
                    <option value="model2">Thinker</option>
                </select>
            </div>
            <div class="chat-header-right">
                <div class="tokens-badge" id="tokens-badge">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M20 6H17.82C17.93 5.69 18 5.35 18 5C18 3.34 16.66 2 15 2C13.95 2 13.04 2.54 12.5 3.35L12 4.02L11.5 3.34C10.96 2.54 10.05 2 9 2C7.34 2 6 3.34 6 5C6 5.35 6.07 5.69 6.18 6H4C2.89 6 2.01 6.89 2.01 8L2 19C2 20.11 2.89 21 4 21H20C21.11 21 22 20.11 22 19V8C22 6.89 21.11 6 20 6ZM15 4C15.55 4 16 4.45 16 5C16 5.55 15.55 6 15 6C14.45 6 14 5.55 14 5C14 4.45 14.45 4 15 4ZM9 4C9.55 4 10 4.45 10 5C10 5.55 9.55 6 9 6C8.45 6 8 5.55 8 5C8 4.45 8.45 4 9 4ZM20 19H4V17H20V19ZM20 15H4V8H20V15Z"
                            fill="currentColor" />
                    </svg>
                    <span id="tokens-badge-text">Free 10000 Tokens</span>
                </div>
                <button class="theme-toggle" id="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
                    <svg id="theme-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M21.64 13a1 1 0 0 0-1.05-.14 8.05 8.05 0 0 1-3.37.73 8.15 8.15 0 0 1-8.14-8.1 8.59 8.59 0 0 1 .25-2A1 1 0 0 0 8 2.36 10.14 10.14 0 1 0 22 14.05 1 1 0 0 0 21.64 13Z"
                            fill="currentColor" />
                    </svg>
                </button>
                <button class="header-btn" onclick="showPricing()">Pricing</button>
                <button class="header-btn primary" onclick="showRegister()"><strong>Hop In</strong></button>
            </div>
        </div>

        <div class="chat-messages" id="chat-messages">
            <div class="particles-container">
                <canvas class="particles-canvas" id="particles-canvas"></canvas>
            </div>
            <div class="welcome-screen" id="welcome-screen">
                <h2>Welcome to Uncensored InfiNet AI</h2>
                <p>Experience unrestricted AI conversations with no filters or limitations. Hop in to start a conversation.</p>
            </div>
        </div>
        <button class="scroll-to-bottom-btn" id="scroll-to-bottom-btn" onclick="scrollToBottom()" title="Scroll to bottom">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" fill="#000000" stroke="#000000" stroke-width="1.5" stroke-linejoin="round"/>
            </svg>
        </button>
        <div class="chat-input-area">
            <div class="input-container">
                <div class="input-left-controls">
                    <button class="cancel-recording-btn" id="cancel-recording-btn" onclick="cancelRecording()" title="Cancel Recording">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" fill="currentColor" />
                        </svg>
                    </button>
                    <button class="img-to-img-btn" id="img-to-img-btn" onclick="openImageToImage()"
                        title="Image to Image">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path
                                d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"
                                fill="currentColor" />
                        </svg>
                    </button>
                    <div class="model-toggle-container">
                        <div class="model-toggle-switch" id="model-toggle" onclick="toggleModel()"></div>
                        <span class="model-toggle-label" id="model-label">Coder</span>
                    </div>
                </div>
                <div class="chat-input-wrapper">
                    <img src="/untrans.PNG" alt="Ghost" class="input-ghost-icon" onerror="console.error('Failed to load untrans.PNG:', this.src); this.style.display='none';" onload="console.log('untrans.PNG loaded successfully');">
                    <textarea class="chat-input" id="message-input" placeholder="Ask me anything..." rows="1"
                        enterkeyhint="send" onkeydown="handleKeyDown(event)" oninput="autoResize(this); updateSendButton();"></textarea>
                </div>
                <div class="input-right-controls">
                    <button class="send-btn" id="send-btn" onclick="handleSendButtonClick()" title="Send">
                        <svg id="send-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="display: none;">
                            <path d="M12 4l-8 8h5v8h6v-8h5l-8-8z" fill="currentColor" />
                        </svg>
                        <svg id="voice-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z" fill="currentColor" />
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Footer -->
            <footer class="chat-footer">
                <a href="https://infinet.services/" target="_blank" class="footer-link footer-link-left"
                    title="Visit InfiNet Services">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM18.92 8h-2.95c-.32-1.25-.78-2.45-1.38-3.56 1.84.63 3.37 1.91 4.33 3.56zM12 4.04c.83 1.2 1.48 2.53 1.91 3.96h-3.82c.43-1.43 1.08-2.76 1.91-3.96zM4.26 14C4.1 13.36 4 12.69 4 12s.1-1.36.26-2h3.38c-.08.66-.14 1.32-.14 2 0 .68.06 1.34.14 2H4.26zm.82 2h2.95c.32 1.25.78 2.45 1.38 3.56-1.84-.63-3.37-1.9-4.33-3.56zm2.95-8H4.26c.96-1.66 2.49-2.93 4.33-3.56C8.03 5.55 7.57 6.75 7.25 8zM12 19.96c-.83-1.2-1.48-2.53-1.91-3.96h3.82c-.43 1.43-1.08 2.76-1.91 3.96zM14.34 14H9.66c-.09-.66-.16-1.32-.16-2 0-.68.07-1.34.16-2h4.68c.09.66.16 1.32.16 2 0 .68-.07 1.34-.16 2zm.25 5.56c.6-1.11 1.06-2.31 1.38-3.56h2.95c-.96 1.65-2.49 2.93-4.33 3.56zM16.36 14c.08-.66.14-1.32.14-2 0-.68-.06-1.34-.14-2h3.38c.16.64.26 1.31.26 2s-.1 1.36-.26 2h-3.38z"
                            fill="currentColor" />
                    </svg>
                </a>
                <div class="footer-center">
                    <p class="footer-text">Powered by <img src="/logo.PNG" alt="InfiNet Logo" class="footer-logo"
                            onerror="this.style.display='none'"></p>
                    <p class="footer-copyright"> 2026 InfiNet AI. All rights reserved.</p>
                </div>
                <a href="mailto:admin@infinet.services" class="footer-link footer-link-right" title="Contact Us">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"
                            fill="currentColor" />
                    </svg>
                </a>
            </footer>

            <input type="file" id="image-upload" accept="image/*" style="display: none;"
                onchange="handleImageUpload(event)">
            <input type="file" id="img-to-img-upload" accept="image/*" style="display: none;"
                onchange="handleImageToImageUpload(event)">
        </div>
    </main>

    <script>
        let currentConversation = null;
        let conversations = [];
        let currentUser = null;
        
        // API Base URL
        const API_BASE = window.location.origin;
        
        // Block internal ingest/debug calls that are failing CORS in production
        (function shimLocalIngest() {
            if (!window.fetch) return;
            const originalFetch = window.fetch.bind(window);
            window.fetch = (input, init) => {
                try {
                    const url = typeof input === 'string' ? input : (input && input.url);
                    if (url && (url.includes('127.0.0.1:7242') || url.includes('127.0.0.1:7243'))) {
                        // Skip debug/ingest calls silently
                        return Promise.resolve(new Response(null, { status: 204 }));
                    }
                } catch (err) {
                    console.warn('Fetch shim error', err);
                }
                return originalFetch(input, init);
            };
        })();

        // Connected Particle Network - Properly handles theme changes
        (function initParticleNetwork() {
            const canvas = document.getElementById('particles-canvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            let particles = [];
            const particleCount = 50;
            const connectionDistance = 150;
            let animationId = null;

            function getColors() {
                const isLightMode = document.body.classList.contains('light-mode');
                const welcomeScreen = document.getElementById('welcome-screen');
                const hasConversation = welcomeScreen && welcomeScreen.classList.contains('hidden');
                
                // When no conversation (welcome screen visible) - full opacity
                // When conversation active (welcome screen hidden) - lighter opacity (50% of original)
                const conversationOpacity = hasConversation ? 0.5 : 1.0;
                
                // Base opacities
                const baseParticleOpacity = isLightMode ? 0.4 : 0.6;
                const baseLineOpacity = isLightMode ? 0.2 : 0.3;
                
                // Apply conversation opacity multiplier
                const particleOpacity = baseParticleOpacity * conversationOpacity;
                const lineOpacity = baseLineOpacity * conversationOpacity;
                
                return {
                    particle: isLightMode 
                        ? `rgba(0, 0, 0, ${particleOpacity})` 
                        : `rgba(229, 255, 58, ${particleOpacity})`,
                    line: lineOpacity,
                    lineColor: isLightMode ? 'rgba(0, 0, 0, ' : 'rgba(229, 255, 58, '
                };
            }

            function resizeCanvas() {
                const container = canvas.parentElement;
                if (container) {
                    canvas.width = container.offsetWidth;
                    canvas.height = container.offsetHeight;
                    initParticles();
                }
            }

            class Particle {
                constructor() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.vx = (Math.random() - 0.5) * 0.5;
                    this.vy = (Math.random() - 0.5) * 0.5;
                    this.radius = Math.random() * 2 + 1;
                }

                update() {
                    this.x += this.vx;
                    this.y += this.vy;

                    if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
                    if (this.y < 0 || this.y > canvas.height) this.vy *= -1;

                    this.x = Math.max(0, Math.min(canvas.width, this.x));
                    this.y = Math.max(0, Math.min(canvas.height, this.y));
                }

                draw(particleColor) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = particleColor;
                    ctx.fill();
                }
            }

            function initParticles() {
                particles = [];
                for (let i = 0; i < particleCount; i++) {
                    particles.push(new Particle());
                }
            }

            function drawConnections(colors) {
                for (let i = 0; i < particles.length; i++) {
                    for (let j = i + 1; j < particles.length; j++) {
                        const dx = particles[i].x - particles[j].x;
                        const dy = particles[i].y - particles[j].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < connectionDistance) {
                            const opacity = (1 - distance / connectionDistance) * colors.line;
                            ctx.beginPath();
                            ctx.moveTo(particles[i].x, particles[i].y);
                            ctx.lineTo(particles[j].x, particles[j].y);
                            ctx.strokeStyle = `${colors.lineColor}${opacity})`;
                            ctx.lineWidth = 0.5;
                            ctx.stroke();
                        }
                    }
                }
            }

            function animate() {
                const colors = getColors();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                particles.forEach(particle => {
                    particle.update();
                    particle.draw(colors.particle);
                });

                drawConnections(colors);
                animationId = requestAnimationFrame(animate);
            }

            // Initialize
            resizeCanvas();
            animate();

            // Handle window resize
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    resizeCanvas();
                }, 100);
            });

            // Watch for theme changes - update colors dynamically
            const observer = new MutationObserver(() => {
                // Colors are updated in animate() function via getColors()
                // No need to reload or reinitialize
            });

            observer.observe(document.body, {
                attributes: true,
                attributeFilter: ['class']
            });
        })();
        
        // Check authentication and load user
        async function checkAuth() {
            try {
                const response = await fetch(`${API_BASE}/api/user/me`, {
                    credentials: 'include'
                });
                
                if (response.ok) {
                    const userData = await response.json();
                    // Map API response to frontend format
                    currentUser = {
                        id: userData.id,
                        email: userData.email,
                        name: userData.displayName || userData.email.split('@')[0],
                        displayName: userData.displayName || null, // Keep null if not set
                        avatar: userData.profilePicture || null, // Map profilePicture to avatar (API returns profilePicture, not profile_picture)
                        profile_picture: userData.profilePicture || null,
                        plan: userData.plan || 'free',
                        emailVerified: userData.emailVerified || false,
                        googleId: userData.googleId || null,
                        tokens: userData.remainingToken !== undefined ? userData.remainingToken : (userData.tokens || 0), // Use remainingToken (uncensored.chat style)
                        remainingToken: userData.remainingToken !== undefined ? userData.remainingToken : (userData.tokens || 0)
                    };
                    isAuthenticated = true; // Set global flag
                    localStorage.setItem('currentUser', JSON.stringify(currentUser));
                    localStorage.setItem('isAuthenticated', 'true');
                    console.log('User authenticated:', currentUser);
                    console.log('Profile picture:', currentUser.profile_picture);
                    console.log('Display name:', currentUser.displayName);
                    return true;
                } else {
                    // Not authenticated - redirect to login or allow guest mode
                    isAuthenticated = false; // Set global flag
                    currentUser = null;
                    localStorage.removeItem('currentUser');
                    localStorage.removeItem('isAuthenticated');
                    console.log('User not authenticated');
                    return false;
                }
            } catch (error) {
                console.error('Auth check error:', error);
                isAuthenticated = false; // Set global flag
                currentUser = null;
                return false;
            }
        }

        // Update tokens badge in header (requires authentication like uncensored.chat)
        async function updateTokensBadge() {
            const badge = document.getElementById('tokens-badge');
            const badgeText = document.getElementById('tokens-badge-text');
            if (!badge || !badgeText) return;

            // Only show tokens if authenticated
            if (!isAuthenticated || !currentUser) {
                badgeText.textContent = 'Start a session to view tokens';
                return;
            }
            // #region agent log
            fetch('http://127.0.0.1:7243/ingest/44364179-96d7-4a0f-ac4f-9f610636e213',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({sessionId:'debug-session',runId:'run1',hypothesisId:'H3',location:'index.html:updateTokensBadge',message:'updateTokensBadge called',data:{isAuthenticated,hasCurrentUser:!!currentUser,badgeText:badgeText.textContent},timestamp:Date.now()})}).catch(()=>{});
            // #endregion

            try {
                const response = await fetch(`${API_BASE}/api/user/tokens`, {
                    credentials: 'include'
                });

                if (response.ok) {
                    const data = await response.json();
                    // Use remainingToken field (matching uncensored.chat) or fallback to tokens
                    const tokensRemaining = data.remainingToken !== undefined ? data.remainingToken : (data.tokens || 0);
                    const plan = data.plan || 'free';
                    
                    // Handle unlimited tokens (owner plan)
                    if (tokensRemaining === Infinity || tokensRemaining === 'Infinity' || tokensRemaining === 'unlimited' || plan === 'owner') {
                        badgeText.textContent = 'Unlimited Tokens';
                    } else if (plan === 'free') {
                        badgeText.textContent = `Free ${tokensRemaining.toLocaleString()} Tokens`;
                    } else {
                        badgeText.textContent = `${tokensRemaining.toLocaleString()} Tokens`;
                    }
                } else if (response.status === 401) {
                    // Session expired - re-check authentication
                    console.log('Session expired, re-checking authentication...');
                    badgeText.textContent = 'Start a session to view tokens';
                    const authResult = await checkAuth();
                    if (!authResult) {
                        // Session really expired - update UI
                        isAuthenticated = false;
                        currentUser = null;
                        localStorage.removeItem('currentUser');
                        localStorage.removeItem('isAuthenticated');
                        updateAuthUI();
                    } else {
                        // Session restored - update UI and try again
                        updateAuthUI();
                        await updateTokensBadge();
                    }
                } else {
                    badgeText.textContent = 'Sign in to view tokens';
                }
            } catch (error) {
                console.error('Error updating tokens badge:', error);
                badgeText.textContent = 'Sign in to view tokens';
            }
        }
        
        // Load conversations from API
        async function loadConversationsFromAPI() {
            try {
                const response = await fetch(`${API_BASE}/api/conversations`, {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    if (response.status === 401) {
                        // Not authenticated - use localStorage as fallback
                        console.log('Not authenticated, using localStorage fallback');
                        conversations = JSON.parse(localStorage.getItem('conversations') || '[]');
                        updateConversationsList();
                        return;
                    }
                    throw new Error('Failed to load conversations');
                }
                
                const data = await response.json();
                conversations = data.conversations.map(conv => ({
                    id: conv.id,
                    title: conv.title,
                    model: conv.model,
                    createdAt: conv.createdAt,
                    updatedAt: conv.updatedAt,
                    messages: [] // Will be loaded separately when needed
                }));
                
                updateConversationsList();
            } catch (error) {
                console.error('Error loading conversations:', error);
                // Fallback to localStorage
                conversations = JSON.parse(localStorage.getItem('conversations') || '[]');
                updateConversationsList();
            }
        }
        
        // Load a conversation with all messages from API
        async function loadConversationFromAPI(conversationId) {
            try {
                console.log('[loadConversationFromAPI] Fetching conversation:', conversationId);
                const response = await fetch(`${API_BASE}/api/conversations/${conversationId}`, {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    console.error('[loadConversationFromAPI] Response not OK:', response.status, response.statusText);
                    throw new Error('Failed to load conversation');
                }
                
                const conversation = await response.json();
                console.log('[loadConversationFromAPI] Received conversation:', {
                    id: conversation.id,
                    title: conversation.title,
                    messageCount: conversation.messages?.length || 0
                });
                return conversation;
            } catch (error) {
                console.error('[loadConversationFromAPI] Error loading conversation:', error);
                return null;
            }
        }
        
        // Create a new conversation via API
        async function createConversationAPI(model = 'model1') {
            try {
                const response = await fetch(`${API_BASE}/api/conversations`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        title: 'New Chat',
                        model: model
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to create conversation');
                }
                
                const data = await response.json();
                return data.conversation;
            } catch (error) {
                console.error('Error creating conversation:', error);
                // Fallback: create local conversation
                return {
                    id: 'local_' + Date.now(),
                    title: 'New Chat',
                    model: model,
                    messages: []
                };
            }
        }
        
        // Add a message to conversation via API
        async function addMessageToConversationAPI(conversationId, role, content) {
            try {
                const response = await fetch(`${API_BASE}/api/conversations/${conversationId}/messages`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        role: role,
                        content: content
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to add message');
                }
                
                const data = await response.json();
                return data.message;
            } catch (error) {
                console.error('Error adding message:', error);
                return null;
            }
        }
        
        // Update sidebar profile link based on auth status
        function updateSidebarProfileLink() {
            const profileLink = document.getElementById('sidebar-profile-link');
            const profileText = document.getElementById('sidebar-profile-text');
            
            if (!profileLink || !profileText) return;
            
            if (isAuthenticated && currentUser) {
                profileLink.href = '/profile';
                profileText.textContent = 'Profile';
            } else {
                profileLink.href = '/#auth';
                profileText.textContent = 'Hop In';
            }
        }
        
        // Advanced Device Fingerprinting - Multi-factor identification
        // Uses multiple browser APIs to create a persistent device fingerprint
        // that survives IP changes, cookie clearing, and browser restarts
        async function generateAdvancedFingerprint() {
            const components = [];
            
            // 1. Canvas Fingerprinting (rendering differences)
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 200;
                canvas.height = 50;
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.textBaseline = 'alphabetic';
                ctx.fillStyle = '#f60';
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = '#069';
                ctx.fillText('InfiNetAI-FP', 2, 15);
                ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
                ctx.fillText('InfiNetAI-FP', 4, 17);
                components.push('canvas:' + canvas.toDataURL().substring(0, 100));
            } catch (e) {
                components.push('canvas:error');
            }
            
            // 2. WebGL Fingerprinting
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl) {
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    if (debugInfo) {
                        components.push('webgl_vendor:' + gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL));
                        components.push('webgl_renderer:' + gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL));
                    }
                    components.push('webgl_version:' + gl.getParameter(gl.VERSION));
                    components.push('webgl_shading:' + gl.getParameter(gl.SHADING_LANGUAGE_VERSION));
                }
            } catch (e) {
                components.push('webgl:error');
            }
            
            // 3. Audio Context Fingerprinting
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const analyser = audioContext.createAnalyser();
                const gainNode = audioContext.createGain();
                const scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);
                
                gainNode.gain.value = 0;
                oscillator.connect(analyser);
                analyser.connect(scriptProcessor);
                scriptProcessor.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.start(0);
                scriptProcessor.onaudioprocess = (event) => {
                    const output = event.inputBuffer.getChannelData(0);
                    const hash = Array.from(output.slice(0, 100)).reduce((acc, val) => acc + Math.abs(val), 0);
                    components.push('audio:' + hash.toFixed(2));
                    audioContext.close();
                };
                // Timeout fallback
                setTimeout(() => {
                    if (!components.some(c => c.startsWith('audio:'))) {
                        components.push('audio:timeout');
                    }
                }, 100);
            } catch (e) {
                components.push('audio:error');
            }
            
            // 4. Screen Properties
            components.push('screen:' + screen.width + 'x' + screen.height + 'x' + screen.colorDepth);
            components.push('avail:' + screen.availWidth + 'x' + screen.availHeight);
            components.push('pixelRatio:' + (window.devicePixelRatio || 1));
            
            // 5. Timezone & Language
            components.push('timezone:' + Intl.DateTimeFormat().resolvedOptions().timeZone);
            components.push('language:' + navigator.language);
            components.push('languages:' + (navigator.languages ? navigator.languages.join(',') : navigator.language));
            
            // 6. Hardware Info
            if (navigator.hardwareConcurrency) {
                components.push('cpu:' + navigator.hardwareConcurrency);
            }
            if (navigator.deviceMemory) {
                components.push('memory:' + navigator.deviceMemory);
            }
            if (navigator.maxTouchPoints) {
                components.push('touch:' + navigator.maxTouchPoints);
            }
            
            // 7. Platform Info
            components.push('platform:' + navigator.platform);
            components.push('userAgent:' + navigator.userAgent.substring(0, 50));
            
            // 8. Installed Fonts (via canvas)
            const testFonts = ['Arial', 'Verdana', 'Times New Roman', 'Courier New', 'Georgia', 'Palatino', 'Garamond', 'Bookman', 'Comic Sans MS', 'Trebuchet MS', 'Impact'];
            const fontString = testFonts.map(font => {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const baseline = ctx.measureText('abcdefghijklmnopqrstuvwxyz0123456789').width;
                    ctx.font = `72px ${font}, monospace`;
                    const width = ctx.measureText('abcdefghijklmnopqrstuvwxyz0123456789').width;
                    return width !== baseline ? '1' : '0';
                } catch (e) {
                    return '0';
                }
            }).join('');
            components.push('fonts:' + fontString);
            
            // 9. Browser Plugins
            if (navigator.plugins && navigator.plugins.length > 0) {
                const plugins = Array.from(navigator.plugins).map(p => p.name).join(',');
                components.push('plugins:' + plugins.substring(0, 100));
            }
            
            // 10. WebGL Parameters (additional)
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl');
                if (gl) {
                    components.push('gl_vendor:' + gl.getParameter(gl.VENDOR));
                    components.push('gl_renderer:' + gl.getParameter(gl.RENDERER));
                }
            } catch (e) {}
            
            // Hash all components together
            const fingerprintString = components.join('|');
            const encoder = new TextEncoder();
            const data = encoder.encode(fingerprintString);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const fingerprint = hashArray.map(b => b.toString(16).padStart(2, '0')).join('').substring(0, 64);
            
            return fingerprint;
        }
        
        // Device Fingerprint Management - Multi-layer persistence with advanced fingerprinting
        async function getOrCreateDeviceFingerprint() {
            const STORAGE_KEY = 'device_fingerprint';
            const ADVANCED_FP_KEY = 'advanced_device_fingerprint';
            
            // 1. Try localStorage (simple fingerprint)
            let fingerprint = localStorage.getItem(STORAGE_KEY);
            
            // 2. Try IndexedDB
            if (!fingerprint) {
                try {
                    const db = await new Promise((resolve, reject) => {
                        const request = indexedDB.open('InfiNetAI', 1);
                        request.onerror = () => reject(request.error);
                        request.onsuccess = () => resolve(request.result);
                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains('fingerprints')) {
                                db.createObjectStore('fingerprints');
                            }
                        };
                    });
                    
                    const transaction = db.transaction(['fingerprints'], 'readonly');
                    const store = transaction.objectStore('fingerprints');
                    const request = store.get(STORAGE_KEY);
                    
                    fingerprint = await new Promise((resolve, reject) => {
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                } catch (err) {
                    console.log('[Device Fingerprint] IndexedDB not available:', err);
                }
            }
            
            // 3. Try advanced fingerprint (more persistent)
            if (!fingerprint) {
                try {
                    fingerprint = localStorage.getItem(ADVANCED_FP_KEY);
                    if (!fingerprint) {
                        const db = await new Promise((resolve, reject) => {
                            const request = indexedDB.open('InfiNetAI', 1);
                            request.onerror = () => reject(request.error);
                            request.onsuccess = () => resolve(request.result);
                            request.onupgradeneeded = (event) => {
                                const db = event.target.result;
                                if (!db.objectStoreNames.contains('fingerprints')) {
                                    db.createObjectStore('fingerprints');
                                }
                            };
                        });
                        
                        const transaction = db.transaction(['fingerprints'], 'readonly');
                        const store = transaction.objectStore('fingerprints');
                        const request = store.get(ADVANCED_FP_KEY);
                        
                        fingerprint = await new Promise((resolve, reject) => {
                            request.onsuccess = () => resolve(request.result);
                            request.onerror = () => reject(request.error);
                        });
                    }
                } catch (err) {
                    console.log('[Device Fingerprint] Advanced fingerprint read failed:', err);
                }
            }
            
            // 4. Generate new advanced fingerprint if none found
            if (!fingerprint) {
                console.log('[Device Fingerprint] Generating new advanced fingerprint...');
                fingerprint = await generateAdvancedFingerprint();
                
                // Store in all available locations
                try {
                    localStorage.setItem(STORAGE_KEY, fingerprint);
                    localStorage.setItem(ADVANCED_FP_KEY, fingerprint);
                } catch (e) {
                    console.log('[Device Fingerprint] localStorage not available');
                }
                
                try {
                    const db = await new Promise((resolve, reject) => {
                        const request = indexedDB.open('InfiNetAI', 1);
                        request.onerror = () => reject(request.error);
                        request.onsuccess = () => resolve(request.result);
                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains('fingerprints')) {
                                db.createObjectStore('fingerprints');
                            }
                        };
                    });
                    
                    const transaction = db.transaction(['fingerprints'], 'readwrite');
                    const store = transaction.objectStore('fingerprints');
                    store.put(fingerprint, STORAGE_KEY);
                    store.put(fingerprint, ADVANCED_FP_KEY);
                } catch (err) {
                    console.log('[Device Fingerprint] IndexedDB write failed:', err);
                }
            }
            
            return fingerprint;
        }
        
        // Send device fingerprint in headers for all fetch requests
        const originalFetch = window.fetch;
        window.fetch = async function(...args) {
            const fingerprint = await getOrCreateDeviceFingerprint();
            
            // Add fingerprint to headers if it's a Request object or URL string
            if (args[0] instanceof Request) {
                args[0].headers.set('x-device-fingerprint', fingerprint);
            } else if (typeof args[0] === 'string') {
                if (!args[1]) args[1] = {};
                if (!args[1].headers) args[1].headers = {};
                args[1].headers['x-device-fingerprint'] = fingerprint;
            }
            
            return originalFetch.apply(this, args);
        };
        
        // Handle profile link click
        function handleProfileLinkClick(event) {
            if (!isAuthenticated || !currentUser) {
                event.preventDefault();
                // If we're already on index page, just open the modal
                if (window.location.pathname === '/' || window.location.pathname === '/index.html') {
                    document.getElementById('auth-modal').style.display = 'flex';
                } else {
                    // Redirect to index with auth hash
                    window.location.href = '/#auth';
                }
            }
            // If authenticated, let the default link behavior work
        }

        // Web App Install Handler
        let deferredPrompt = null;
        // Expose to window so banner can access it
        window.deferredPrompt = null;

        function handleWebAppInstall(event) {
            event.preventDefault();
            
            // Check if already installed
            if (window.matchMedia('(display-mode: standalone)').matches || 
                window.navigator.standalone === true) {
                alert('This app is already installed on your device!');
                return;
            }

            // Check if browser supports install prompt
            if (deferredPrompt) {
                // Show the install prompt
                deferredPrompt.prompt();
                
                // Wait for the user to respond to the prompt
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('User accepted the install prompt');
                    } else {
                        console.log('User dismissed the install prompt');
                    }
                    deferredPrompt = null;
                });
            } else {
                // Fallback for browsers that don't support beforeinstallprompt
                // Show instructions based on device
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                const isAndroid = /Android/.test(navigator.userAgent);
                
                // Show install instructions modal
                showInstallInstructions();
            }
        }

        function showInstallInstructions() {
            const modal = document.getElementById('install-instructions-modal');
            if (modal) {
                modal.classList.add('show');
            }
        }

        function closeInstallModal() {
            const modal = document.getElementById('install-instructions-modal');
            if (modal) {
                modal.classList.remove('show');
            }
        }

        // Listen for the beforeinstallprompt event
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent the mini-infobar from appearing on mobile
            e.preventDefault();
            // Stash the event so it can be triggered later (both local and window)
            deferredPrompt = e;
            window.deferredPrompt = e;
            
            console.log('[PWA] beforeinstallprompt event - stored in global deferredPrompt');
            
            // Update button text/title to indicate install is available
            const webBtn = document.getElementById('sidebar-web-btn');
            if (webBtn) {
                webBtn.title = 'Add to Home Screen';
            }
        });

        // Listen for app installed event
        window.addEventListener('appinstalled', () => {
            console.log('PWA was installed');
            deferredPrompt = null;
            window.deferredPrompt = null;
            
            // Update button to show it's installed
            const webBtn = document.getElementById('sidebar-web-btn');
            if (webBtn) {
                webBtn.title = 'App Installed';
            }
        });
        
        // Initialize: Check auth and load conversations
        (async function init() {
            // Check for OAuth redirect parameters
            const urlParams = new URLSearchParams(window.location.search);
            const authStatus = urlParams.get('auth');
            const error = urlParams.get('error');
            
            // Check for #auth hash to open auth modal
            if (window.location.hash === '#auth') {
                // Wait a bit for page to load, then open modal
                setTimeout(() => {
                    document.getElementById('auth-modal').style.display = 'flex';
                    // Remove hash from URL without reload
                    window.history.replaceState(null, null, window.location.pathname + window.location.search);
                }, 100);
            }

            // If redirected with ?auth=login, open the auth modal
            if (authStatus === 'login') {
                setTimeout(() => {
                    const modal = document.getElementById('authModal') || document.getElementById('auth-modal');
                    if (modal) {
                        modal.style.display = 'flex';
                    }
                    // Clean the URL to avoid reopening on refresh
                    const cleanedUrl = window.location.pathname + window.location.search.replace(/([?&])auth=login(&)?/, (m, p1, p2) => {
                        if (p1 === '?' && p2) return '?';
                        return p1 === '?' ? '' : p1 === '&' ? '&' : '';
                    });
                    window.history.replaceState({}, document.title, cleanedUrl);
                }, 50);
            }
            
            // Check for #register hash to open auth modal with register tab
            if (window.location.hash === '#register') {
                // Wait a bit for page to load, then open modal and switch to register tab
                setTimeout(() => {
                    document.getElementById('auth-modal').style.display = 'flex';
                    switchAuthTab('register');
                    // Remove hash from URL without reload
                    window.history.replaceState(null, null, window.location.pathname + window.location.search);
                }, 100);
            }
            
            if (error === 'oauth_not_configured') {
                alert('Google OAuth is not configured. Please set up Google OAuth credentials.');
            } else if (error === 'auth_failed') {
                alert('Authentication failed. Please try again.');
            } else if (error === 'oauth_error') {
                const message = urlParams.get('message') || 'OAuth error occurred';
                alert('OAuth Error: ' + decodeURIComponent(message));
            } else if (authStatus === 'success') {
                console.log('OAuth authentication successful');
                // Reload auth state after OAuth success
                const authResult = await checkAuth();
                if (authResult) {
                    // checkAuth() already sets isAuthenticated and currentUser
                    await loadConversationsFromAPI();
                    updateConversationsList(); // Explicitly update the list
                    updateAuthUI();
                    updateSidebarProfileLink();
                    // Close auth modal if open
                    const authModal = document.getElementById('authModal');
                    if (authModal) {
                        authModal.style.display = 'none';
                    }
                } else {
                    console.error('Failed to authenticate after OAuth success');
                }
                // Clean up URL parameters
                window.history.replaceState({}, document.title, window.location.pathname);
                // Update tokens badge
                await updateTokensBadge();
                return; // Exit early - don't continue to the else block below
            }
            
            // Clean up URL parameters
            if (authStatus || error) {
                window.history.replaceState({}, document.title, window.location.pathname);
            }
            
            // Only check auth if not already handled by OAuth success
            if (authStatus !== 'success') {
                const isAuthenticated = await checkAuth();
                if (isAuthenticated) {
                    await loadConversationsFromAPI();
                    updateConversationsList();
                    updateAuthUI();
                } else {
                    // Not authenticated - clear conversations and use localStorage
                    conversations = [];
                    const savedConversations = JSON.parse(localStorage.getItem('conversations') || '[]');
                    conversations = savedConversations;
                    updateConversationsList();
                }
                updateSidebarProfileLink();
            } else {
                // Guest mode - use localStorage (this should not be reached after OAuth success due to return above)
                conversations = JSON.parse(localStorage.getItem('conversations') || '[]');
                updateConversationsList();
                updateSidebarProfileLink();
            }
            
            // Update tokens badge (for both authenticated and non-authenticated users)
            await updateTokensBadge();
        })();


        // CRITICAL: Initialize sidebar IMMEDIATELY when script loads
        // This must happen before any conversation loading to prevent state issues
        (function initializeSidebarImmediate() {
            function resetSidebar() {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('sidebar-overlay');

                if (sidebar && overlay) {
                    // Force reset all sidebar states first - always hidden by default
                    sidebar.classList.remove('sidebar-open');
                    sidebar.classList.add('mobile-hidden');
                    overlay.classList.remove('show');
                }
            }

            // Try immediately
            resetSidebar();

            // Also try when DOM is ready (if not already ready)
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', resetSidebar);
            }

            // And on next frame to ensure everything is painted
            requestAnimationFrame(function () {
                setTimeout(resetSidebar, 0);
            });
        })();

        // Load selected conversation if coming from other pages
        // This runs after init() completes
        (async function() {
            // Wait a bit for init() to complete and conversations to load
            await new Promise(resolve => setTimeout(resolve, 500));
            
            const selectedConvId = localStorage.getItem('selectedConversationId');
            if (selectedConvId) {
                // Convert to number if it's a numeric string (from API)
                const convIdNum = isNaN(selectedConvId) ? selectedConvId : parseInt(selectedConvId, 10);
                
                // If authenticated, reload conversations from API first
                if (currentUser) {
                    await loadConversationsFromAPI();
                    updateConversationsList();
                } else {
                    // Not authenticated - reload from localStorage
                    const savedConversations = JSON.parse(localStorage.getItem('conversations') || '[]');
                    if (savedConversations.length > 0) {
                        conversations = savedConversations;
                        updateConversationsList();
                    }
                }

                // Find the conversation by ID (check both string and number)
                const selectedConv = conversations.find(c => c.id == convIdNum || c.id == selectedConvId);
                if (selectedConv || (currentUser && typeof convIdNum === 'number')) {
                    // Load the conversation using ID
                    // Use setTimeout to ensure DOM is fully ready
                    setTimeout(async function () {
                        await loadConversation(convIdNum);
                        localStorage.removeItem('selectedConversationId');
                    }, 200);
                } else {
                    console.error('Selected conversation not found:', selectedConvId);
                    localStorage.removeItem('selectedConversationId');
                }
            }
        })();

        async function newChat() {
            // Create a new conversation via API (if authenticated) or locally
            const model = currentModel || 'model2';
            
            if (currentUser) {
                // Authenticated - create via API
                try {
                    const newConv = await createConversationAPI(model);
            currentConversation = {
                        id: newConv.id,
                        title: newConv.title,
                messages: [],
                        model: newConv.model
                    };
                } catch (error) {
                    console.error('Error creating conversation via API:', error);
                    // Fallback to local
                    currentConversation = {
                        id: 'local_' + Date.now(),
                        messages: [],
                        model: model
                    };
                }
            } else {
                // Guest mode - create local conversation
                currentConversation = {
                    id: 'local_' + Date.now(),
                    messages: [],
                    model: model
                };
            }

            // Clear the chat UI
            clearChat();

            // Focus the input field so user can start typing immediately
            const input = document.getElementById('message-input');
            if (input) {
                setTimeout(() => {
                    input.focus();
                }, 100);
            }

            // Close sidebar on mobile after creating new chat
            if (window.innerWidth <= 768) {
                closeSidebar();
            }
        }

        async function deleteConversation(convId) {
            // Delete from API if authenticated and conversation ID is numeric
            if (currentUser && typeof convId === 'number') {
                try {
                    const response = await fetch(`${API_BASE}/api/conversations/${convId}`, {
                        method: 'DELETE',
                        credentials: 'include'
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to delete conversation');
                    }
                } catch (error) {
                    console.error('Error deleting conversation:', error);
                    alert('Failed to delete conversation. Please try again.');
                    return;
                }
            }
            
            // Remove from local array
            conversations = conversations.filter(conv => conv.id !== convId);
            if (currentConversation && currentConversation.id === convId) {
                currentConversation = null;
                clearChat();
            }
            
            // Update localStorage if guest mode
            if (!currentUser) {
            localStorage.setItem('conversations', JSON.stringify(conversations));
            }
            
            // Reload conversations from API if authenticated
            if (currentUser) {
                await loadConversationsFromAPI();
            } else {
            updateConversationsList();
            }
        }

        function updateConversationsList() {
            const container = document.getElementById('conversations');
            if (!container) return; // Exit if container doesn't exist (not on index page)

            container.innerHTML = '';

            // If authenticated, conversations are already loaded from API
            // If guest mode, use localStorage
            if (!currentUser) {
            const savedConversations = JSON.parse(localStorage.getItem('conversations') || '[]');
            if (savedConversations.length > 0) {
                conversations = savedConversations;

                // If we have a currentConversation, update it with the latest from localStorage
                if (currentConversation) {
                    const updatedConv = conversations.find(c => c.id === currentConversation.id);
                    if (updatedConv) {
                        currentConversation = updatedConv;
                        }
                    }
                }
            }

            if (conversations.length === 0) {
                // Keep same padding structure - container already has padding: 0.5rem
                const emptyDiv = document.createElement('div');
                emptyDiv.style.padding = '0';
                emptyDiv.style.color = 'var(--text-muted)';
                emptyDiv.style.fontSize = '0.85rem';
                emptyDiv.style.textAlign = 'center';
                emptyDiv.textContent = 'No conversations yet';
                container.appendChild(emptyDiv);
                return;
            }

            conversations.forEach(conv => {
                const item = document.createElement('div');
                // Compare by ID instead of reference to ensure correct active state
                item.className = 'conversation-item' + (currentConversation && conv.id === currentConversation.id ? ' active' : '');
                
                // Use title if available, otherwise use first message content, otherwise "New Chat"
                let preview = 'New Chat';
                if (conv.title && conv.title !== 'New Chat' && conv.title.trim() !== '') {
                    preview = conv.title;
                } else if (conv.messages && conv.messages.length > 0 && conv.messages[0].content) {
                    preview = conv.messages[0].content.substring(0, 30) + '...';
                }

                const content = document.createElement('div');
                content.className = 'conversation-item-content';
                content.textContent = preview;
                content.onclick = () => handleConversationClick(conv);

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'conversation-delete-btn';
                deleteBtn.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z" fill="currentColor"/></svg>';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteConversation(conv.id);
                };
                deleteBtn.title = 'Delete conversation';

                item.appendChild(content);
                item.appendChild(deleteBtn);
                container.appendChild(item);
            });
        }

        async function loadConversation(conv) {
            const convId = typeof conv === 'object' ? conv.id : conv;
            console.log('[loadConversation] Loading conversation:', convId, 'Type:', typeof convId);
            
            // Convert to number if it's a numeric string (from API)
            const convIdNum = (typeof convId === 'string' && !isNaN(convId)) ? parseInt(convId, 10) : convId;
            
            // Clear current conversation state first
            currentConversation = null;
            
            // Clear the chat messages container (preserve particles-container)
            const container = document.getElementById('chat-messages');
            if (container) {
                const particlesContainer = container.querySelector('.particles-container');
                const welcome = container.querySelector('.welcome-screen');
                Array.from(container.children).forEach(child => {
                    if (child !== particlesContainer && child !== welcome) {
                        child.remove();
                    }
                });
            }
            
            // If authenticated and conversation ID is numeric (from database), load from API
            if (currentUser && typeof convIdNum === 'number') {
                console.log('[loadConversation] Loading from API, conversation ID:', convIdNum);
                const loadedConv = await loadConversationFromAPI(convIdNum);
                console.log('[loadConversation] API response:', loadedConv);
                if (loadedConv) {
                    currentConversation = {
                        id: loadedConv.id,
                        title: loadedConv.title,
                        model: loadedConv.model,
                        messages: loadedConv.messages || []
                    };
                    currentModel = loadedConv.model || 'model1';
                    console.log('[loadConversation] Loaded conversation with', currentConversation.messages.length, 'messages');
                } else {
                    console.log('[loadConversation] API load failed, trying local fallback');
                    // Fallback to local - try both number and string comparison
                    const foundConv = conversations.find(c => c.id == convIdNum || c.id == convId);
                    if (!foundConv) {
                        console.error('[loadConversation] Conversation not found locally:', convIdNum);
                        return;
                    }
                    currentConversation = foundConv;
                    currentModel = foundConv.model || 'model1';
                    console.log('[loadConversation] Using local conversation with', currentConversation.messages?.length || 0, 'messages');
                }
            } else {
                console.log('[loadConversation] Loading from local storage, conversation ID:', convIdNum);
                // Guest mode or local conversation - use local data (try both number and string)
                const foundConv = conversations.find(c => c.id == convIdNum || c.id == convId);
                if (!foundConv) {
                    console.error('[loadConversation] Conversation not found:', convIdNum);
                    return;
                }
                currentConversation = foundConv;
                currentModel = foundConv.model || 'model1';
                console.log('[loadConversation] Using local conversation with', currentConversation.messages?.length || 0, 'messages');
            }

            // Update model toggle UI
            const toggle = document.getElementById('model-toggle');
            const label = document.getElementById('model-label');
            if (toggle && label) {
                if (currentModel === 'model2') {
                    toggle.classList.add('active');
                    label.textContent = 'Thinker';
                } else {
                    toggle.classList.remove('active');
                    label.textContent = 'Coder';
                }
            }

            // Refresh conversations list and render messages
            updateConversationsList();
            
            // Always render messages - renderMessages() will handle empty case
            console.log('[loadConversation] Rendering messages, conversation has', currentConversation?.messages?.length || 0, 'messages');
            await renderMessages();

            // CRITICAL: Reset expanded cards after loading conversation to ensure hover works
            // This fixes the issue where cards don't pop up on hover after redirect from "New Chat" button
            setTimeout(function () {
                closeAllExpandedCards();
                // Clear any inline styles that might block hover events
                const allExpanded = document.querySelectorAll('.info-card-expanded');
                allExpanded.forEach(expanded => {
                    expanded.style.display = '';
                    expanded.style.opacity = '';
                    expanded.style.visibility = '';
                    expanded.style.pointerEvents = '';
                });
            }, 150);
        }

        function clearChat() {
            const container = document.getElementById('chat-messages');
            const welcome = document.getElementById('welcome-screen');

            if (container) {
                // Remove all children except particles-container and welcome-screen
                const particlesContainer = container.querySelector('.particles-container');
                Array.from(container.children).forEach(child => {
                    if (child !== particlesContainer && child !== welcome) {
                        child.remove();
                    }
                });
            }

            if (welcome) {
                welcome.classList.remove('hidden');
            }
        }

        async function renderMessages() {
            const container = document.getElementById('chat-messages');
            const welcome = document.getElementById('welcome-screen');

            if (!container) {
                console.error('[renderMessages] Container not found!');
                return;
            }

            if (!currentConversation) {
                console.log('[renderMessages] No current conversation, showing welcome');
                if (welcome) welcome.classList.remove('hidden');
                return;
            }

            if (!currentConversation.messages || currentConversation.messages.length === 0) {
                console.log('[renderMessages] No messages in conversation, showing welcome');
                if (welcome) welcome.classList.remove('hidden');
                return;
            }

            console.log('[renderMessages] Rendering', currentConversation.messages.length, 'messages');
            if (welcome) welcome.classList.add('hidden');
            
            // Remove all children except particles-container and welcome-screen
            const particlesContainer = container.querySelector('.particles-container');
            Array.from(container.children).forEach(child => {
                if (child !== particlesContainer && child !== welcome && !child.classList.contains('message')) {
                    child.remove();
                }
            });
            
            // Remove existing messages
            const existingMessages = container.querySelectorAll('.message');
            existingMessages.forEach(msg => msg.remove());

            for (const msg of currentConversation.messages) {
                const index = currentConversation.messages.indexOf(msg);
                console.log(`[renderMessages] Rendering message ${index + 1}:`, msg.role, msg.content?.substring(0, 50));
                await addMessageToUI(msg.role, msg.content, false);
            }
        }

        async function addMessageToUI(role, content, isLoading = false) {
            const container = document.getElementById('chat-messages');
            const welcome = document.getElementById('welcome-screen');

            if (!container) {
                console.error('chat-messages container not found!');
                return null;
            }

            if (welcome) {
                welcome.classList.add('hidden');
            }

            // Refresh currentUser data if authenticated to ensure we have latest profile picture
            if (role === 'user' && isAuthenticated && !currentUser?.profile_picture && !currentUser?.avatar) {
                try {
                    await checkAuth();
                } catch (error) {
                    console.error('Error refreshing user data:', error);
                }
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;

            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            if (role === 'user') {
                // Check if user has a profile picture - try multiple sources
                const avatarUrl = currentUser && (currentUser.profile_picture || currentUser.avatar || currentUser.profilePicture || currentUser.picture);
                // #region agent log
                fetch('http://127.0.0.1:7243/ingest/44364179-96d7-4a0f-ac4f-9f610636e213',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({sessionId:'debug-session',runId:'run1',hypothesisId:'H1',location:'index.html:addMessageToUI',message:'Avatar selection for message',data:{isAuthenticated,hasCurrentUser:!!currentUser,avatarUrl,profile_picture:currentUser?.profile_picture,avatar:currentUser?.avatar,profilePicture:currentUser?.profilePicture,picture:currentUser?.picture},timestamp:Date.now()})}).catch(()=>{});
                // #endregion
                console.log('Message avatar check:', { 
                    hasCurrentUser: !!currentUser, 
                    isAuthenticated,
                    profile_picture: currentUser?.profile_picture, 
                    avatar: currentUser?.avatar, 
                    profilePicture: currentUser?.profilePicture,
                    picture: currentUser?.picture,
                    avatarUrl,
                    currentUserKeys: currentUser ? Object.keys(currentUser) : []
                });
                if (avatarUrl && avatarUrl.trim() !== '' && avatarUrl !== 'null' && avatarUrl !== 'undefined') {
                    // Show user's profile picture
                    const img = document.createElement('img');
                    img.src = avatarUrl;
                    img.alt = 'User';
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    img.style.borderRadius = '50%';
                    img.onerror = function() {
                        console.error('Failed to load profile picture:', avatarUrl);
                        // Fallback to 'U' if image fails to load
                        const userInitial = (currentUser?.displayName || currentUser?.name || (currentUser?.email ? currentUser.email.split('@')[0] : 'U')).charAt(0).toUpperCase();
                        avatar.textContent = userInitial || 'U';
                        avatar.classList.add('no-photo');
                    };
                    avatar.appendChild(img);
                } else {
                    // Fallback to 'U' if no profile picture
                    console.log('No profile picture found, showing default initial');
                    const userInitial = (currentUser?.displayName || currentUser?.name || (currentUser?.email ? currentUser.email.split('@')[0] : 'U')).charAt(0).toUpperCase();
                    avatar.textContent = userInitial || 'U';
                    avatar.classList.add('no-photo');
                }
            } else {
                // Use untrans.PNG image for AI assistant
                const img = document.createElement('img');
                img.src = '/untrans.PNG';
                img.alt = 'AI';
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'cover';
                img.style.borderRadius = '50%';
                avatar.appendChild(img);
            }

            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';

            if (isLoading) {
                // Different loading text based on model
                // Check if this is an image generation request - use more specific keywords
                const lastUserMessage = currentConversation.messages && 
                    currentConversation.messages.length > 0 &&
                    currentConversation.messages[currentConversation.messages.length - 1].role === 'user' ?
                    currentConversation.messages[currentConversation.messages.length - 1].content?.toLowerCase() || '' : '';
                
                // Check if the last message has imageData (image-to-image request)
                const lastMessage = currentConversation.messages && 
                    currentConversation.messages.length > 0 &&
                    currentConversation.messages[currentConversation.messages.length - 1];
                const hasImageData = lastMessage && lastMessage.role === 'user' && lastMessage.imageData;
                
                // More specific image request detection - only show image loader for clear image requests
                const isImageRequest = hasImageData || (lastUserMessage && (
                    lastUserMessage.startsWith('[image-to-image]') ||
                    lastUserMessage.includes('generate image') ||
                    lastUserMessage.includes('create image') ||
                    lastUserMessage.includes('make image') ||
                    lastUserMessage.includes('draw image') ||
                    lastUserMessage.includes('image of') ||
                    lastUserMessage.includes('picture of') ||
                    lastUserMessage.includes('photo of') ||
                    lastUserMessage.includes('generate a picture') ||
                    lastUserMessage.includes('create a picture') ||
                    lastUserMessage.includes('generate a photo') ||
                    lastUserMessage.includes('create a photo') ||
                    lastUserMessage.includes('text to image') ||
                    lastUserMessage.includes('image generation') ||
                    (lastUserMessage.includes('image') && (lastUserMessage.includes('generate') || lastUserMessage.includes('create') || lastUserMessage.includes('draw'))) ||
                    (lastUserMessage.includes('picture') && (lastUserMessage.includes('generate') || lastUserMessage.includes('create'))) ||
                    (lastUserMessage.includes('photo') && (lastUserMessage.includes('generate') || lastUserMessage.includes('create')))
                ));
                
                if (isImageRequest) {
                    // Check if this is image-to-image (has imageData) vs text-to-image
                    const isImageToImageRequest = hasImageData;
                    const additionalText = isImageToImageRequest ? '<p style="margin-bottom: 10px; color: #888; font-size: 12px;">This process could take up to 15 minutes.</p>' : '';
                    
                    contentDiv.innerHTML = `
                        <div style="text-align: center; padding: 20px;">
                            <p style="margin-bottom: 15px; color: #666;">This may take a while... Please do not refresh or leave this page!</p>
                            ${additionalText}
                            <div style="background: #f0f0f0; border-radius: 10px; padding: 3px; margin-bottom: 10px;">
                                <div id="image-progress-bar" style="background: linear-gradient(90deg, #4CAF50, #45a049); height: 20px; border-radius: 8px; width: 0%; transition: width 0.3s ease;"></div>
                            </div>
                            <div id="image-progress-text" style="color: #666; font-size: 14px;">Generating... 0%</div>
                        </div>
                    `;
                } else {
                    const loadingText = (currentModel === 'model2') ? 'Thinking...' : 'Analyzing...';
                    contentDiv.innerHTML = `<span class="loading"></span> ${loadingText}`;
                }
            } else {
                // Format message with markdown support
                contentDiv.innerHTML = formatMessage(content);
                
                // Add copy button for assistant messages
                if (role === 'assistant') {
                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'message-copy-btn';
                    copyBtn.title = 'Copy message';
                    copyBtn.innerHTML = `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" fill="currentColor"/>
                    </svg>`;
                    copyBtn.onclick = async (e) => {
                        e.stopPropagation();
                        try {
                            // Get plain text content (strip HTML)
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = content;
                            const plainText = tempDiv.textContent || tempDiv.innerText || content;
                            
                            await navigator.clipboard.writeText(plainText);
                            
                            // Visual feedback
                            const originalHTML = copyBtn.innerHTML;
                            copyBtn.innerHTML = `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" fill="currentColor"/>
                            </svg>`;
                            copyBtn.style.color = 'var(--accent)';
                            
                            setTimeout(() => {
                                copyBtn.innerHTML = originalHTML;
                                copyBtn.style.color = '';
                            }, 2000);
                        } catch (err) {
                            console.error('Failed to copy:', err);
                            // Fallback for older browsers
                            const textArea = document.createElement('textarea');
                            textArea.value = content.replace(/<[^>]*>/g, '');
                            textArea.style.position = 'fixed';
                            textArea.style.opacity = '0';
                            document.body.appendChild(textArea);
                            textArea.select();
                            try {
                                document.execCommand('copy');
                                const originalHTML = copyBtn.innerHTML;
                                copyBtn.innerHTML = `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" fill="currentColor"/>
                                </svg>`;
                                copyBtn.style.color = 'var(--accent)';
                                setTimeout(() => {
                                    copyBtn.innerHTML = originalHTML;
                                    copyBtn.style.color = '';
                                }, 2000);
                            } catch (fallbackErr) {
                                console.error('Fallback copy failed:', fallbackErr);
                            }
                            document.body.removeChild(textArea);
                        }
                    };
                    contentDiv.appendChild(copyBtn);
                }
            }

            messageDiv.appendChild(avatar);
            messageDiv.appendChild(contentDiv);
            container.appendChild(messageDiv);

            container.scrollTop = container.scrollHeight;
            checkScrollPosition();

            return messageDiv;
        }

        // API Configuration - Loaded dynamically from server
        let API_CONFIG = {
            baseUrl: window.location.origin,
            models: {
                model1: { // Coder model (fallback)
                    name: 'InfiNet-Coder',
                    apiKey: 'YOUR_WEBUI_API_KEY_1',
                    endpoint: '/api/ollama/chat',
                    modelName: 'hf.co/mradermacher/Huihui-Qwen3-Coder-30B-A3B-Instruct-abliterated-i1-GGUF:Q3_K_M'
                },
                model2: { // Thinker model (fallback)
                    name: 'InfiNet-Thinker',
                    apiKey: 'YOUR_WEBUI_API_KEY_2',
                    endpoint: '/api/ollama/chat',
                    modelName: 'hf.co/DavidAU/Qwen3-4B-Gemini-TripleX-High-Reasoning-Thinking-Heretic-Uncensored-GGUF:Q8_0'
                }
            }
        };

        // Load model configuration from server
        async function loadModelConfig() {
            try {
                const response = await fetch('/api/models/config');
                if (response.ok) {
                    const config = await response.json();
                    API_CONFIG.models = config.models;
                    API_CONFIG.baseUrl = window.location.origin;
                    console.log('Model config loaded from server:', API_CONFIG);
                } else {
                    console.warn('Failed to load model config from server, using fallback');
                }
            } catch (error) {
                console.error('Error loading model config:', error);
                console.warn('Using fallback model configuration');
            }
        }

        // Load config on page load
        loadModelConfig();
        
        // Initialize send button state
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', updateSendButton);
        } else {
            setTimeout(updateSendButton, 100);
        }

        async function sendMessage() {
            console.log('sendMessage called');
            const input = document.getElementById('message-input');
            if (!input) {
                console.error('Input element not found!');
                return;
            }

            const message = input.value.trim();
            console.log('Message:', message);

            // Check if there's a pending image-to-image
            const hasImageToImage = pendingImageToImage !== null;
            
            if (!message && !hasImageToImage) {
                console.log('Empty message and no image, returning');
                return;
            }
            
            if (hasImageToImage && !message) {
                // Show error if image is uploaded but no prompt
                showErrorNotification('Please enter a prompt describing what you want to change in the image');
                return;
            }

            const sendBtn = document.getElementById('send-btn');
            let loadingMsg = null;

            try {
                // Disable input and button immediately
                input.disabled = true;
                if (sendBtn) sendBtn.disabled = true;

                // Initialize conversation if needed
                if (!currentConversation) {
                    console.log('Creating new conversation');
                    try {
                        await newChat();
                    } catch (error) {
                        console.error('Error in newChat:', error);
                        // Create conversation manually if newChat fails
                        currentConversation = {
                            id: Date.now(),
                            messages: [],
                            model: currentModel || 'model1'
                        };
                    }
                }

                // Ensure currentConversation exists before setting model
                if (!currentConversation) {
                    console.error('Failed to create conversation, cannot send message');
                    throw new Error('Failed to initialize conversation');
                }

                // Ensure currentModel is defined
                if (typeof currentModel === 'undefined') {
                    console.warn('currentModel is undefined, defaulting to model1 (Coder)');
                    currentModel = 'model1';
                }

                console.log('Current model:', currentModel);

                // Use currentModel from toggle
                currentConversation.model = currentModel;

                // Get current model config
                const modelConfig = API_CONFIG.models[currentModel];
                console.log('Model config:', modelConfig);

                if (!modelConfig) {
                    throw new Error(' Oops! The AI model setup seems incomplete. Please refresh the page and try again!');
                }

                // Check if this is the first message (conversation not in list yet)
                const convIndex = conversations.findIndex(c => c.id === currentConversation.id);
                const isFirstMessage = convIndex === -1;

                // Refresh user data to ensure we have latest profile picture before displaying message
                if (isAuthenticated) {
                    try {
                        await checkAuth();
                        console.log('User data refreshed before sending message:', {
                            profile_picture: currentUser?.profile_picture,
                            avatar: currentUser?.avatar
                        });
                    } catch (error) {
                        console.error('Error refreshing user data:', error);
                    }
                }

                // If there's a pending image, show it first
                if (hasImageToImage && pendingImageToImage) {
                    await addImageToImageToChat(pendingImageToImage, message);
                    // Clear the pending image and preview
                    pendingImageToImage = null;
                    const preview = document.querySelector('.image-preview-container');
                    if (preview) {
                        preview.remove();
                    }
                    // Reset placeholder
                    input.placeholder = 'Ask me anything...';
                } else {
                    // Add user message to conversation
                    console.log('Adding user message to conversation');
                    currentConversation.messages.push({ role: 'user', content: message });

                    // Save user message to API if authenticated
                    if (currentUser && typeof currentConversation.id === 'number') {
                        await addMessageToConversationAPI(currentConversation.id, 'user', message);
                    }

                    // Add user message to UI
                    await addMessageToUI('user', message);
                }

                // Clear input after message is added to UI
                input.value = '';
                autoResize(input);
                updateSendButton(); // Return button to voice mode

                // If this is the first message, reload from API to get the new conversation
                if (isFirstMessage) {
                    // Don't add manually - let loadConversationsFromAPI handle it
                    // Reload conversations from API to get the new one (this will add it to the list)
                    if (currentUser) {
                        await loadConversationsFromAPI();
                        // After reloading, update currentConversation to match what's in the list
                        const updatedConv = conversations.find(c => c.id === currentConversation.id);
                        if (updatedConv) {
                            currentConversation = {
                                ...updatedConv,
                                messages: currentConversation.messages // Keep local messages
                            };
                        }
                    } else {
                        // Guest mode - add manually
                        conversations.unshift(currentConversation);
                    }
                } else {
                    // Update the existing conversation in the array
                    conversations[convIndex] = {
                        ...conversations[convIndex],
                        ...currentConversation,
                        messages: currentConversation.messages
                    };
                }

                // Save to localStorage as backup (for guest mode or offline)
                if (!currentUser) {
                localStorage.setItem('conversations', JSON.stringify(conversations));
                }

                // Update sidebar title immediately with first message
                updateConversationsList();

                // Show loading
                console.log('Showing loading message');
                loadingMsg = await addMessageToUI('assistant', '', true);

                console.log('Starting API call');
                // Prepare messages for API (include conversation history)
                const messages = currentConversation.messages.map(msg => {
                    const messageObj = {
                        role: msg.role,
                        content: msg.content
                    };
                    // Include image data if present (for image-to-image)
                    if (msg.imageData) {
                        messageObj.imageData = msg.imageData;
                        console.log('[Image-to-Image] Including imageData in message, size:', msg.imageData.length);
                    }
                    return messageObj;
                });

                console.log('Prepared messages:', messages.length, 'messages');
                console.log('Last message has imageData:', messages[messages.length - 1]?.imageData ? 'YES' : 'NO');

                let response;
                let data;
                let assistantMessage = ''; // Declare at function scope for error handling

                // Always use /api/ollama/chat endpoint when API key is available
                if (modelConfig.apiKey && modelConfig.apiKey.trim() !== '') {
                    console.log('Making API call to /api/ollama/chat');
                    console.log('API Key (first 10 chars):', modelConfig.apiKey.substring(0, 10) + '...');

                    try {
                        // Make API call to local /api/ollama/chat endpoint with streaming
                        // Use keepalive and cache control to help keep connection alive
                        const controller = new AbortController();
                        // Don't abort when page is hidden - let it continue
                        window._currentStreamingAbortController = controller;
                        
                        response = await fetch("/api/ollama/chat", {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                "X-API-Key": modelConfig.apiKey,
                                "Cache-Control": "no-cache",
                                "Accept": "text/event-stream"
                            },
                            credentials: 'include', // Include session cookie for token tracking
                            // keepalive removed to avoid Safari 64kb queued data limit
                            signal: controller.signal,
                            body: JSON.stringify({
                                type: "conversation",
                                messages: messages,
                                stream: true
                            })
                        });

                        console.log('Response status:', response.status, response.statusText);

                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({ error: ` Connection hiccup! The server responded with ${response.status}. Please try again!` }));
                            console.error('API Error response:', errorData);
                            // Check for insufficient tokens error (status 402)
                            if (response.status === 402 && (errorData.error?.toLowerCase().includes('insufficient tokens') || errorData.error?.toLowerCase().includes('token'))) {
                                throw new Error('Insufficient tokens');
                            }
                            throw new Error(errorData.error || ` Connection hiccup! The server responded with ${response.status}. Please try again!`);
                        }
                    } catch (fetchError) {
                        // Check if fetch error is due to page visibility
                        const fetchErrorMessage = fetchError.message || '';
                        const isFetchVisibilityError = fetchError.name === 'AbortError' || 
                                                       fetchErrorMessage.includes('Load failed') ||
                                                       fetchErrorMessage.includes('Failed to fetch') ||
                                                       fetchErrorMessage.includes('network') ||
                                                       (document.hidden && fetchErrorMessage);
                        
                        if (isFetchVisibilityError && document.hidden) {
                            // Page was hidden during fetch - don't show error
                            console.log('Fetch cancelled due to page visibility - silently handling');
                            if (loadingMsg) {
                                loadingMsg.remove();
                            }
                            // Re-enable input
                            input.disabled = false;
                            if (sendBtn) sendBtn.disabled = false;
                            input.focus();
                            return; // Exit early, don't show error
                        }
                        // Real fetch error - rethrow to be caught by outer catch
                        throw fetchError;
                    }

                    // Handle streaming response
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    assistantMessage = ''; // Reset for new message
                    let buffer = '';
                    let streamInterrupted = false;
                    
                    // Track streaming state globally for visibility handling
                    window._currentStreamingState = {
                        active: true,
                        conversationId: currentConversation.id,
                        loadingMsg: loadingMsg,
                        startTime: Date.now()
                    };

                    if (!loadingMsg || !loadingMsg.querySelector('.message-content')) {
                        throw new Error('Loading message element not found in UI');
                    }

                    const messageContent = loadingMsg.querySelector('.message-content');
                    
                    // Improved UI update mechanism - single source of truth, no race conditions
                    let lastUpdateTime = 0;
                    const UPDATE_THROTTLE = 100; // Update every 100ms max
                    let updateTimer = null;
                    let isUpdating = false;
                    
                    // Improved update function with proper debouncing and no race conditions
                    const updateUI = () => {
                        // If already updating, mark that we need another update after this one
                        if (isUpdating) {
                            // Set flag to update again after current update completes
                            updateTimer = setTimeout(() => updateUI(), UPDATE_THROTTLE);
                            return;
                        }
                        
                        // Clear any pending timer
                        if (updateTimer) {
                            clearTimeout(updateTimer);
                            updateTimer = null;
                        }
                        
                            const now = Date.now();
                        const timeSinceLastUpdate = now - lastUpdateTime;
                        
                        // If enough time has passed, update immediately
                        if (timeSinceLastUpdate >= UPDATE_THROTTLE) {
                            isUpdating = true;
                            lastUpdateTime = now;
                            
                            // Use requestAnimationFrame for smooth DOM updates
                        requestAnimationFrame(() => {
                            try {
                                // Always use the current assistantMessage (single source of truth)
                                if (assistantMessage.trim()) {
                                    // If it's an image generation or already contains HTML, set directly without formatting
                                    if (isImageGeneration && assistantMessage.includes('<img') && assistantMessage.includes('<div')) {
                                        messageContent.innerHTML = assistantMessage;
                                    } else {
                                        messageContent.innerHTML = formatMessage(assistantMessage);
                                    }
                                    const container = document.getElementById('chat-messages');
                                    if (container) {
                                        container.scrollTop = container.scrollHeight;
                                        checkScrollPosition();
                                    }
                                }
                                } finally {
                                    isUpdating = false;
                                }
                            });
                            } else {
                            // Schedule update for later - don't clear/reschedule if one is already pending
                            if (!updateTimer) {
                                const delay = UPDATE_THROTTLE - timeSinceLastUpdate;
                                updateTimer = setTimeout(() => {
                                    updateTimer = null;
                                    updateUI();
                                }, delay);
                            }
                        }
                    };
                    
                    // Force immediate update (for final updates)
                    const forceUpdateUI = () => {
                        // Clear any pending updates
                        if (updateTimer) {
                            clearTimeout(updateTimer);
                            updateTimer = null;
                        }
                        
                        // Wait for current update to finish if in progress
                        if (isUpdating) {
                            // Wait a bit and try again
                            setTimeout(() => forceUpdateUI(), 50);
                            return;
                        }
                        
                        isUpdating = true;
                        lastUpdateTime = Date.now();
                        
                        requestAnimationFrame(() => {
                            try {
                                if (assistantMessage.trim()) {
                                    // If it's an image generation or already contains HTML, set directly without formatting
                                    if (isImageGeneration && assistantMessage.includes('<img') && assistantMessage.includes('<div')) {
                                        messageContent.innerHTML = assistantMessage;
                                    } else {
                                        messageContent.innerHTML = formatMessage(assistantMessage);
                                    }
                                } else {
                                    // If message is empty, show a warning
                                    messageContent.innerHTML = formatMessage(' Response received but was empty. Please try again.');
                                }
                                
                                        const container = document.getElementById('chat-messages');
                                        if (container) {
                                            container.scrollTop = container.scrollHeight;
                                            checkScrollPosition();
                                        }
                            } finally {
                                isUpdating = false;
                            }
                        });
                    };

                    // Periodic save of partial content during long streams (every 30 seconds)
                    // NOTE: This only saves to state, does NOT update UI (to avoid conflicts)
                    let lastSaveTime = Date.now();
                    const SAVE_INTERVAL = 30000; // 30 seconds
                    const partialSaveInterval = setInterval(() => {
                        if (assistantMessage.trim() && Date.now() - lastSaveTime > SAVE_INTERVAL) {
                            // Save partial message to prevent data loss
                            console.log('Auto-saving partial message during long stream:', assistantMessage.length, 'chars');
                            if (window._currentStreamingState) {
                                window._currentStreamingState.partialMessage = assistantMessage;
                                window._currentStreamingState.lastSaveTime = Date.now();
                            }
                            // DO NOT update UI here - let the normal update mechanism handle it
                            lastSaveTime = Date.now();
                        }
                    }, SAVE_INTERVAL);

                    let streamDone = false;
                    let streamDoneTime = null; // Track when streamDone was set
                    let lastDataTime = Date.now();
                    const MAX_IDLE_TIME = 300000; // Stop if no data for 5 minutes (much longer)
                    const STREAM_DONE_TIMEOUT = 2000; // Break 2 seconds after receiving done flag
                    let isImageGeneration = false;
                    let imageProgress = 0;
                    
                    try {
                        while (true) {
                            const { done, value } = await reader.read();

                            if (done) {
                                console.log('Stream reader returned done=true - stream completed');
                                break;
                            }

                            // Update last data time
                            lastDataTime = Date.now();

                            // Decode the chunk
                            const decodedChunk = decoder.decode(value, { stream: true });
                            buffer += decodedChunk;
                            
                            // Debug: log raw chunk data (first few chunks only)
                            if (!window._rawChunkCount) window._rawChunkCount = 0;
                            window._rawChunkCount++;
                            if (window._rawChunkCount <= 3) {
                                console.log(`Raw chunk #${window._rawChunkCount} (${decodedChunk.length} bytes):`, decodedChunk.substring(0, 200));
                            }

                            // Process complete lines
                            const lines = buffer.split('\n');
                            buffer = lines.pop() || ''; // Keep incomplete line in buffer
                            
                            if (lines.length > 0) {
                                console.log(`Processing ${lines.length} complete line(s) from buffer`);
                            }
                            
                            for (const line of lines) {
                                if (line.trim() === '') continue;

                                try {
                                    // Handle both Ollama and ComfyUI streaming formats
                                    let jsonData;
                                    if (line.startsWith('data: ')) {
                                        jsonData = JSON.parse(line.substring(6));
                                    } else {
                                        jsonData = JSON.parse(line);
                                    }
                                    
                                    // Debug: log all received data (but only first 5 chunks to avoid spam)
                                    if (!window._chunkCount) window._chunkCount = 0;
                                    window._chunkCount++;
                                    if (window._chunkCount <= 5 || jsonData.done) {
                                        console.log(`Received JSON chunk #${window._chunkCount}:`, JSON.stringify(jsonData));
                                    }

                                    // Handle ComfyUI image generation progress
                                    if (jsonData.type === 'progress' && jsonData.progress !== undefined) {
                                        isImageGeneration = true;
                                        imageProgress = jsonData.progress;
                                        const progressBar = document.getElementById('image-progress-bar');
                                        const progressText = document.getElementById('image-progress-text');
                                        if (progressBar) {
                                            progressBar.style.width = jsonData.progress + '%';
                                        }
                                        if (progressText) {
                                            progressText.textContent = `Generating... ${jsonData.progress}%`;
                                        }
                                        continue;
                                    }

                                    // Handle final image response from ComfyUI
                                    if (jsonData.image) {
                                        isImageGeneration = true;
                                        const imageSrc = jsonData.image;
                                        assistantMessage = `
                                            <div style="position: relative; display: inline-block; max-width: 100%;">
                                                <img src="${imageSrc}" alt="Generated image" style="max-width: 100%; border-radius: 8px; margin: 10px 0; display: block;">
                                                <button onclick="downloadImage('${imageSrc}', 'comfyui-image-${Date.now()}.png')" style="position: absolute; top: 15px; right: 15px; background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 5px; padding: 8px 12px; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 5px;">
                                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                                        <polyline points="7 10 12 15 17 10"></polyline>
                                                        <line x1="12" y1="15" x2="12" y2="3"></line>
                                                    </svg>
                                                    Download
                                                </button>
                                            </div>
                                        `;
                                        if (messageContent) {
                                            messageContent.innerHTML = assistantMessage;
                                        }
                                        streamDone = true;
                                        streamDoneTime = Date.now();
                                        console.log('[Image] Received image, displaying in conversation');
                                        if (jsonData.done) continue;
                                    }
                                    
                                    // Also check for image in response field
                                    if (jsonData.response && jsonData.response.startsWith('data:image/')) {
                                        isImageGeneration = true;
                                        const imageSrc = jsonData.response;
                                        assistantMessage = `
                                            <div style="position: relative; display: inline-block; max-width: 100%;">
                                                <img src="${imageSrc}" alt="Generated image" style="max-width: 100%; border-radius: 8px; margin: 10px 0; display: block;">
                                                <button onclick="downloadImage('${imageSrc}', 'comfyui-image-${Date.now()}.png')" style="position: absolute; top: 15px; right: 15px; background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 5px; padding: 8px 12px; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 5px;">
                                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                                        <polyline points="7 10 12 15 17 10"></polyline>
                                                        <line x1="12" y1="15" x2="12" y2="3"></line>
                                                    </svg>
                                                    Download
                                                </button>
                                            </div>
                                        `;
                                        if (messageContent) {
                                            messageContent.innerHTML = assistantMessage;
                                        }
                                        streamDone = true;
                                        streamDoneTime = Date.now();
                                        console.log('[Image] Received image in response field');
                                        if (jsonData.done) continue;
                                    }

                                    // Check if stream is done (Ollama sends done: true when complete)
                                    if (jsonData.done === true) {
                                        console.log('Ollama stream marked as done - processing final response');
                                        console.log('Done chunk full data:', JSON.stringify(jsonData, null, 2));
                                        streamDone = true;
                                        streamDoneTime = Date.now(); // Record when done flag was received
                                        
                                        // For image generation, check if we already have the image
                                        if (isImageGeneration && jsonData.image) {
                                            const imageSrc = jsonData.image;
                                            assistantMessage = `
                                                <div style="position: relative; display: inline-block; max-width: 100%;">
                                                    <img src="${imageSrc}" alt="Generated image" style="max-width: 100%; border-radius: 8px; margin: 10px 0; display: block;">
                                                    <button onclick="downloadImage('${imageSrc}', 'comfyui-image-${Date.now()}.png')" style="position: absolute; top: 15px; right: 15px; background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 5px; padding: 8px 12px; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 5px;">
                                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                                            <polyline points="7 10 12 15 17 10"></polyline>
                                                            <line x1="12" y1="15" x2="12" y2="3"></line>
                                                        </svg>
                                                        Download
                                                    </button>
                                                </div>
                                            `;
                                            if (messageContent) {
                                                messageContent.innerHTML = assistantMessage;
                                            }
                                            console.log('[Image] Final image received in done chunk');
                                        } else if (isImageGeneration && jsonData.response && jsonData.response.startsWith('data:image/')) {
                                            const imageSrc = jsonData.response;
                                            assistantMessage = `
                                                <div style="position: relative; display: inline-block; max-width: 100%;">
                                                    <img src="${imageSrc}" alt="Generated image" style="max-width: 100%; border-radius: 8px; margin: 10px 0; display: block;">
                                                    <button onclick="downloadImage('${imageSrc}', 'comfyui-image-${Date.now()}.png')" style="position: absolute; top: 15px; right: 15px; background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 5px; padding: 8px 12px; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 5px;">
                                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                                            <polyline points="7 10 12 15 17 10"></polyline>
                                                            <line x1="12" y1="15" x2="12" y2="3"></line>
                                                        </svg>
                                                        Download
                                                    </button>
                                                </div>
                                            `;
                                            if (messageContent) {
                                                messageContent.innerHTML = assistantMessage;
                                            }
                                            console.log('[Image] Final image received in response field of done chunk');
                                        } else {
                                            // Check ALL possible response fields and accumulate them (for text responses)
                                            let hasContent = false;
                                            if (jsonData.response && !jsonData.response.startsWith('data:image/')) {
                                                assistantMessage += jsonData.response;
                                                console.log('Added response from done chunk:', jsonData.response.substring(0, 50));
                                                hasContent = true;
                                            }
                                            if (jsonData.text) {
                                                assistantMessage += jsonData.text;
                                                console.log('Added text from done chunk:', jsonData.text.substring(0, 50));
                                                hasContent = true;
                                            }
                                            if (jsonData.message) {
                                                assistantMessage += jsonData.message;
                                                console.log('Added message from done chunk:', jsonData.message.substring(0, 50));
                                                hasContent = true;
                                            }
                                            if (jsonData.content) {
                                                assistantMessage += jsonData.content;
                                                console.log('Added content from done chunk:', jsonData.content.substring(0, 50));
                                                hasContent = true;
                                            }
                                            
                                            // Only call updateUI() once after processing all fields
                                            if (hasContent) {
                                                updateUI();
                                            }
                                        }
                                        
                                        console.log('Total message length after done chunk:', assistantMessage.length);
                                        // Don't break here - continue reading to get any trailing data, but stop processing response content
                                    }

                                    // Extract the response text (ONLY if NOT done AND streamDone is false)
                                    // Once streamDone is true, ignore any response content from subsequent chunks
                                    if (!streamDone && !jsonData.done && jsonData.response) {
                                        // If we're showing image loader but getting text response, switch to normal loader
                                        if (!isImageGeneration && jsonData.response && !jsonData.response.startsWith('data:image/')) {
                                            const imageLoader = document.getElementById('image-progress-bar')?.parentElement?.parentElement;
                                            if (imageLoader) {
                                                const messageContent = imageLoader.closest('.message-content');
                                                if (messageContent) {
                                                    const loadingText = (currentModel === 'model2') ? 'Thinking...' : 'Analyzing...';
                                                    messageContent.innerHTML = `<span class="loading"></span> ${loadingText}`;
                                                }
                                            }
                                        }
                                        assistantMessage += jsonData.response;
                                        console.log(`Added response chunk (${jsonData.response.length} chars):`, jsonData.response.substring(0, 50));
                                        updateUI();
                                    }
                                    // Also check for 'text' field (some models use this instead of 'response')
                                    else if (!streamDone && !jsonData.done && jsonData.text) {
                                        // If we're showing image loader but getting text response, switch to normal loader
                                        if (!isImageGeneration) {
                                            const imageLoader = document.getElementById('image-progress-bar')?.parentElement?.parentElement;
                                            if (imageLoader) {
                                                const messageContent = imageLoader.closest('.message-content');
                                                if (messageContent) {
                                                    const loadingText = (currentModel === 'model2') ? 'Thinking...' : 'Analyzing...';
                                                    messageContent.innerHTML = `<span class="loading"></span> ${loadingText}`;
                                                }
                                            }
                                        }
                                        assistantMessage += jsonData.text;
                                        console.log(`Added text chunk (${jsonData.text.length} chars):`, jsonData.text.substring(0, 50));
                                        updateUI();
                                    }
                                    // Check for other possible fields
                                    else if (!streamDone && !jsonData.done && jsonData.message) {
                                        // If we're showing image loader but getting text response, switch to normal loader
                                        if (!isImageGeneration) {
                                            const imageLoader = document.getElementById('image-progress-bar')?.parentElement?.parentElement;
                                            if (imageLoader) {
                                                const messageContent = imageLoader.closest('.message-content');
                                                if (messageContent) {
                                                    const loadingText = (currentModel === 'model2') ? 'Thinking...' : 'Analyzing...';
                                                    messageContent.innerHTML = `<span class="loading"></span> ${loadingText}`;
                                                }
                                            }
                                        }
                                        assistantMessage += jsonData.message;
                                        console.log(`Added message chunk (${jsonData.message.length} chars):`, jsonData.message.substring(0, 50));
                                        updateUI();
                                    }
                                    else if (!streamDone && !jsonData.done && jsonData.content) {
                                        // If we're showing image loader but getting text response, switch to normal loader
                                        if (!isImageGeneration) {
                                            const imageLoader = document.getElementById('image-progress-bar')?.parentElement?.parentElement;
                                            if (imageLoader) {
                                                const messageContent = imageLoader.closest('.message-content');
                                                if (messageContent) {
                                                    const loadingText = (currentModel === 'model2') ? 'Thinking...' : 'Analyzing...';
                                                    messageContent.innerHTML = `<span class="loading"></span> ${loadingText}`;
                                                }
                                            }
                                        }
                                        assistantMessage += jsonData.content;
                                        console.log(`Added content chunk (${jsonData.content.length} chars):`, jsonData.content.substring(0, 50));
                                        updateUI();
                                    }
                                    
                                    // Debug: log if we see a chunk with done=false but no response
                                    if (!jsonData.done && !jsonData.response && !jsonData.text && !jsonData.message && !jsonData.content) {
                                        console.warn('Received chunk with done=false but no response fields:', Object.keys(jsonData));
                                    }
                                    
                                    // If streamDone is true and we receive a chunk, log it but don't process response content
                                    if (streamDone && !jsonData.done) {
                                        console.log('Received chunk after done flag - ignoring response content to prevent infinite typing');
                                    }
                                } catch (e) {
                                    // If it's not JSON, might be plain text, but only append if streamDone is false
                                    if (!streamDone) {
                                        console.log('Non-JSON line received:', line.substring(0, 100));
                                        if (line.trim()) {
                                            assistantMessage += line + '\n';
                                            updateUI();
                                        }
                                    } else {
                                        console.log('Non-JSON line received after done flag - ignoring to prevent infinite typing');
                                    }
                                }
                            }
                            
                            // Break if streamDone is true and enough time has passed (timeout mechanism)
                            if (streamDone && streamDoneTime) {
                                const timeSinceDone = Date.now() - streamDoneTime;
                                if (timeSinceDone >= STREAM_DONE_TIMEOUT) {
                                    console.log(`Stream done flag received ${timeSinceDone}ms ago, breaking loop to prevent infinite typing`);
                                    break;
                                } else {
                                    console.log(`Stream marked as done, waiting for reader to finish (${timeSinceDone}ms since done flag)`);
                                }
                            }
                            
                            // Safety check: if no data received for too long, assume stream is stuck
                            if (Date.now() - lastDataTime > MAX_IDLE_TIME) {
                                console.warn('Stream idle for too long, assuming completion');
                                break;
                            }
                        }
                    } catch (streamError) {
                        // Clear the periodic save interval
                        clearInterval(partialSaveInterval);
                        
                        console.error('Stream error caught:', streamError);
                        console.error('Error name:', streamError.name);
                        console.error('Error message:', streamError.message);
                        console.error('Partial message length:', assistantMessage.length);
                        
                        // Check if error is due to page visibility (browser cancelling the stream)
                        const isVisibilityError = streamError.name === 'AbortError' || 
                                                  streamError.message?.includes('Load failed') ||
                                                  streamError.message?.includes('network') ||
                                                  streamError.message?.includes('fetch') ||
                                                  streamError.message?.includes('timeout');
                        
                        // For ANY error (including timeouts), save partial content
                        streamInterrupted = true;
                        
                        if (isVisibilityError && document.hidden) {
                            // Page is hidden - this is expected, don't show error
                            console.log('Stream interrupted due to page visibility - will resume when visible');
                        } else {
                            // Unexpected error (timeout, network, etc.) - log but don't show error if we have content
                            console.log('Stream interrupted unexpectedly:', streamError.message);
                        }
                        
                        // Always save partial message on any interruption
                        if (window._currentStreamingState) {
                            window._currentStreamingState.interrupted = true;
                            window._currentStreamingState.partialMessage = assistantMessage;
                            window._currentStreamingState.error = streamError.message;
                        }
                        
                        // If we have substantial content, don't throw - save what we have
                        if (assistantMessage.trim().length > 10) {
                            console.log('Saving partial message due to stream interruption');
                            // Don't throw - continue to final update with what we have
                        } else {
                            // No content - rethrow to be caught by outer catch
                            throw streamError;
                        }
                    } finally {
                        // Clear the periodic save interval
                        clearInterval(partialSaveInterval);
                        
                        // Clear streaming state when done (successfully or interrupted)
                        if (!streamInterrupted) {
                            window._currentStreamingState = null;
                        }
                    }
                    
                    // Final update after streaming completes (or was interrupted)
                    if (!streamInterrupted) {
                        // Process any remaining buffer FIRST before final update
                        let bufferProcessed = false;
                        if (buffer.trim()) {
                            console.log('Processing remaining buffer:', buffer.substring(0, 200));
                            try {
                                const jsonData = JSON.parse(buffer);
                                console.log('Buffer JSON data:', JSON.stringify(jsonData, null, 2));
                                
                                // Check ALL possible response fields
                                if (jsonData.response) {
                                    assistantMessage += jsonData.response;
                                    console.log('Added response from buffer');
                                    bufferProcessed = true;
                                }
                                if (jsonData.text) {
                                    assistantMessage += jsonData.text;
                                    console.log('Added text from buffer');
                                    bufferProcessed = true;
                                }
                                if (jsonData.message) {
                                    assistantMessage += jsonData.message;
                                    console.log('Added message from buffer');
                                    bufferProcessed = true;
                                }
                                if (jsonData.content) {
                                    assistantMessage += jsonData.content;
                                    console.log('Added content from buffer');
                                    bufferProcessed = true;
                                }
                                
                                // Also check if done flag is in buffer
                                if (jsonData.done === true) {
                                    console.log('Done flag found in buffer');
                                }
                            } catch (e) {
                                console.log('Buffer is not JSON, treating as plain text');
                                // If not JSON, might be plain text
                                if (buffer.trim() && !buffer.trim().startsWith('{')) {
                                    assistantMessage += buffer;
                                    console.log('Added plain text from buffer');
                                    bufferProcessed = true;
                                }
                            }
                            
                            // If buffer had content, update UI using the update mechanism
                            if (bufferProcessed) {
                                updateUI();
                                // Wait a bit for the update to complete
                                setTimeout(() => {
                                    // Final update using forceUpdateUI to ensure it's the last one
                                    forceUpdateUI();
                                }, 150);
                            } else {
                                // No buffer content, just do final update
                                forceUpdateUI();
                            }
                        } else {
                            // No buffer, just do final update
                            forceUpdateUI();
                        }
                        
                        // Force final update - ensure message is displayed even if empty (for debugging)
                        console.log('Final assistant message length:', assistantMessage.length);
                        console.log('Final assistant message preview:', assistantMessage.substring(0, 100));
                        
                            // #region agent log
                        fetch('http://127.0.0.1:7242/ingest/3ed930ca-2135-4e7e-8d90-8b30632dad4b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:4448',message:'Final innerHTML update after streaming',data:{messageLength:assistantMessage.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
                            // #endregion
                        
                        // Clear streaming state on successful completion
                        window._currentStreamingState = null;
                    } else {
                        // Stream was interrupted - update with partial content and mark for resume
                        if (assistantMessage.trim()) {
                            // Save the partial message immediately
                            currentConversation.messages.push({ role: 'assistant', content: assistantMessage });
                            
                            // Update UI with formatted partial content
                            // If it's an image generation or already contains HTML, set directly without formatting
                            if (isImageGeneration && assistantMessage.includes('<img') && assistantMessage.includes('<div')) {
                                messageContent.innerHTML = assistantMessage;
                            } else {
                                messageContent.innerHTML = formatMessage(assistantMessage);
                            }
                            
                            // Add a visual indicator that message was interrupted
                            const interruptedIndicator = document.createElement('div');
                            interruptedIndicator.style.cssText = 'margin-top: 0.5rem; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px; font-size: 0.85rem; color: var(--text-secondary); border: 1px solid var(--border);';
                            interruptedIndicator.innerHTML = '<strong> Stream interrupted</strong><br>Partial content saved. You can continue the conversation.';
                            
                            messageContent.appendChild(interruptedIndicator);
                            
                            // Save to localStorage if guest mode
                            if (!currentUser) {
                                localStorage.setItem('conversations', JSON.stringify(conversations));
                            }
                            updateConversationsList();
                            
                            const container = document.getElementById('chat-messages');
                            if (container) {
                                container.scrollTop = container.scrollHeight;
                                checkScrollPosition();
                            }
                            
                            console.log('Partial message saved:', assistantMessage.length, 'characters');
                        } else {
                            // No content received - remove loading message
                            if (loadingMsg) {
                                loadingMsg.remove();
                            }
                        }
                    }

                    console.log('Final assistant message:', assistantMessage);

                    // For images, make sure we save the full HTML with download button
                    let messageToSave = assistantMessage;
                    // If it's an image but doesn't have download button, add it
                    if (isImageGeneration && assistantMessage.includes('<img') && !assistantMessage.includes('downloadImage')) {
                        const imgMatch = assistantMessage.match(/<img[^>]+src="([^"]+)"/);
                        if (imgMatch) {
                            const imageSrc = imgMatch[1];
                            messageToSave = `
                                <div style="position: relative; display: inline-block; max-width: 100%;">
                                    <img src="${imageSrc}" alt="Generated image" style="max-width: 100%; border-radius: 8px; margin: 10px 0; display: block;">
                                    <button onclick="downloadImage('${imageSrc}', 'comfyui-image-${Date.now()}.png')" style="position: absolute; top: 15px; right: 15px; background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 5px; padding: 8px 12px; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 5px;">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                            <polyline points="7 10 12 15 17 10"></polyline>
                                            <line x1="12" y1="15" x2="12" y2="3"></line>
                                        </svg>
                                        Download
                                    </button>
                                </div>
                            `;
                        }
                    }

                    // Save the complete message
                    currentConversation.messages.push({ role: 'assistant', content: messageToSave });

                    // Save assistant message to API if authenticated
                    if (currentUser && typeof currentConversation.id === 'number') {
                        await addMessageToConversationAPI(currentConversation.id, 'assistant', messageToSave);
                    }

                    // Update the existing conversation in the array (don't add it again)
                    const convIndex = conversations.findIndex(c => c.id === currentConversation.id);
                    if (convIndex !== -1) {
                        // Update existing conversation
                        conversations[convIndex] = {
                            ...conversations[convIndex],
                            ...currentConversation,
                            messages: currentConversation.messages
                        };
                    } else {
                        // Only add if it's truly not in the list (shouldn't happen after first message)
                        console.warn('Conversation not found in list after assistant message, this should not happen');
                        // Don't add it - it should already be in the list from the user message
                    }

                    // Save to localStorage as backup (for guest mode or offline)
                    if (!currentUser) {
                        localStorage.setItem('conversations', JSON.stringify(conversations));
                    }
                    updateConversationsList();
                    
                    // Update tokens badge after message
                    await updateTokensBadge();
                } else {
                    // No API key - show error
                    throw new Error(' Looks like the AI needs its access key! Please refresh the page or contact support.');
                }

            } catch (error) {
                console.error('Error in sendMessage:', error);
                const errorMessage = error.message || ' Something unexpected happened! Please try again or refresh the page.';
                console.error('Error details:', errorMessage);
                console.error('Error stack:', error.stack);

                // Check if error is due to page visibility (browser cancelling the request)
                // Check both current state and if page was likely hidden when error occurred
                const isVisibilityError = error.name === 'AbortError' || 
                                         errorMessage.includes('Load failed') ||
                                         errorMessage.includes('Failed to fetch') ||
                                         errorMessage.includes('network') ||
                                         errorMessage.includes('fetch') ||
                                         errorMessage.includes('aborted') ||
                                         (document.hidden && (errorMessage.includes('fetch') || errorMessage.includes('Load')));

                // Handle visibility errors - don't show error if page is hidden or was hidden
                if (isVisibilityError && (document.hidden || errorMessage.includes('Load failed'))) {
                    // Page was hidden - don't show error, just update with what we have
                    console.log('Error due to page visibility - silently handling:', errorMessage);
                    if (loadingMsg && loadingMsg.querySelector('.message-content') && assistantMessage && assistantMessage.trim()) {
                        // Update with partial message if we have any
                        loadingMsg.querySelector('.message-content').innerHTML = formatMessage(assistantMessage);
                        const loadingIndicator = loadingMsg.querySelector('.loading');
                        if (loadingIndicator) loadingIndicator.remove();
                        // Save partial message
                        currentConversation.messages.push({ role: 'assistant', content: assistantMessage });
                        // Save to localStorage if guest mode
                        if (!currentUser) {
                            localStorage.setItem('conversations', JSON.stringify(conversations));
                        }
                        updateConversationsList();
                    } else if (loadingMsg) {
                        // No message content yet - just remove loading indicator
                        loadingMsg.remove();
                    }
                    // Don't show error to user - it's expected when page is hidden
                    // Re-enable input is already in finally block
                    return;
                }

                // Check if it's an insufficient tokens error
                if (errorMessage.toLowerCase().includes('insufficient tokens') || 
                    errorMessage.toLowerCase().includes('token limit') ||
                    errorMessage.toLowerCase().includes('not enough tokens')) {
                    // Show token limit modal
                    showTokenLimitModal();
                    // Remove loading message
                    if (loadingMsg) {
                        loadingMsg.remove();
                    }
                } else {
                    // Show regular error in UI
                    // Check if it's a friendly message - don't add "Error:" prefix
                    const isNapMessage = errorMessage.includes('out for a nap');
                    const isAuthMessage = errorMessage.includes('Please sign in') || errorMessage.includes('Hey there');
                    const displayMessage = (isNapMessage || isAuthMessage) ? errorMessage : 'Error: ' + errorMessage;
                    
                    if (loadingMsg && loadingMsg.querySelector('.message-content')) {
                        loadingMsg.querySelector('.message-content').innerHTML = `<p style="color: var(--accent);">${escapeHtml(displayMessage)}</p>`;
                        // Remove loading indicator if present
                        const loadingIndicator = loadingMsg.querySelector('.loading');
                        if (loadingIndicator) loadingIndicator.remove();
                    } else {
                        // If loadingMsg doesn't exist, create an error message
                        try {
                            const errorMsg = await addMessageToUI('assistant', escapeHtml(displayMessage), false);
                            if (errorMsg && errorMsg.querySelector('.message-content')) {
                                errorMsg.querySelector('.message-content').style.color = 'var(--accent)';
                            }
                        } catch (uiError) {
                            console.error('Error displaying error message:', uiError);
                            const isAuthMessage = errorMessage.includes('Please sign in') || errorMessage.includes('Hey there');
                            alert((isNapMessage || isAuthMessage) ? errorMessage : 'Error: ' + errorMessage);
                        }
                    }
                }
            } finally {
                // Re-enable input
                input.disabled = false;
                if (sendBtn) sendBtn.disabled = false;
                updateSendButton(); // Ensure button returns to voice mode after sending
                input.focus();
            }
        }

        // Download image function
        function downloadImage(imageSrc, filename) {
            try {
                const link = document.createElement('a');
                link.href = imageSrc;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (error) {
                console.error('Error downloading image:', error);
                // Fallback: open in new tab
                window.open(imageSrc, '_blank');
            }
        }

        // #region agent log
        let formatMessageCallCount = 0;
        // #endregion
        function formatMessage(text) {
            // #region agent log
            formatMessageCallCount++;
            const startTime = performance.now();
            if (formatMessageCallCount % 50 === 0) {
                fetch('http://127.0.0.1:7242/ingest/3ed930ca-2135-4e7e-8d90-8b30632dad4b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:4533',message:'formatMessage called',data:{callCount:formatMessageCallCount,textLength:text?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
            }
            // #endregion
            if (!text) return '';

            // Check if markdown-it is available
            if (typeof markdownit === 'undefined') {
                console.warn('markdown-it not loaded, falling back to basic formatting');
                return escapeHtml(text).replace(/\n/g, '<br>');
            }

            // Initialize markdown-it with Open WebUI-style configuration
            const md = markdownit({
                html: true,
                linkify: true,
                typographer: true,
                breaks: true,
                highlight: function (str, lang) {
                    // Use highlight.js for syntax highlighting (like Open WebUI)
                    if (lang && typeof hljs !== 'undefined' && hljs.getLanguage(lang)) {
                        try {
                            const highlighted = hljs.highlight(str, { language: lang }).value;
                            return `<pre class="hljs"><code class="language-${lang}">${highlighted}</code></pre>`;
                        } catch (err) {
                            console.error('Highlight.js error:', err);
                        }
                    }
                    // Fallback for unknown languages
                    return `<pre class="hljs"><code>${escapeHtml(str)}</code></pre>`;
                }
            });


            // Custom code block renderer (Open WebUI style with copy button)
            md.renderer.rules.fence = function (tokens, idx, options) {
                const token = tokens[idx];
                const info = token.info ? token.info.trim() : '';
                const langName = info ? info.split(/\s+/g)[0] : '';
                const code = token.content;
                const codeBlockId = `code-block-${Date.now()}-${idx}`;
                
                // Use highlight.js for syntax highlighting
                let highlightedCode = '';
                if (langName && typeof hljs !== 'undefined' && hljs.getLanguage(langName)) {
                    try {
                        highlightedCode = hljs.highlight(code, { language: langName }).value;
                    } catch (err) {
                        highlightedCode = escapeHtml(code);
                    }
                } else {
                    highlightedCode = escapeHtml(code);
                }
                
                return `
                            <div class="code-block-container">
                                <div class="code-block-header">
                            <span class="code-block-language">${escapeHtml(langName || 'text')}</span>
                                    <button class="code-block-copy-btn" onclick="copyCodeBlock('${codeBlockId}')" title="Copy code">
                                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                            <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" fill="currentColor"/>
                                        </svg>
                                        Copy
                                    </button>
                                </div>
                                <div class="code-block-content">
                            <pre class="hljs"><code id="${codeBlockId}" class="language-${escapeHtml(langName || 'text')}">${highlightedCode}</code></pre>
                                </div>
                            </div>
                `;
            };

            // Render markdown
            let html = md.render(text);

            // #region agent log
            const endTime = performance.now();
            const executionTime = endTime - startTime;
            if (executionTime > 10 || formatMessageCallCount % 50 === 0) {
                fetch('http://127.0.0.1:7242/ingest/3ed930ca-2135-4e7e-8d90-8b30632dad4b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:4701',message:'formatMessage completed',data:{callCount:formatMessageCallCount,executionTime:executionTime.toFixed(2),outputLength:html.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
            }
            // #endregion

            return html;
        }
        
        // Copy code block function
        async function copyCodeBlock(codeBlockId) {
            const codeElement = document.getElementById(codeBlockId);
            if (!codeElement) return;
            
            const code = codeElement.textContent || codeElement.innerText;
            try {
                await navigator.clipboard.writeText(code);
                
                // Visual feedback
                const btn = event.target.closest('.code-block-copy-btn');
                if (btn) {
                    const originalHTML = btn.innerHTML;
                    btn.innerHTML = `
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" fill="currentColor"/>
                        </svg>
                        Copied!
                    `;
                    btn.style.color = 'var(--accent)';
                    
                    setTimeout(() => {
                        btn.innerHTML = originalHTML;
                        btn.style.color = '';
                    }, 2000);
                }
            } catch (err) {
                console.error('Failed to copy:', err);
            }
        }

        function handleKeyDown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        // Voice recording state
        let isRecording = false;
        let mediaRecorder = null;
        let audioChunks = [];
        let audioStream = null;
        let speechRecognition = null;
        let transcribedText = '';

        // Update send button based on input state
        function updateSendButton() {
            const input = document.getElementById('message-input');
            const sendBtn = document.getElementById('send-btn');
            const sendIcon = document.getElementById('send-icon');
            const voiceIcon = document.getElementById('voice-icon');
            const cancelBtn = document.getElementById('cancel-recording-btn');
            
            if (!input || !sendBtn) return;
            
            const hasText = input.value.trim().length > 0;
            
            if (isRecording) {
                // Recording state - show voice icon with recording animation
                sendIcon.style.display = 'none';
                voiceIcon.style.display = 'block';
                sendBtn.classList.add('recording');
                sendBtn.title = 'Click to send voice';
                if (cancelBtn) {
                    cancelBtn.classList.add('visible');
                }
            } else if (hasText) {
                // Has text - show send arrow
                sendIcon.style.display = 'block';
                voiceIcon.style.display = 'none';
                sendBtn.classList.remove('recording');
                sendBtn.title = 'Send';
                if (cancelBtn) {
                    cancelBtn.classList.remove('visible');
                }
            } else {
                // Empty - show voice icon
                sendIcon.style.display = 'none';
                voiceIcon.style.display = 'block';
                sendBtn.classList.remove('recording');
                sendBtn.title = 'Click to start voice recording';
                if (cancelBtn) {
                    cancelBtn.classList.remove('visible');
                }
            }
        }

        // Start voice recording
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioStream = stream;
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                transcribedText = '';
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    // Clean up stream
                    if (audioStream) {
                        audioStream.getTracks().forEach(track => track.stop());
                        audioStream = null;
                    }
                };
                
                // Start speech recognition if available
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    speechRecognition = new SpeechRecognition();
                    speechRecognition.continuous = true;
                    speechRecognition.interimResults = false;
                    speechRecognition.lang = 'en-US';
                    
                    speechRecognition.onresult = (event) => {
                        for (let i = event.resultIndex; i < event.results.length; i++) {
                            if (event.results[i].isFinal) {
                                transcribedText += event.results[i][0].transcript + ' ';
                            }
                        }
                    };
                    
                    speechRecognition.onerror = (event) => {
                        console.error('Speech recognition error:', event.error);
                    };
                    
                    speechRecognition.start();
                }
                
                mediaRecorder.start();
                isRecording = true;
                updateSendButton();
            } catch (error) {
                console.error('Error starting recording:', error);
                alert('Could not access microphone. Please check permissions.');
            }
        }

        // Stop recording and send voice
        async function stopRecordingAndSend() {
            if (!isRecording || !mediaRecorder) return;
            
            // Stop speech recognition first
            if (speechRecognition) {
                speechRecognition.stop();
            }
            
            return new Promise((resolve) => {
                // Set up onstop handler before stopping
                const originalOnStop = mediaRecorder.onstop;
                mediaRecorder.onstop = async () => {
                    isRecording = false;
                    
                    // Create audio blob
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    audioChunks = [];
                    
                    // Clean up stream
                    if (audioStream) {
                        audioStream.getTracks().forEach(track => track.stop());
                        audioStream = null;
                    }
                    
                    // Call original onstop if it exists
                    if (originalOnStop) {
                        originalOnStop();
                    }
                    
                    // Update button state
                    updateSendButton();
                    
                    // Transcribe and send voice
                    try {
                        await transcribeAndSendVoice(audioBlob);
                    } catch (error) {
                        console.error('Error in transcribeAndSendVoice:', error);
                    }
                    resolve();
                };
                
                // Stop the recorder
                if (mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                    console.log('MediaRecorder.stop() called');
                } else {
                    console.log('MediaRecorder state:', mediaRecorder.state);
                    // If already stopped, trigger the handler manually
                    setTimeout(() => {
                        if (mediaRecorder.onstop) {
                            mediaRecorder.onstop();
                        }
                    }, 100);
                }
            });
        }

        // Cancel recording
        function cancelRecording() {
            if (!isRecording) return;
            
            if (speechRecognition) {
                speechRecognition.stop();
                speechRecognition = null;
            }
            
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
            }
            
            isRecording = false;
            audioChunks = [];
            transcribedText = '';
            updateSendButton();
        }

        // Transcribe voice and send as text message
        async function transcribeAndSendVoice(audioBlob) {
            const input = document.getElementById('message-input');
            const sendBtn = document.getElementById('send-btn');
            
            console.log('transcribeAndSendVoice called, audioBlob size:', audioBlob.size);
            
            try {
                // Stop speech recognition if still running
                if (speechRecognition) {
                    speechRecognition.stop();
                    speechRecognition = null;
                }
                
                // Wait a bit for final transcription
                await new Promise(resolve => setTimeout(resolve, 800));
                
                // Get transcribed text (from speech recognition)
                let finalText = transcribedText.trim();
                console.log('Transcribed text from speech recognition:', finalText);
                
                if (!finalText) {
                    console.log('No transcription from speech recognition, trying server fallback...');
                    // Fallback: Try to send audio to server for transcription
                    try {
                        const formData = new FormData();
                        formData.append('audio', audioBlob, 'voice.webm');
                        
                        const response = await fetch('/api/transcribe', {
                            method: 'POST',
                            body: formData,
                            credentials: 'include'
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            finalText = data.text || '';
                            console.log('Transcribed text from server:', finalText);
                        } else {
                            console.log('Server transcription failed with status:', response.status);
                        }
                    } catch (error) {
                        console.error('Server transcription error:', error);
                    }
                }
                
                if (!finalText) {
                    alert(' No speech detected. Please try again or type your message.');
                    return;
                }
                
                // Disable input and button before sending
                if (input) input.disabled = true;
                if (sendBtn) sendBtn.disabled = true;
                
                // Set transcribed text in input and send
                if (input) {
                    input.value = finalText;
                    updateSendButton();
                }
                
                // Send the transcribed message
                await sendMessage();
                
            } catch (error) {
                console.error('Error transcribing voice:', error);
                alert('Failed to process voice message: ' + error.message);
            } finally {
                // Clean up
                speechRecognition = null;
                transcribedText = '';
                
                // Re-enable input and button (sendMessage will handle clearing input and updating button)
                if (input) input.disabled = false;
                if (sendBtn) sendBtn.disabled = false;
                // Note: updateSendButton will be called by sendMessage after clearing input
            }
        }

        // Handle send button click
        function handleSendButtonClick() {
            const input = document.getElementById('message-input');
            
            if (isRecording) {
                // Stop recording and send
                stopRecordingAndSend();
            } else if (input && input.value.trim().length > 0) {
                // Has text - send message
                sendMessage();
            } else {
                // Empty - start recording
                startRecording();
            }
        }

        function autoResize(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 200) + 'px';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showPricing() {
            window.location.href = '/pricing';
        }

        // Authentication State (using the global currentUser from above)
        let isAuthenticated = localStorage.getItem('isAuthenticated') === 'true';
        // Restore saved user from localStorage if available
        const savedUser = JSON.parse(localStorage.getItem('currentUser') || 'null');
        if (savedUser) {
            currentUser = savedUser;
            console.log('Restored user from localStorage:', {
                profile_picture: currentUser.profile_picture,
                avatar: currentUser.avatar
            });
        }
        // Note: currentUser is already declared globally above

        function showRegister() {
            document.getElementById('auth-modal').style.display = 'flex';
        }

        // Show verification code error alert
        function showVerificationCodeAlert(message) {
            const alert = document.getElementById('verification-code-alert');
            const alertMessage = document.getElementById('verification-code-alert-message');
            
            if (alert && alertMessage) {
                alertMessage.textContent = message;
                alert.classList.add('show');
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    hideVerificationCodeAlert();
                }, 5000);
            }
        }

        // Hide verification code error alert
        function hideVerificationCodeAlert() {
            const alert = document.getElementById('verification-code-alert');
            if (alert) {
                alert.classList.remove('show');
            }
        }

        // Show password mismatch error alert
        function showPasswordMismatchAlert(message) {
            const alert = document.getElementById('password-mismatch-alert');
            const alertMessage = document.getElementById('password-mismatch-alert-message');
            
            if (alert && alertMessage) {
                alertMessage.textContent = message;
                alert.classList.add('show');
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    hidePasswordMismatchAlert();
                }, 5000);
            }
        }

        // Hide password mismatch error alert
        function hidePasswordMismatchAlert() {
            const alert = document.getElementById('password-mismatch-alert');
            if (alert) {
                alert.classList.remove('show');
            }
        }

        // Make functions globally accessible
        window.showVerificationCodeAlert = showVerificationCodeAlert;
        window.hideVerificationCodeAlert = hideVerificationCodeAlert;
        window.showPasswordMismatchAlert = showPasswordMismatchAlert;
        window.hidePasswordMismatchAlert = hidePasswordMismatchAlert;

        function closeAuthModal() {
            document.getElementById('auth-modal').style.display = 'none';
            // Reset forms
            document.getElementById('login-form').reset();
            document.getElementById('register-form').reset();
            document.getElementById('auth-error').textContent = '';
            // Hide all alerts if visible
            hideVerificationCodeAlert();
            hidePasswordMismatchAlert();
        }

        function switchAuthTab(tab) {
            document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.auth-content').forEach(c => c.classList.remove('active'));

            document.getElementById(tab + '-tab').classList.add('active');
            document.getElementById(tab + '-content').classList.add('active');
            document.getElementById('auth-error').textContent = '';
        }

        // Token Limit Modal Functions
        // Show error notification popup
        function showErrorNotification(message) {
            // Remove any existing notification
            const existing = document.getElementById('error-notification');
            if (existing) {
                existing.remove();
            }

            // Create notification element
            const notification = document.createElement('div');
            notification.id = 'error-notification';
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--bg-secondary);
                border: 2px solid #ff4444;
                color: var(--text-primary);
                padding: 2rem 2.5rem;
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 68, 68, 0.1);
                z-index: 10000;
                font-weight: 400;
                font-size: 1rem;
                max-width: 500px;
                width: 90%;
                text-align: center;
                animation: slideIn 0.3s ease-out;
                line-height: 1.6;
            `;
            
            notification.innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; gap: 1rem;">
                    <div style="font-size: 2.5rem; color: #ff4444;"></div>
                    <div style="color: var(--text-primary); font-size: 1rem; line-height: 1.6;">
                        ${message}
                    </div>
                </div>
            `;
            
            document.body.appendChild(notification);

            // Auto-remove after 3 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease-in';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }
        
        // Show success notification popup
        function showSuccessNotification(message) {
            // Remove any existing notification
            const existing = document.getElementById('success-notification');
            if (existing) {
                existing.remove();
            }

            // Create notification element
            const notification = document.createElement('div');
            notification.id = 'success-notification';
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--bg-secondary);
                border: 2px solid var(--accent);
                color: var(--text-primary);
                padding: 2rem 2.5rem;
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(229, 255, 58, 0.1);
                z-index: 10000;
                font-weight: 400;
                font-size: 1rem;
                max-width: 500px;
                width: 90%;
                text-align: center;
                animation: slideIn 0.3s ease-out;
                line-height: 1.6;
            `;
            
            // Format message with better line breaks
            const formattedMessage = message.replace(/\n/g, '<br>');
            
            notification.innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; gap: 1rem;">
                    <div style="font-size: 2.5rem; color: var(--accent);"></div>
                    <div style="color: var(--text-primary); font-size: 1rem; line-height: 1.6;">
                        ${formattedMessage}
                    </div>
                </div>
            `;

            // Add animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideIn {
                    from {
                        opacity: 0;
                        transform: translate(-50%, -50%) scale(0.9);
                    }
                    to {
                        opacity: 1;
                        transform: translate(-50%, -50%) scale(1);
                    }
                }
                @keyframes slideOut {
                    from {
                        opacity: 1;
                        transform: translate(-50%, -50%) scale(1);
                    }
                    to {
                        opacity: 0;
                        transform: translate(-50%, -50%) scale(0.9);
                    }
                }
            `;
            if (!document.getElementById('notification-style')) {
                style.id = 'notification-style';
                document.head.appendChild(style);
            }

            // Create backdrop overlay
            const backdrop = document.createElement('div');
            backdrop.id = 'success-notification-backdrop';
            backdrop.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                z-index: 9999;
                animation: fadeIn 0.3s ease-out;
            `;
            
            const backdropStyle = document.createElement('style');
            backdropStyle.textContent = `
                @keyframes fadeIn {
                    from { opacity: 0; }
                    to { opacity: 1; }
                }
                @keyframes fadeOut {
                    from { opacity: 1; }
                    to { opacity: 0; }
                }
            `;
            if (!document.getElementById('backdrop-style')) {
                backdropStyle.id = 'backdrop-style';
                document.head.appendChild(backdropStyle);
            }

            document.body.appendChild(backdrop);
            document.body.appendChild(notification);

            // Close on backdrop click
            backdrop.addEventListener('click', () => {
                closeNotification();
            });

            // Auto-remove after 5 seconds
            setTimeout(() => {
                closeNotification();
            }, 5000);

            function closeNotification() {
                notification.style.animation = 'slideOut 0.3s ease-out';
                backdrop.style.animation = 'fadeOut 0.3s ease-out';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                    if (backdrop.parentNode) {
                        backdrop.remove();
                    }
                }, 300);
            }
        }

        function showTokenLimitModal() {
            const modal = document.getElementById('token-limit-modal');
            if (modal) {
                modal.classList.add('show');
            }
        }

        function closeTokenLimitModal() {
            const modal = document.getElementById('token-limit-modal');
            if (modal) {
                modal.classList.remove('show');
            }
        }

        // Close token limit modal when clicking outside
        document.addEventListener('DOMContentLoaded', function() {
            initScrollToBottom();
            const tokenLimitModal = document.getElementById('token-limit-modal');
            if (tokenLimitModal) {
                tokenLimitModal.addEventListener('click', function(event) {
                    if (event.target === tokenLimitModal) {
                        closeTokenLimitModal();
                    }
                });
            }
        });

        function validatePassword(password) {
            if (password.length < 8) {
                return 'Password must be at least 8 characters long';
            }
            const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(password);
            const hasUpperCase = /[A-Z]/.test(password);
            if (!hasSpecial && !hasUpperCase) {
                return 'Password must contain at least one special character or uppercase letter';
            }
            return '';
        }

        function checkPasswordRequirements(password) {
            const requirements = {
                length: password.length >= 8,
                uppercase: /[A-Z]/.test(password),
                special: /[!@#$%^&*(),.?":{}|<>]/.test(password)
            };
            return requirements;
        }

        function updatePasswordRequirements(password) {
            const reqDiv = document.getElementById('password-requirements');
            if (!reqDiv) return;

            if (!password || password.length === 0) {
                reqDiv.innerHTML = '';
                return;
            }

            const req = checkPasswordRequirements(password);
            let html = '<div style="display: flex; flex-direction: column; gap: 0.25rem;">';
            
            html += `<div style="color: ${req.length ? 'var(--accent)' : '#ff4444'};">
                ${req.length ? '' : ''} At least 8 characters
            </div>`;
            html += `<div style="color: ${req.uppercase ? 'var(--accent)' : '#ff4444'};">
                ${req.uppercase ? '' : ''} One uppercase letter
            </div>`;
            html += `<div style="color: ${req.special ? 'var(--accent)' : '#ff4444'};">
                ${req.special ? '' : ''} One special character
            </div>`;
            
            html += '</div>';
            reqDiv.innerHTML = html;
        }

        // Add event listener for password field
        document.addEventListener('DOMContentLoaded', function() {
            const passwordInput = document.getElementById('register-password');
            if (passwordInput) {
                passwordInput.addEventListener('input', function(e) {
                    updatePasswordRequirements(e.target.value);
                });
            }
        });

        // Handle forgot password
        async function handleForgotPassword(event) {
            event.preventDefault();
            
            const email = document.getElementById('login-email').value;
            const errorDiv = document.getElementById('auth-error');
            const forgotPasswordLink = document.getElementById('forgot-password-link');

            if (!email) {
                errorDiv.textContent = 'Please enter your email address first';
                errorDiv.style.display = 'block';
                return;
            }

            // Basic email validation
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                errorDiv.textContent = 'Please enter a valid email address';
                errorDiv.style.display = 'block';
                return;
            }

            // Disable link and show loading
            forgotPasswordLink.style.pointerEvents = 'none';
            forgotPasswordLink.style.opacity = '0.6';
            const originalText = forgotPasswordLink.textContent;
            forgotPasswordLink.textContent = 'Sending...';
            errorDiv.textContent = '';
            errorDiv.style.display = 'none';

            try {
                const response = await fetch(`${API_BASE}/api/forgot-password`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ email })
                });

                const data = await response.json();

                if (!response.ok) {
                    errorDiv.textContent = data.error || 'Failed to send password reset email';
                    errorDiv.style.display = 'block';
                    forgotPasswordLink.style.pointerEvents = 'auto';
                    forgotPasswordLink.style.opacity = '1';
                    forgotPasswordLink.textContent = originalText;
                    return;
                }

                // Success
                const destinationEmail = data.email || email;
                showSuccessNotification(`Password reset link has been sent to ${destinationEmail}. Please check your inbox (and spam folder).`);
                errorDiv.textContent = '';
                errorDiv.style.display = 'none';
                forgotPasswordLink.style.pointerEvents = 'auto';
                forgotPasswordLink.style.opacity = '1';
                forgotPasswordLink.textContent = originalText;

            } catch (error) {
                console.error('Error sending password reset request:', error);
                errorDiv.textContent = 'Network error. Please try again.';
                errorDiv.style.display = 'block';
                forgotPasswordLink.style.pointerEvents = 'auto';
                forgotPasswordLink.style.opacity = '1';
                forgotPasswordLink.textContent = originalText;
            }
        }

        async function handleLogin(event) {
            event.preventDefault();
            const email = document.getElementById('login-email').value;
            const password = document.getElementById('login-password').value;
            const errorDiv = document.getElementById('auth-error');

            if (!email || !password) {
                errorDiv.textContent = 'Please enter email and password';
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/api/login`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ email, password })
                });

                const data = await response.json();

                if (!response.ok) {
                    errorDiv.textContent = data.error || 'Login failed';
                    return;
                }

                // Success - prime currentUser from login response immediately
                if (data && data.user) {
                    currentUser = {
                        id: data.user.id,
                        email: data.user.email,
                        name: data.user.displayName || data.user.email.split('@')[0],
                        displayName: data.user.displayName || null,
                        avatar: data.user.profilePicture || null,
                        profile_picture: data.user.profilePicture || null,
                        plan: data.user.plan || 'free',
                        emailVerified: data.user.emailVerified || false,
                        googleId: data.user.googleId || null
                    };
                    isAuthenticated = true;
                    localStorage.setItem('currentUser', JSON.stringify(currentUser));
                    localStorage.setItem('isAuthenticated', 'true');
                    console.log('Login response user primed:', currentUser);
                    // #region agent log
                    fetch('http://127.0.0.1:7243/ingest/44364179-96d7-4a0f-ac4f-9f610636e213',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({sessionId:'debug-session',runId:'run1',hypothesisId:'H1',location:'index.html:handleLogin',message:'Manual login primed user',data:{hasProfile:!!(currentUser&&currentUser.profile_picture),profile_picture:currentUser&&currentUser.profile_picture,avatar:currentUser&&currentUser.avatar,profilePicture:data.user.profilePicture,isAuthenticated},timestamp:Date.now()})}).catch(()=>{});
                    // #endregion
                }

                // Reload full user data from /api/user/me to get all fields
                const authResult = await checkAuth();
                if (authResult) {
                    // checkAuth() already sets isAuthenticated and currentUser with full data
                    // Reload conversations from API
                    await loadConversationsFromAPI();
                    updateConversationsList();
                    
                    updateAuthUI();
                    updateSidebarProfileLink();
                    await updateTokensBadge(); // Update tokens badge after login
                    closeAuthModal();
                    
                    console.log('Login successful, user data loaded:', currentUser);
                } else {
                    errorDiv.textContent = 'Login successful but failed to load user data';
                }
            } catch (error) {
                console.error('Login error:', error);
                errorDiv.textContent = 'Network error. Please try again.';
            }
        }

        // Send verification code function
        async function sendVerificationCode() {
            console.log('sendVerificationCode function called'); // Debug log
            
            try {
                const emailInput = document.getElementById('register-email');
                const sendCodeBtn = document.getElementById('send-code-btn');
                const codeStatus = document.getElementById('code-status');
                const errorDiv = document.getElementById('auth-error');

                console.log('Elements check:', {
                    emailInput: !!emailInput,
                    sendCodeBtn: !!sendCodeBtn,
                    codeStatus: !!codeStatus,
                    errorDiv: !!errorDiv
                });

                // Check if elements exist
                if (!emailInput) {
                    console.error('Email input not found');
                    alert('Email input field not found. Please refresh the page.');
                    return;
                }
                if (!sendCodeBtn) {
                    console.error('Send code button not found');
                    alert('Send code button not found. Please refresh the page.');
                    return;
                }
                if (!codeStatus) {
                    console.error('Code status element not found');
                    // Continue anyway, this is not critical
                }
                if (!errorDiv) {
                    console.error('Error div not found');
                    // Continue anyway, we can show alerts
                }

                const email = emailInput.value.trim();
                console.log('Email value:', email);

                if (!email) {
                    const message = 'Please enter your email address first';
                    if (errorDiv) {
                        errorDiv.textContent = message;
                        errorDiv.style.display = 'block';
                    } else {
                        alert(message);
                    }
                    return;
                }

                // Basic email validation
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                if (!emailRegex.test(email)) {
                    const message = 'Please enter a valid email address';
                    if (errorDiv) {
                        errorDiv.textContent = message;
                        errorDiv.style.display = 'block';
                    } else {
                        alert(message);
                    }
                    return;
                }

                // Disable button and show loading
                sendCodeBtn.disabled = true;
                sendCodeBtn.textContent = 'Sending...';
                if (codeStatus) {
                    codeStatus.textContent = '';
                }
                if (errorDiv) {
                    errorDiv.textContent = '';
                    errorDiv.style.display = 'none';
                }

                console.log('Sending request to:', `${API_BASE}/api/send-verification-code`);
                console.log('API_BASE:', API_BASE);
                
                const response = await fetch(`${API_BASE}/api/send-verification-code`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ email })
                });

                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);

                if (!response.ok) {
                    let errorMessage = data.error || 'Failed to send verification code';
                    
                    // Show user-friendly message for SMTP configuration error
                    if (errorMessage.includes('not configured') || errorMessage.includes('SMTP')) {
                        errorMessage = ' Email service is currently being set up. Please contact support or try again later.';
                    }

                    // If email is already registered, show explicit alert
                    if (errorMessage.toLowerCase().includes('already registered')) {
                        alert('This email is already registered. Please sign in or use a different email.');
                    }
                    
                    if (errorDiv) {
                        errorDiv.textContent = errorMessage;
                        errorDiv.style.display = 'block';
                    } else {
                        alert(errorMessage);
                    }
                    sendCodeBtn.disabled = false;
                    sendCodeBtn.textContent = 'Send Code';
                    return;
                }

                // Success - Show popup notification with destination email from response
                const destinationEmail = data.email || email;
                if (typeof showSuccessNotification === 'function') {
                    showSuccessNotification(` Verification code has been sent to ${destinationEmail}. Please check your inbox (and spam folder).`);
                } else {
                    alert(` Verification code has been sent to ${destinationEmail}. Please check your inbox (and spam folder).`);
                }
                
                // Update status text
                if (codeStatus) {
                    codeStatus.textContent = ` Verification code sent to ${destinationEmail}! Check your inbox (and spam folder).`;
                    codeStatus.style.color = 'var(--accent)';
                }
                
                // Start countdown timer (60 seconds)
                let countdown = 60;
                const countdownInterval = setInterval(() => {
                    countdown--;
                    if (countdown > 0) {
                        sendCodeBtn.textContent = `Resend (${countdown}s)`;
                    } else {
                        clearInterval(countdownInterval);
                        sendCodeBtn.disabled = false;
                        sendCodeBtn.textContent = 'Resend Code';
                    }
                }, 1000);

            } catch (error) {
                console.error('Error sending verification code:', error);
                const errorMessage = 'Network error. Please try again.';
                if (errorDiv) {
                    errorDiv.textContent = errorMessage;
                    errorDiv.style.display = 'block';
                } else {
                    alert(errorMessage + '\n\nError: ' + error.message);
                }
                const sendCodeBtn = document.getElementById('send-code-btn');
                if (sendCodeBtn) {
                    sendCodeBtn.disabled = false;
                    sendCodeBtn.textContent = 'Send Code';
                }
            }
        }

        // Make function globally accessible
        window.sendVerificationCode = sendVerificationCode;

        // Attach send code handler once to avoid duplicate sends
        let sendCodeHandlerAttached = false;
        function attachSendCodeHandler() {
            if (sendCodeHandlerAttached) return;
            const sendCodeBtn = document.getElementById('send-code-btn');
            if (sendCodeBtn) {
                console.log('Send code button found, attaching single event listener');
                sendCodeBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (sendCodeBtn.disabled) {
                        console.warn('Send code click ignored because button is disabled');
                        return;
                    }
                    sendVerificationCode();
                });
                sendCodeHandlerAttached = true;
            } else {
                console.warn('Send code button not found when attempting to attach handler');
            }
        }

        document.addEventListener('DOMContentLoaded', attachSendCodeHandler);
        if (document.readyState !== 'loading') {
            attachSendCodeHandler();
        }

        async function handleRegister(event) {
            event.preventDefault();
            const email = document.getElementById('register-email').value;
            const password = document.getElementById('register-password').value;
            const confirmPassword = document.getElementById('register-confirm-password').value;
            const verificationCode = document.getElementById('register-verification-code').value;
            const errorDiv = document.getElementById('auth-error');

            const passwordError = validatePassword(password);
            if (passwordError) {
                errorDiv.textContent = passwordError;
                return;
            }

            if (password !== confirmPassword) {
                errorDiv.textContent = 'Passwords do not match';
                showPasswordMismatchAlert('Passwords do not match');
                return;
            }

            // Verify code is provided and is 6 digits
            if (!verificationCode || verificationCode.length !== 6 || !/^\d{6}$/.test(verificationCode)) {
                errorDiv.textContent = 'Please enter a valid 6-digit verification code';
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/api/register`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ 
                        email, 
                        password,
                        verificationCode,
                        displayName: email.split('@')[0]
                    })
                });

                const data = await response.json();

                if (!response.ok) {
                    const errorMessage = data.error || 'Registration failed';
                    errorDiv.textContent = errorMessage;
                    
                    // Show alert card if it's a verification code error
                    if (errorMessage.toLowerCase().includes('verification code') || 
                        errorMessage.toLowerCase().includes('invalid') || 
                        errorMessage.toLowerCase().includes('expired')) {
                        showVerificationCodeAlert(errorMessage);
                    }
                    return;
                }

                // Success - reload full user data from /api/user/me to get all fields
                const authResult = await checkAuth();
                if (authResult) {
                    // checkAuth() already sets isAuthenticated and currentUser with full data
                    // Reload conversations from API
                    await loadConversationsFromAPI();
                    updateConversationsList();
                    
                    updateAuthUI();
                    updateSidebarProfileLink();
                    await updateTokensBadge(); // Update tokens badge after registration
                    closeAuthModal();
                    
                    console.log('Registration successful, user data loaded:', currentUser);
                } else {
                    errorDiv.textContent = 'Registration successful but failed to load user data';
                    return;
                }
            } catch (error) {
                console.error('Registration error:', error);
                errorDiv.textContent = 'Network error. Please try again.';
            }
        }

        function handleGoogleSignIn() {
            // Redirect to Google OAuth endpoint
            window.location.href = `${API_BASE}/api/auth/google`;
        }

        function updateAuthUI() {
            const hopInBtn = document.querySelector('.header-btn.primary');
            if (!hopInBtn) {
                console.warn('Hop In button not found');
                return;
            }
            
            if (isAuthenticated && currentUser) {
                // Extract name from email if not set
                const userName = currentUser.display_name || currentUser.name || (currentUser.email ? currentUser.email.split('@')[0] : 'User');
                if (!currentUser.name) {
                    currentUser.name = userName;
                }

                // Make button circular
                hopInBtn.style.width = '40px';
                hopInBtn.style.height = '40px';
                hopInBtn.style.padding = '0';
                hopInBtn.style.borderRadius = '50%';
                hopInBtn.style.border = '2px solid var(--accent)';
                hopInBtn.style.overflow = 'hidden';
                hopInBtn.style.display = 'flex';
                hopInBtn.style.alignItems = 'center';
                hopInBtn.style.justifyContent = 'center';
                hopInBtn.style.position = 'relative';

                // Get avatar (image, emoji, or default) - prioritize profile_picture from Google
                const avatarUrl = currentUser.profile_picture || currentUser.avatar || currentUser.profilePicture || currentUser.picture;
                // #region agent log
                fetch('http://127.0.0.1:7243/ingest/44364179-96d7-4a0f-ac4f-9f610636e213',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({sessionId:'debug-session',runId:'run1',hypothesisId:'H2',location:'index.html:updateAuthUI',message:'Header avatar rendering',data:{avatarUrl,profile_picture:currentUser.profile_picture,avatar:currentUser.avatar,profilePicture:currentUser.profilePicture,picture:currentUser.picture},timestamp:Date.now()})}).catch(()=>{});
                // #endregion
                console.log('Updating avatar UI:', { avatarUrl, profile_picture: currentUser.profile_picture, avatar: currentUser.avatar });
                if (avatarUrl) {
                    // Add class to indicate profile picture is present
                    hopInBtn.classList.add('has-profile-picture');
                    // Show profile picture as background - use !important to override light-mode CSS
                    hopInBtn.style.setProperty('background-image', `url(${avatarUrl})`, 'important');
                    hopInBtn.style.setProperty('background-size', 'cover', 'important');
                    hopInBtn.style.setProperty('background-position', 'center', 'important');
                    hopInBtn.style.setProperty('background-color', 'transparent', 'important');
                    hopInBtn.innerHTML = '';
                    console.log('Profile picture displayed:', avatarUrl);
                } else if (currentUser.avatarEmoji) {
                    hopInBtn.style.backgroundImage = 'none';
                    hopInBtn.style.backgroundColor = 'var(--bg-tertiary)';
                    hopInBtn.innerHTML = `<span style="font-size: 1.5rem;">${currentUser.avatarEmoji}</span>`;
                } else {
                    hopInBtn.style.backgroundImage = 'none';
                    hopInBtn.style.backgroundColor = 'var(--bg-tertiary)';
                    const initial = userName.charAt(0).toUpperCase();
                    hopInBtn.innerHTML = `<span style="font-size: 1rem; font-weight: 600; color: var(--accent);">${initial}</span>`;
                    console.log('Using initial letter:', initial);
                }

                hopInBtn.onclick = () => window.location.href = '/profile';
                hopInBtn.title = userName || 'Profile';
            } else {
                // Remove profile picture class when not authenticated
                hopInBtn.classList.remove('has-profile-picture');
                hopInBtn.style.width = 'auto';
                hopInBtn.style.height = 'auto';
                hopInBtn.style.padding = '0.5rem 1rem';
                hopInBtn.style.borderRadius = '8px';
                hopInBtn.style.border = 'none';
                hopInBtn.style.overflow = 'visible';
                hopInBtn.style.backgroundImage = 'none';
                hopInBtn.style.backgroundColor = 'var(--accent)';
                hopInBtn.innerHTML = '<strong>Hop In</strong>';
                hopInBtn.onclick = showRegister;
                hopInBtn.title = '';
            }
        }

        // Close modal when clicking outside
        window.addEventListener('click', function (event) {
            const modal = document.getElementById('auth-modal');
            if (event.target === modal) {
                closeAuthModal();
            }
        });

        // Model Toggle Function
        let currentModel = 'model1'; // model1 = InfiNet-Coder (OFF/default), model2 = InfiNet-Thinker (ON)

        function toggleModel() {
            const toggle = document.getElementById('model-toggle');
            const label = document.getElementById('model-label');

            if (currentModel === 'model1') {
                // Switch to Thinker (ON)
                currentModel = 'model2';
                toggle.classList.add('active');
                label.textContent = 'Thinker';
            } else {
                // Switch to Coder (OFF)
                currentModel = 'model1';
                toggle.classList.remove('active');
                label.textContent = 'Coder';
            }
        }

        // Scroll to Bottom Button Functions
        function scrollToBottom() {
            const container = document.getElementById('chat-messages');
            const isMobile = window.innerWidth <= 768;
            
            if (isMobile) {
                // On mobile, scroll window to bottom
                window.scrollTo({
                    top: document.documentElement.scrollHeight,
                    behavior: 'smooth'
                });
            } else if (container) {
                // On desktop, scroll container to bottom
                container.scrollTo({
                    top: container.scrollHeight,
                    behavior: 'smooth'
                });
            }
            
            // Hide button after scrolling
            setTimeout(checkScrollPosition, 300);
        }

        // #region agent log
        let checkScrollPositionCallCount = 0;
        // #endregion
        function checkScrollPosition() {
            // #region agent log
            checkScrollPositionCallCount++;
            if (checkScrollPositionCallCount % 10 === 0) {
                fetch('http://127.0.0.1:7242/ingest/3ed930ca-2135-4e7e-8d90-8b30632dad4b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:5032',message:'checkScrollPosition called',data:{callCount:checkScrollPositionCallCount},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
            }
            // #endregion
            const container = document.getElementById('chat-messages');
            const scrollBtn = document.getElementById('scroll-to-bottom-btn');
            
            if (!container || !scrollBtn) {
                return;
            }
            
            // For mobile, check window scroll instead of container scroll
            const isMobile = window.innerWidth <= 768;
            let isNearBottom = false;
            let hasScrollableContent = false;
            
            if (isMobile) {
                // On mobile, chat-messages doesn't scroll, window does
                const windowHeight = window.innerHeight;
                const documentHeight = document.documentElement.scrollHeight;
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                hasScrollableContent = documentHeight > windowHeight;
                isNearBottom = documentHeight - scrollTop - windowHeight < 100;
            } else {
                // On desktop, check container scroll
                hasScrollableContent = container.scrollHeight > container.clientHeight;
                isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 100;
            }
            
            // Show button if there's scrollable content and user is not at bottom
            if (hasScrollableContent && !isNearBottom) {
                scrollBtn.classList.add('show');
            } else {
                scrollBtn.classList.remove('show');
            }
        }

        // Initialize scroll listener for chat messages
        // #region agent log
        let mutationObserverInstance = null;
        let scrollListenerHandler = null;
        let scrollListenerTarget = null;
        let resizeListenerHandler = null;
        let initScrollResizeTimeout = null;
        // #endregion
        function initScrollToBottom() {
            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/3ed930ca-2135-4e7e-8d90-8b30632dad4b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:5125',message:'initScrollToBottom called',data:{hasObserver:!!mutationObserverInstance,hasScrollListener:!!scrollListenerHandler,hasResizeListener:!!resizeListenerHandler},timestamp:Date.now(),sessionId:'debug-session',runId:'post-fix',hypothesisId:'A'})}).catch(()=>{});
            // #endregion
            const container = document.getElementById('chat-messages');
            const scrollBtn = document.getElementById('scroll-to-bottom-btn');
            const isMobile = window.innerWidth <= 768;
            
            if (!container || !scrollBtn) {
                console.log('[initScrollToBottom] Container or button not found, retrying...');
                setTimeout(initScrollToBottom, 500);
                return;
            }
            
            // Clean up old MutationObserver
            // #region agent log
            if (mutationObserverInstance) {
                fetch('http://127.0.0.1:7242/ingest/3ed930ca-2135-4e7e-8d90-8b30632dad4b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:5140',message:'Disconnecting old MutationObserver',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'post-fix',hypothesisId:'A'})}).catch(()=>{});
                mutationObserverInstance.disconnect();
                mutationObserverInstance = null;
            }
            // #endregion
            
            // Remove old scroll listener before adding new one
            if (scrollListenerHandler && scrollListenerTarget) {
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/3ed930ca-2135-4e7e-8d90-8b30632dad4b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:5146',message:'Removing old scroll listener',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'post-fix',hypothesisId:'B'})}).catch(()=>{});
                // #endregion
                scrollListenerTarget.removeEventListener('scroll', scrollListenerHandler);
                scrollListenerHandler = null;
                scrollListenerTarget = null;
            }
            
            // Add new scroll listener
            if (isMobile) {
                // On mobile, listen to window scroll
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/3ed930ca-2135-4e7e-8d90-8b30632dad4b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:5155',message:'Adding window scroll listener',data:{isMobile:true},timestamp:Date.now(),sessionId:'debug-session',runId:'post-fix',hypothesisId:'B'})}).catch(()=>{});
                // #endregion
                scrollListenerHandler = checkScrollPosition;
                scrollListenerTarget = window;
                window.addEventListener('scroll', scrollListenerHandler, { passive: true });
            } else if (container) {
                // On desktop, listen to container scroll
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/3ed930ca-2135-4e7e-8d90-8b30632dad4b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:5166',message:'Adding container scroll listener',data:{isMobile:false},timestamp:Date.now(),sessionId:'debug-session',runId:'post-fix',hypothesisId:'B'})}).catch(()=>{});
                // #endregion
                scrollListenerHandler = checkScrollPosition;
                scrollListenerTarget = container;
                container.addEventListener('scroll', scrollListenerHandler, { passive: true });
            }
            
            // Check initial position multiple times to ensure it works
            setTimeout(checkScrollPosition, 100);
            setTimeout(checkScrollPosition, 500);
            setTimeout(checkScrollPosition, 1000);
            
            // Also check after messages are rendered
            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/3ed930ca-2135-4e7e-8d90-8b30632dad4b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:5179',message:'Creating new MutationObserver',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'post-fix',hypothesisId:'A'})}).catch(()=>{});
            // #endregion
            const observer = new MutationObserver(function(mutations) {
                // #region agent log
                if (mutations.length > 0 && mutations.length % 50 === 0) {
                    fetch('http://127.0.0.1:7242/ingest/3ed930ca-2135-4e7e-8d90-8b30632dad4b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:5183',message:'MutationObserver callback triggered',data:{mutationCount:mutations.length},timestamp:Date.now(),sessionId:'debug-session',runId:'post-fix',hypothesisId:'A'})}).catch(()=>{});
                }
                // #endregion
                // Throttle checkScrollPosition to prevent excessive calls
                clearTimeout(checkScrollPosition.timeoutId);
                checkScrollPosition.timeoutId = setTimeout(checkScrollPosition, 100);
            });
            observer.observe(container, { childList: true, subtree: true });
            mutationObserverInstance = observer;
            
            // Remove old resize listener before adding new one
            if (resizeListenerHandler) {
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/3ed930ca-2135-4e7e-8d90-8b30632dad4b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:5195',message:'Removing old resize listener',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'post-fix',hypothesisId:'B'})}).catch(()=>{});
                // #endregion
                window.removeEventListener('resize', resizeListenerHandler);
                resizeListenerHandler = null;
            }
            
            // Re-initialize on window resize (mobile/desktop switch)
            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/3ed930ca-2135-4e7e-8d90-8b30632dad4b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:5200',message:'Adding resize listener',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'post-fix',hypothesisId:'B'})}).catch(()=>{});
            // #endregion
            resizeListenerHandler = function() {
                if (initScrollResizeTimeout) {
                    clearTimeout(initScrollResizeTimeout);
                }
                initScrollResizeTimeout = setTimeout(function() {
                    initScrollToBottom();
                }, 250);
            };
            window.addEventListener('resize', resizeListenerHandler);
        }

        // Image to Image Functions
        let pendingImageToImage = null; // Store the image until user sends prompt
        
        function openImageToImage() {
            document.getElementById('img-to-img-upload').click();
        }

        function handleImageToImageUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const imageUrl = e.target.result;
                    
                    // Store the image for later sending
                    pendingImageToImage = imageUrl;
                    
                    // Show preview in input area
                    showImagePreview(imageUrl);
                    
                    // Update placeholder for image-to-image
                    const input = document.getElementById('message-input');
                    input.placeholder = 'Describe what you want to change in this image...';
                    input.focus();
                };
                reader.readAsDataURL(file);
            }
            // Reset the file input
            event.target.value = '';
        }
        
        function showImagePreview(imageUrl) {
            // Remove any existing preview
            const existingPreview = document.querySelector('.image-preview-container');
            if (existingPreview) {
                existingPreview.remove();
            }
            
            // Create preview container
            const previewContainer = document.createElement('div');
            previewContainer.className = 'image-preview-container';
            previewContainer.style.cssText = `
                position: relative;
                padding: 10px;
                background: var(--bg-secondary);
                border-radius: 8px;
                margin-bottom: 10px;
                display: flex;
                align-items: center;
                gap: 10px;
            `;
            
            // Create preview image
            const previewImg = document.createElement('img');
            previewImg.src = imageUrl;
            previewImg.style.cssText = `
                max-width: 80px;
                max-height: 80px;
                border-radius: 6px;
                object-fit: cover;
            `;
            
            // Create label
            const label = document.createElement('span');
            label.textContent = 'Image to modify';
            label.style.cssText = `
                flex: 1;
                color: var(--text-secondary);
                font-size: 0.9rem;
            `;
            
            // Create remove button
            const removeBtn = document.createElement('button');
            removeBtn.innerHTML = `
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            `;
            removeBtn.style.cssText = `
                background: transparent;
                border: none;
                cursor: pointer;
                padding: 5px;
                display: flex;
                align-items: center;
                justify-content: center;
                color: var(--text-secondary);
                transition: color 0.2s;
            `;
            removeBtn.onmouseover = () => removeBtn.style.color = 'var(--accent)';
            removeBtn.onmouseout = () => removeBtn.style.color = 'var(--text-secondary)';
            removeBtn.onclick = cancelImageToImage;
            
            previewContainer.appendChild(previewImg);
            previewContainer.appendChild(label);
            previewContainer.appendChild(removeBtn);
            
            // Insert preview above the input
            const chatInputArea = document.querySelector('.chat-input-area');
            chatInputArea.insertBefore(previewContainer, chatInputArea.firstChild);
        }
        
        function cancelImageToImage() {
            pendingImageToImage = null;
            const preview = document.querySelector('.image-preview-container');
            if (preview) {
                preview.remove();
            }
            const input = document.getElementById('message-input');
            input.placeholder = 'Ask me anything...';
        }

        async function addImageToImageToChat(imageUrl, prompt) {
            const container = document.getElementById('chat-messages');
            const welcome = document.getElementById('welcome-screen');
            welcome.classList.add('hidden');

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message user';

            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            // Check if user has a profile picture
            const avatarUrl = currentUser && (currentUser.profile_picture || currentUser.avatar || currentUser.profilePicture || currentUser.picture);
            if (avatarUrl && avatarUrl.trim() !== '') {
                // Show user's profile picture
                const img = document.createElement('img');
                img.src = avatarUrl;
                img.alt = 'User';
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'cover';
                img.style.borderRadius = '50%';
                img.onerror = function() {
                    console.error('Failed to load profile picture:', avatarUrl);
                    // Fallback to 'U' if image fails to load
                    const userInitial = (currentUser?.displayName || currentUser?.name || (currentUser?.email ? currentUser.email.split('@')[0] : 'U')).charAt(0).toUpperCase();
                    avatar.textContent = userInitial || 'U';
                    avatar.classList.add('no-photo');
                };
                avatar.appendChild(img);
            } else {
                // Fallback to 'U' if no profile picture
                const userInitial = (currentUser?.displayName || currentUser?.name || (currentUser?.email ? currentUser.email.split('@')[0] : 'U')).charAt(0).toUpperCase();
                avatar.textContent = userInitial || 'U';
                avatar.classList.add('no-photo');
            }

            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            // Show image with prompt
            contentDiv.innerHTML = `
                <div style="margin-bottom: 0.5rem;">
                    <img src="${imageUrl}" alt="Source image" style="max-width: 300px; border-radius: 8px;">
                </div>
                <p style="margin-top: 0.5rem;"><strong>Prompt:</strong> ${prompt}</p>
            `;

            messageDiv.appendChild(avatar);
            messageDiv.appendChild(contentDiv);
            container.appendChild(messageDiv);

            // Add to conversation history
            const messageWithImage = `[Image-to-Image] ${prompt}`;
            if (currentConversation) {
                currentConversation.messages.push({ 
                    role: 'user', 
                    content: messageWithImage,
                    imageData: imageUrl // Store image data for backend
                });
                
                // Save to API if authenticated
                if (currentUser && typeof currentConversation.id === 'number') {
                    await addMessageToConversationAPI(currentConversation.id, 'user', messageWithImage);
                }
            }

            container.scrollTop = container.scrollHeight;
            checkScrollPosition();
        }

        // Regular Image Upload (for chat)
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const imageUrl = e.target.result;
                    addImageToChat(imageUrl);
                };
                reader.readAsDataURL(file);
            }
        }

        function addImageToChat(imageUrl) {
            const container = document.getElementById('chat-messages');
            const welcome = document.getElementById('welcome-screen');
            welcome.classList.add('hidden');

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message user';

            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            // Check if user has a profile picture
            const avatarUrl = currentUser && (currentUser.profile_picture || currentUser.avatar || currentUser.profilePicture || currentUser.picture);
            if (avatarUrl && avatarUrl.trim() !== '') {
                // Show user's profile picture
                const img = document.createElement('img');
                img.src = avatarUrl;
                img.alt = 'User';
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'cover';
                img.style.borderRadius = '50%';
                img.onerror = function() {
                    console.error('Failed to load profile picture:', avatarUrl);
                    // Fallback to 'U' if image fails to load
                    const userInitial = (currentUser?.displayName || currentUser?.name || (currentUser?.email ? currentUser.email.split('@')[0] : 'U')).charAt(0).toUpperCase();
                    avatar.textContent = userInitial || 'U';
                    avatar.classList.add('no-photo');
                };
                avatar.appendChild(img);
            } else {
                // Fallback to 'U' if no profile picture
            const userInitial = (currentUser?.displayName || currentUser?.name || (currentUser?.email ? currentUser.email.split('@')[0] : 'U')).charAt(0).toUpperCase();
            avatar.textContent = userInitial || 'U';
            avatar.classList.add('no-photo');
            }

            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.innerHTML = `<img src="${imageUrl}" alt="Uploaded image" style="max-width: 300px; border-radius: 8px; margin-top: 0.5rem;">`;

            messageDiv.appendChild(avatar);
            messageDiv.appendChild(contentDiv);
            container.appendChild(messageDiv);

            container.scrollTop = container.scrollHeight;
            checkScrollPosition();
        }

        // Update theme-color meta tag
        function updateThemeColor(isLight) {
            // Get all theme-color meta tags (including media query ones)
            const allThemeColorMetas = document.querySelectorAll('meta[name="theme-color"]');
            let themeColorMeta = document.querySelector('meta[name="theme-color"]:not([media])');
            const themeColorMetaLight = document.querySelector('meta[name="theme-color"][media*="light"]');
            const themeColorMetaDark = document.querySelector('meta[name="theme-color"][media*="dark"]');
            let appleStatusBarMeta = document.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
            
            // Create or update the main theme-color meta (without media query) - Chrome needs this
            if (!themeColorMeta) {
                themeColorMeta = document.createElement('meta');
                themeColorMeta.setAttribute('name', 'theme-color');
                document.head.appendChild(themeColorMeta);
            }
            
            // Update media query meta tags for Safari
            if (themeColorMetaLight) {
                themeColorMetaLight.setAttribute('content', isLight ? '#ffffff' : '#000000');
            }
            if (themeColorMetaDark) {
                themeColorMetaDark.setAttribute('content', isLight ? '#ffffff' : '#000000');
            }
            
            // Update main theme-color meta (Chrome uses this, Safari also respects it)
            const newColor = isLight ? '#ffffff' : '#000000';
            themeColorMeta.setAttribute('content', newColor);
            
            // Force update by removing and re-adding for ALL browsers (not just iOS) to ensure browser chrome updates
            const parent = themeColorMeta.parentNode;
            const nextSibling = themeColorMeta.nextSibling;
            const newMeta = themeColorMeta.cloneNode(true);
            newMeta.setAttribute('content', newColor);
            parent.removeChild(themeColorMeta);
            if (nextSibling) {
                parent.insertBefore(newMeta, nextSibling);
            } else {
                parent.appendChild(newMeta);
            }
            themeColorMeta = newMeta;
            
            // Force multiple updates for stubborn browsers (especially Safari)
            setTimeout(() => {
                const currentMeta = document.querySelector('meta[name="theme-color"]:not([media])');
                if (currentMeta) {
                    currentMeta.setAttribute('content', newColor);
                }
            }, 0);
            setTimeout(() => {
                const currentMeta = document.querySelector('meta[name="theme-color"]:not([media])');
                if (currentMeta) {
                    currentMeta.setAttribute('content', newColor);
                }
            }, 50);
            setTimeout(() => {
                const currentMeta = document.querySelector('meta[name="theme-color"]:not([media])');
                if (currentMeta) {
                    currentMeta.setAttribute('content', newColor);
                }
            }, 100);
            
            if (!appleStatusBarMeta) {
                appleStatusBarMeta = document.createElement('meta');
                appleStatusBarMeta.setAttribute('name', 'apple-mobile-web-app-status-bar-style');
                document.head.appendChild(appleStatusBarMeta);
            }
            
            if (isLight) {
                appleStatusBarMeta.setAttribute('content', 'default');
            } else {
                appleStatusBarMeta.setAttribute('content', 'black');
            }
        }

        // Theme Toggle Function
        function toggleTheme() {
            const body = document.body;
            const html = document.documentElement;
            const themeIcon = document.getElementById('theme-icon');
            const mainContent = document.querySelector('.main-content');
            const chatMessages = document.querySelector('.chat-messages');

            if (body.classList.contains('light-mode')) {
                body.classList.remove('light-mode');
                // Immediately update background colors for dark mode
                html.style.setProperty('background-color', '#000000', 'important');
                body.style.setProperty('background-color', '#000000', 'important');
                if (mainContent) {
                    mainContent.style.setProperty('background-color', '#000000', 'important');
                }
                if (chatMessages) {
                    chatMessages.style.setProperty('background-color', 'transparent', 'important');
                }
                // Moon icon for dark mode (crescent moon)
                themeIcon.innerHTML = '<path d="M21.64 13a1 1 0 0 0-1.05-.14 8.05 8.05 0 0 1-3.37.73 8.15 8.15 0 0 1-8.14-8.1 8.59 8.59 0 0 1 .25-2A1 1 0 0 0 8 2.36 10.14 10.14 0 1 0 22 14.05 1 1 0 0 0 21.64 13Z" fill="currentColor"/>';
                localStorage.setItem('theme', 'dark');
                updateThemeColor(false);
                // Force refresh to ensure all elements update
                refreshThemeColor();
            } else {
                body.classList.add('light-mode');
                // Immediately update background colors for light mode
                html.style.setProperty('background-color', '#ffffff', 'important');
                body.style.setProperty('background-color', '#ffffff', 'important');
                if (mainContent) {
                    mainContent.style.setProperty('background-color', '#ffffff', 'important');
                }
                if (chatMessages) {
                    chatMessages.style.setProperty('background-color', 'transparent', 'important');
                }
                // Sun icon for light mode
                themeIcon.innerHTML = '<circle cx="12" cy="12" r="5" fill="currentColor"/><path d="M12 1V3M12 21V23M4.22 4.22L5.64 5.64M18.36 18.36L19.78 19.78M1 12H3M21 12H23M4.22 19.78L5.64 18.36M18.36 5.64L19.78 4.22" stroke="currentColor" stroke-width="2" stroke-linecap="round" fill="none"/>';
                localStorage.setItem('theme', 'light');
                updateThemeColor(true);
                // Force refresh to ensure all elements update
                refreshThemeColor();
            }
        }

        // Load saved theme on page load
        function loadTheme() {
            const savedTheme = localStorage.getItem('theme');
            const themeIcon = document.getElementById('theme-icon');

            if (savedTheme === 'light') {
                document.body.classList.add('light-mode');
                document.documentElement.setAttribute('data-force-light', '1');
                // Sun icon for light mode
                themeIcon.innerHTML = '<circle cx="12" cy="12" r="5" fill="currentColor"/><path d="M12 1V3M12 21V23M4.22 4.22L5.64 5.64M18.36 18.36L19.78 19.78M1 12H3M21 12H23M4.22 19.78L5.64 18.36M18.36 5.64L19.78 4.22" stroke="currentColor" stroke-width="2" stroke-linecap="round" fill="none"/>';
                updateThemeColor(true);
            } else {
                document.body.classList.remove('light-mode');
                document.documentElement.removeAttribute('data-force-light');
                // Moon icon for dark mode (crescent moon)
                themeIcon.innerHTML = '<path d="M21.64 13a1 1 0 0 0-1.05-.14 8.05 8.05 0 0 1-3.37.73 8.15 8.15 0 0 1-8.14-8.1 8.59 8.59 0 0 1 .25-2A1 1 0 0 0 8 2.36 10.14 10.14 0 1 0 22 14.05 1 1 0 0 0 21.64 13Z" fill="currentColor"/>';
                updateThemeColor(false);
            }
        }

        // Maintain theme-color on scroll (immediate, no debounce)
        function refreshThemeColor() {
            const isLightMode = document.body.classList.contains('light-mode');
            const html = document.documentElement;
            const body = document.body;
            const mainContent = document.querySelector('.main-content');
            const chatMessages = document.querySelector('.chat-messages');
            
            // Immediately update background colors
            if (isLightMode) {
                html.style.setProperty('background-color', '#ffffff', 'important');
                body.style.setProperty('background-color', '#ffffff', 'important');
                if (mainContent) {
                    mainContent.style.setProperty('background-color', '#ffffff', 'important');
                }
                if (chatMessages) {
                    chatMessages.style.setProperty('background-color', 'transparent', 'important');
                }
            } else {
                html.style.setProperty('background-color', '#000000', 'important');
                body.style.setProperty('background-color', '#000000', 'important');
                if (mainContent) {
                    mainContent.style.setProperty('background-color', '#000000', 'important');
                }
                if (chatMessages) {
                    chatMessages.style.setProperty('background-color', 'transparent', 'important');
                }
            }
            
            updateThemeColor(isLightMode);
            const topSafe = document.querySelector('.top-safe-area');
            if (topSafe) {
                // Only show in light mode, always hide in dark mode
                if (isLightMode) {
                    topSafe.style.display = 'block';
                    topSafe.style.background = '#ffffff';
                } else {
                    topSafe.style.display = 'none';
                }
            }
            
            // Force update for all browsers to prevent reversion
            setTimeout(() => updateThemeColor(isLightMode), 0);
            setTimeout(() => updateThemeColor(isLightMode), 50);
        }
        window.addEventListener('scroll', refreshThemeColor, { passive: true });
        window.addEventListener('pageshow', refreshThemeColor, { passive: true });
        document.addEventListener('visibilitychange', function () {
            if (!document.hidden) {
                refreshThemeColor();
                // Force update again after visibility change for Safari
                setTimeout(() => refreshThemeColor(), 100);
            }
        }, { passive: true });
        window.addEventListener('resize', refreshThemeColor, { passive: true });
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', refreshThemeColor, { once: true });
        } else {
            refreshThemeColor();
        }
        
        


        // Expanded Card Functions
        let activeExpandedCard = null;

        function closeAllExpandedCards() {
            // Close all expanded cards and reset state
            const allExpanded = document.querySelectorAll('.info-card-expanded');
            allExpanded.forEach(expanded => {
                expanded.classList.remove('show');
            });

            const allCards = document.querySelectorAll('.info-card');
            allCards.forEach(card => {
                card.classList.remove('expanded-active');
            });

            activeExpandedCard = null;

            // IMPORTANT: Remove any inline styles that might block hover
            setTimeout(function () {
                allExpanded.forEach(expanded => {
                    expanded.style.display = '';
                    expanded.style.opacity = '';
                    expanded.style.visibility = '';
                });
            }, 50);
        }

        function showExpandedCard(type) {
            // Only show on hover for desktop (not touch devices)
            if ('ontouchstart' in window) {
                return; // Don't show on hover for mobile
            }

            // IMMEDIATELY close ALL other cards first (no matter which one)
            if (activeExpandedCard && activeExpandedCard !== type) {
                const otherExpanded = document.getElementById(activeExpandedCard + '-expanded');
                if (otherExpanded) {
                    otherExpanded.classList.remove('show');
                    // Don't set inline display - let CSS handle it
                    const otherParentCard = otherExpanded.closest('.info-card');
                    if (otherParentCard) {
                        otherParentCard.classList.remove('expanded-active');
                    }
                }
            }

            const expanded = document.getElementById(type + '-expanded');
            if (expanded) {
                // Ensure no inline styles are blocking it
                expanded.style.display = '';
                expanded.style.opacity = '';
                expanded.style.visibility = '';
                expanded.style.pointerEvents = '';

                expanded.classList.add('show');
                activeExpandedCard = type;
                // Add class to parent card for z-index
                const parentCard = expanded.closest('.info-card');
                if (parentCard) {
                    parentCard.classList.add('expanded-active');
                }
            }
        }

        function hideExpandedCard(type) {
            // Only hide on mouse leave for desktop (not touch devices)
            if ('ontouchstart' in window) {
                return; // Don't hide on mouse leave for mobile
            }

            // Immediately close if this is the active card
            if (activeExpandedCard === type) {
                const expanded = document.getElementById(type + '-expanded');
                if (expanded) {
                    // Small delay to allow mouse to move to expanded area
                    setTimeout(function () {
                        const card = expanded.closest('.info-card');
                        const isOverCard = card && card.matches(':hover');
                        const isOverExpanded = expanded && expanded.matches(':hover');

                        // Only close if mouse is not over card or expanded area
                        if (!isOverCard && !isOverExpanded && activeExpandedCard === type) {
                            expanded.classList.remove('show');
                            activeExpandedCard = null;
                            if (card) {
                                card.classList.remove('expanded-active');
                            }
                        }
                    }, 150);
                }
            }
        }

        function toggleExpandedCard(type) {
            const expanded = document.getElementById(type + '-expanded');
            if (expanded) {
                const isCurrentlyOpen = expanded.classList.contains('show');

                // ALWAYS close ALL other expanded cards first (force with inline styles)
                const allExpanded = document.querySelectorAll('.info-card-expanded');
                allExpanded.forEach(exp => {
                    if (exp !== expanded) {
                        exp.classList.remove('show');
                        exp.style.display = 'none';
                        const parentCard = exp.closest('.info-card');
                        if (parentCard) {
                            parentCard.classList.remove('expanded-active');
                        }
                    }
                });

                // Toggle current card
                const parentCard = expanded.closest('.info-card');
                if (isCurrentlyOpen) {
                    // If currently open, close it
                    expanded.classList.remove('show');
                    expanded.style.display = 'none';
                    activeExpandedCard = null;
                    if (parentCard) {
                        parentCard.classList.remove('expanded-active');
                    }

                    // Reset display style after a moment
                    setTimeout(function () {
                        expanded.style.display = '';
                    }, 200);
                } else {
                    // If closed, open it - reset display first
                    expanded.style.display = '';
                    expanded.classList.add('show');
                    activeExpandedCard = type;
                    if (parentCard) {
                        parentCard.classList.add('expanded-active');
                    }
                }
            }
        }

        // Sidebar Toggle Functions
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebar-overlay');
            const hint = document.getElementById('sidebar-hint');

            const isOpen = sidebar.classList.contains('sidebar-open');

            if (isOpen) {
                // Closing sidebar - close all expanded cards
                closeAllExpandedCards();
                sidebar.classList.remove('sidebar-open');
                sidebar.classList.add('mobile-hidden');
                overlay.classList.remove('show');
                // Show hint when sidebar closes
                if (hint) {
                    hint.classList.remove('hidden');
                }
            } else {
                // Opening sidebar
                sidebar.classList.remove('mobile-hidden');
                sidebar.classList.add('sidebar-open');
                overlay.classList.add('show');
                // Hide hint when sidebar opens
                if (hint) {
                    hint.classList.add('hidden');
                }
            }
        }

        function closeSidebar() {
            // Always close expanded cards when closing sidebar
            closeAllExpandedCards();
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebar-overlay');
            const hint = document.getElementById('sidebar-hint');

            sidebar.classList.remove('sidebar-open');
            sidebar.classList.add('mobile-hidden');
            overlay.classList.remove('show');
            // Show hint when sidebar closes
            if (hint) {
                hint.classList.remove('hidden');
            }
        }

        // Close sidebar when clicking on a conversation item
        async function handleConversationClick(conv) {
            await loadConversation(conv);
            closeSidebar();
        }

        // Close sidebar when clicking anywhere outside (but not on sidebar itself)
        document.addEventListener('click', function (event) {
            const sidebar = document.getElementById('sidebar');
            const sidebarHandle = sidebar ? sidebar.querySelector('.sidebar-handle') : null;

            // Check if sidebar is open
            if (sidebar && sidebar.classList.contains('sidebar-open')) {
                // If click is on the handle, let toggleSidebar handle it
                if (sidebarHandle && sidebarHandle.contains(event.target)) {
                    return;
                }

                // If click is inside sidebar, don't close
                if (sidebar.contains(event.target)) {
                    return;
                }

                // Otherwise, close the sidebar
                closeSidebar();
            }
        });

        // Close expanded card when clicking outside (mobile and desktop)
        document.addEventListener('click', function (event) {
            if (activeExpandedCard) {
                const card = event.target.closest('.info-card');
                const expanded = event.target.closest('.info-card-expanded');

                // If click is outside both card and expanded area, close it
                if (!card && !expanded) {
                    closeAllExpandedCards();
                }
            }
        });

        // Close expanded cards when clicking on a conversation item (to prevent conflicts)
        document.addEventListener('click', function (event) {
            if (event.target.closest('.conversation-item-content')) {
                closeAllExpandedCards();
            }
        });

        // Close expanded cards when sidebar overlay is clicked
        document.addEventListener('click', function (event) {
            if (event.target.classList.contains('sidebar-overlay')) {
                closeAllExpandedCards();
            }
        });

        // Watch for sidebar visibility changes and close cards
        const sidebar = document.getElementById('sidebar');
        if (sidebar) {
            const observer = new MutationObserver(function (mutations) {
                mutations.forEach(function (mutation) {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                        const isHidden = sidebar.classList.contains('mobile-hidden');
                        if (isHidden) {
                            closeAllExpandedCards();
                        }
                    }
                });
            });

            observer.observe(sidebar, {
                attributes: true,
                attributeFilter: ['class']
            });
        }

        // Initialize sidebar - always hidden by default
        function initializeSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebar-overlay');

            if (sidebar && overlay) {
                // Always hide sidebar by default (both mobile and desktop)
                sidebar.classList.remove('sidebar-open');
                sidebar.classList.add('mobile-hidden');
                overlay.classList.remove('show');
            }
        }

        // Initialize
        loadTheme();

        // CRITICAL: Force close ALL expanded cards immediately on page load
        // Reset activeExpandedCard state first
        activeExpandedCard = null;

        // Function to aggressively close all cards (only for initialization)
        function forceCloseAllCards() {
            activeExpandedCard = null;
            const allExpanded = document.querySelectorAll('.info-card-expanded');
            allExpanded.forEach(expanded => {
                expanded.classList.remove('show');
                // Don't set inline styles - let CSS handle it
            });

            const allCards = document.querySelectorAll('.info-card');
            allCards.forEach(card => {
                card.classList.remove('expanded-active');
            });

            // Clear any lingering inline styles immediately
            setTimeout(function () {
                allExpanded.forEach(expanded => {
                    expanded.style.display = '';
                    expanded.style.opacity = '';
                    expanded.style.visibility = '';
                });
            }, 100);
        }

        // Close cards immediately
        forceCloseAllCards();
        closeAllExpandedCards();

        // CRITICAL: Initialize sidebar state FIRST, before anything else
        // This must happen before loading conversations to prevent state conflicts
        initializeSidebar();

        // Force sidebar reset on page load (especially important for redirects)
        (function () {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebar-overlay');

            // Reset all sidebar-related classes and states - always hidden by default
            if (sidebar && overlay) {
                sidebar.classList.remove('sidebar-open');
                sidebar.classList.add('mobile-hidden');
                overlay.classList.remove('show');
            }

            // Then apply correct state based on screen size
            const menuToggle = document.getElementById('menu-toggle') || document.querySelector('.menu-toggle');
            if (window.innerWidth <= 768) {
                sidebar.classList.add('mobile-hidden');
                if (menuToggle) {
                menuToggle.style.display = '';
                }
            } else {
                if (menuToggle) {
                menuToggle.style.display = 'none';
                }
            }

            // Ensure all expanded cards are closed AGAIN
            forceCloseAllCards();
            closeAllExpandedCards();
        })();

        // Also run on DOM ready and window load as backup
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function () {
                initializeSidebar();
                forceCloseAllCards();
                closeAllExpandedCards();
            });
        }
        window.addEventListener('load', function () {
            initializeSidebar();
            forceCloseAllCards();
            closeAllExpandedCards();
        });

        // Mobile browser UI hiding - minimize bottom bar on touch/click
        (function () {
            function isMobile() {
                return window.innerWidth <= 768;
            }

            // Set body height to full viewport to enable browser UI hiding
            function setFullHeight() {
                if (!isMobile()) return;
                const vh = window.innerHeight * 0.01;
                document.documentElement.style.setProperty('--vh', `${vh}px`);
                // Make body slightly taller to enable scrolling
                document.body.style.minHeight = `${window.innerHeight + 1}px`;
            }

            setFullHeight();
            window.addEventListener('resize', setFullHeight);
            window.addEventListener('orientationchange', function () {
                setTimeout(setFullHeight, 100);
            });

            // Browser UI hiding - ensure window is scrollable
            if (isMobile()) {
                // Force window to be scrollable by ensuring body is taller than viewport
                function ensureWindowScrollable() {
                    const vh = window.innerHeight;
                    const bodyHeight = document.body.scrollHeight;
                    const htmlHeight = document.documentElement.scrollHeight;

                    // Ensure both html and body are taller than viewport
                    if (htmlHeight <= vh) {
                        document.documentElement.style.minHeight = `${vh + 200}px`;
                    }
                    if (bodyHeight <= vh) {
                        document.body.style.minHeight = `${vh + 200}px`;
                    }
                }

                // Run immediately
                ensureWindowScrollable();

                // Run on resize
                window.addEventListener('resize', ensureWindowScrollable);
                window.addEventListener('orientationchange', function () {
                    setTimeout(ensureWindowScrollable, 200);
                });
            }


            // Prevent viewport shift on input focus
            const chatInput = document.getElementById('message-input');
            if (chatInput) {
                chatInput.addEventListener('focus', function () {
                    if (isMobile()) {
                        // Prevent iOS Safari from scrolling
                        setTimeout(() => {
                            const mainContent = document.querySelector('.main-content');
                            if (mainContent) {
                                mainContent.scrollTop = mainContent.scrollHeight;
                            }
                        }, 300);
                    }
                }, { passive: true });
            }

            // Handle viewport height changes (when browser UI shows/hides)
            let viewportHeight = window.innerHeight;
            function updateViewportHeight() {
                if (isMobile()) {
                    const newHeight = window.innerHeight;
                    if (Math.abs(newHeight - viewportHeight) > 50) {
                        viewportHeight = newHeight;
                        document.documentElement.style.setProperty('--vh', `${newHeight * 0.01}px`);
                        // Update main content height
                        const mainContent = document.querySelector('.main-content');
                        if (mainContent) {
                            mainContent.style.height = `${newHeight}px`;
                        }
                    }
                }
            }

            window.addEventListener('resize', updateViewportHeight, { passive: true });
            window.addEventListener('orientationchange', function () {
                setTimeout(updateViewportHeight, 100);
            });

            // Initial call
            if (isMobile()) {
                updateViewportHeight();
            }

            // Handle keyboard visibility for input container transform and footer position
            function handleViewportResize() {
                // CRITICAL: Don't run on desktop - let clearMobileStylesOnDesktop handle it
                if (!isMobile() || window.innerWidth > 768) {
                    // Clear any mobile styles if we're on desktop
                    if (window.innerWidth > 768) {
                        clearMobileStylesOnDesktop();
                    }
                    return;
                }

                const inputContainer = document.querySelector('.input-container');
                const footer = document.querySelector('.chat-footer');
                if (!inputContainer) return;

                if (window.visualViewport) {
                    const viewport = window.visualViewport;
                    const windowHeight = window.innerHeight;
                    const viewportHeight = viewport.height;
                    const keyboardHeight = windowHeight - viewportHeight;

                    // Set CSS variable for keyboard height
                    document.documentElement.style.setProperty('--keyboard-height', `${keyboardHeight}px`);

                    // Toggle keyboard-visible class based on keyboard presence
                    if (keyboardHeight > 150) {
                        inputContainer.classList.add('keyboard-visible');
                        // Hide footer and footer-center when keyboard appears
                        if (footer) {
                            footer.style.display = 'none';
                            footer.style.position = 'absolute';
                            footer.style.bottom = '0';
                            footer.style.transform = 'translateY(0)';
                        }
                        const footerCenter = document.querySelector('.footer-center');
                        if (footerCenter) {
                            footerCenter.style.display = 'none';
                        }
                    } else {
                        inputContainer.classList.remove('keyboard-visible');
                        // Show footer and footer-center when keyboard hides
                        if (footer) {
                            footer.style.display = '';
                            footer.style.position = 'absolute';
                            footer.style.bottom = '0';
                            footer.style.transform = 'translateY(0)';
                        }
                        const footerCenter = document.querySelector('.footer-center');
                        if (footerCenter) {
                            footerCenter.style.display = '';
                        }
                    }
                } else {
                    // Fallback for browsers without visualViewport
                    const chatInput = document.getElementById('message-input');
                    if (chatInput && document.activeElement === chatInput) {
                        const windowHeight = window.innerHeight;
                        const screenHeight = screen.height;
                        const keyboardHeight = screenHeight - windowHeight;

                        if (keyboardHeight > 150) {
                            document.documentElement.style.setProperty('--keyboard-height', `${keyboardHeight}px`);
                            inputContainer.classList.add('keyboard-visible');
                            // Hide footer and footer-center when keyboard appears
                            if (footer) {
                                footer.style.display = 'none';
                                footer.style.position = 'absolute';
                                footer.style.bottom = '0';
                                footer.style.transform = 'translateY(0)';
                            }
                            const footerCenter = document.querySelector('.footer-center');
                            if (footerCenter) {
                                footerCenter.style.display = 'none';
                            }
                        } else {
                            inputContainer.classList.remove('keyboard-visible');
                            // Show footer and footer-center when keyboard hides
                            if (footer) {
                                footer.style.display = '';
                                footer.style.position = 'absolute';
                                footer.style.bottom = '0';
                                footer.style.transform = 'translateY(0)';
                            }
                            const footerCenter = document.querySelector('.footer-center');
                            if (footerCenter) {
                                footerCenter.style.display = '';
                            }
                        }
                    } else {
                        inputContainer.classList.remove('keyboard-visible');
                        // Show footer and footer-center when keyboard is not visible
                        if (footer) {
                            footer.style.display = '';
                            footer.style.position = 'absolute';
                            footer.style.bottom = '0';
                            footer.style.transform = 'translateY(0)';
                        }
                        const footerCenter = document.querySelector('.footer-center');
                        if (footerCenter) {
                            footerCenter.style.display = '';
                        }
                    }
                }
            }

            // Listen for visual viewport changes
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', handleViewportResize);
                window.visualViewport.addEventListener('scroll', handleViewportResize);
            } else {
                window.addEventListener('resize', handleViewportResize);
            }

            // Persistent footer position enforcement (runs continuously but not too aggressively)
            function enforceFooterPosition() {
                if (!isMobile()) return;

                const footer = document.querySelector('.chat-footer');
                const footerCenter = document.querySelector('.footer-center');
                const inputContainer = document.querySelector('.input-container');
                const chatInput = document.getElementById('message-input');
                
                // Check if keyboard is visible
                const isKeyboardVisible = inputContainer && (
                    inputContainer.classList.contains('keyboard-visible') ||
                    (chatInput && document.activeElement === chatInput)
                );

                if (footer) {
                    // Hide footer when keyboard is visible, show when hidden
                    if (isKeyboardVisible) {
                        footer.style.setProperty('display', 'none', 'important');
                    } else {
                        footer.style.setProperty('display', 'flex', 'important');
                    }
                    // Always enforce footer position
                    footer.style.setProperty('position', 'absolute', 'important');
                    footer.style.setProperty('bottom', '0', 'important');
                    footer.style.setProperty('transform', 'translateY(0)', 'important');
                    footer.style.setProperty('left', '0', 'important');
                    footer.style.setProperty('right', '0', 'important');
                }

                // Hide footer-center when keyboard is visible
                if (footerCenter) {
                    if (isKeyboardVisible) {
                        footerCenter.style.setProperty('display', 'none', 'important');
                    } else {
                        footerCenter.style.setProperty('display', 'flex', 'important');
                    }
                }
            }

            // Run footer enforcement periodically (every 200ms) to catch any changes
            if (isMobile()) {
                // Clear any existing interval first
                if (footerEnforcementInterval) {
                    clearInterval(footerEnforcementInterval);
                }
                footerEnforcementInterval = setInterval(enforceFooterPosition, 200);
                // Also enforce immediately
                enforceFooterPosition();
            } else {
                // Stop footer enforcement on desktop
                if (footerEnforcementInterval) {
                    clearInterval(footerEnforcementInterval);
                    footerEnforcementInterval = null;
                }
            }

            // Handle input focus/blur for keyboard detection - ensure it works every time
            if (chatInput) {
                chatInput.addEventListener('focus', function () {
                    if (isMobile()) {
                        // Call multiple times to ensure it works consistently
                        handleViewportResize();
                        enforceFooterPosition();
                        setTimeout(function () {
                            handleViewportResize();
                            enforceFooterPosition();
                        }, 100);
                        setTimeout(function () {
                            handleViewportResize();
                            enforceFooterPosition();
                        }, 300);
                        setTimeout(function () {
                            handleViewportResize();
                            enforceFooterPosition();
                        }, 500);
                    }
                }, { passive: true });

                chatInput.addEventListener('blur', function () {
                    if (isMobile()) {
                        const inputContainer = document.querySelector('.input-container');
                        if (inputContainer) {
                            inputContainer.classList.remove('keyboard-visible');
                        }
                        // Show footer and footer-center when keyboard hides
                        const footer = document.querySelector('.chat-footer');
                        const footerCenter = document.querySelector('.footer-center');
                        if (footer) {
                            footer.style.display = '';
                        }
                        if (footerCenter) {
                            footerCenter.style.display = '';
                        }
                        // Enforce footer position multiple times
                        enforceFooterPosition();
                        setTimeout(enforceFooterPosition, 50);
                        setTimeout(enforceFooterPosition, 100);
                        setTimeout(enforceFooterPosition, 200);
                    }
                }, { passive: true });
            }

            // Also enforce footer on every viewport resize
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', function () {
                    if (isMobile()) {
                        handleViewportResize();
                        enforceFooterPosition();
                    }
                });
                window.visualViewport.addEventListener('scroll', function () {
                    if (isMobile()) {
                        handleViewportResize();
                        enforceFooterPosition();
                    }
                });
            } else {
                window.addEventListener('resize', function () {
                    if (isMobile()) {
                        handleViewportResize();
                        enforceFooterPosition();
                    }
                });
            }
        })();

        // Register Service Worker for PWA Install Prompt
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js?v=2')
                    .then((registration) => {
                        console.log('[PWA] Service Worker registered:', registration.scope);
                        // Check for updates
                        registration.update();
                        
                        // Listen for install prompt (Chrome) and show banner
                        window.addEventListener('beforeinstallprompt', (e) => {
                            e.preventDefault(); // Prevent Chrome's default banner
                            console.log('[PWA] Install prompt available!', e);
                            // Store the event for later use
                            window.deferredPrompt = e;
                            
                            // Show custom banner
                            const banner = document.getElementById('chrome-install-banner');
                            if (banner) {
                                banner.classList.add('show');
                                
                                // Install button click
                                const installBtn = document.getElementById('chrome-install-btn');
                                if (installBtn) {
                                    installBtn.addEventListener('click', async () => {
                                        if (window.deferredPrompt) {
                                            try {
                                                await window.deferredPrompt.prompt();
                                                const result = await window.deferredPrompt.userChoice;
                                                console.log('[PWA] User choice:', result.outcome);
                                                window.deferredPrompt = null;
                                                banner.classList.remove('show');
                                            } catch (err) {
                                                console.error('[PWA] Install error:', err);
                                            }
                                        }
                                    });
                                }
                                
                                // Close button click
                                const closeBtn = document.getElementById('chrome-install-close');
                                if (closeBtn) {
                                    closeBtn.addEventListener('click', () => {
                                        banner.classList.remove('show');
                                        // Store dismissal in sessionStorage
                                        sessionStorage.setItem('chrome-install-dismissed', 'true');
                                    });
                                }
                                
                                // Check if already dismissed
                                if (sessionStorage.getItem('chrome-install-dismissed') === 'true') {
                                    banner.classList.remove('show');
                                }
                            }
                        });
                        
                        // Listen for app installed
                        window.addEventListener('appinstalled', () => {
                            console.log('[PWA] App installed successfully!');
                        });
                    })
                    .catch((error) => {
                        console.error('[PWA] Service Worker registration failed:', error);
                    });
            });
        }

        // Close cards on page visibility change and handle stream resumption
        document.addEventListener('visibilitychange', function () {
            if (!document.hidden) {
                forceCloseAllCards();
                
                // Check if streaming was interrupted and try to continue
                if (window._currentStreamingState && window._currentStreamingState.interrupted) {
                    const state = window._currentStreamingState;
                    console.log('Page visible again - checking for interrupted stream');
                    
                    // Check if we still have the loading message
                    const loadingMsg = state.loadingMsg;
                    if (loadingMsg && loadingMsg.parentNode) {
                        const messageContent = loadingMsg.querySelector('.message-content');
                        if (messageContent && state.partialMessage) {
                            // Check if message looks incomplete (ends mid-sentence or has loading indicator)
                            const hasLoading = loadingMsg.querySelector('.loading');
                            const partialMsg = state.partialMessage.trim();
                            
                            // If we have partial content and it seems incomplete, try to continue
                            if (partialMsg && (hasLoading || partialMsg.length > 0)) {
                                // Remove the interrupted indicator if it exists
                                const interruptedIndicator = messageContent.querySelector('div[onclick]');
                                if (interruptedIndicator) {
                                    interruptedIndicator.remove();
                                }
                                
                                // Try to continue the stream by making a new request
                                // Get the last user message to continue from
                                const lastUserMessage = currentConversation.messages.filter(m => m.role === 'user').pop();
                                if (lastUserMessage && currentConversation.id === state.conversationId) {
                                    // Auto-continue after a short delay
                                    setTimeout(() => {
                                        // Only continue if still on same conversation and still interrupted
                                        if (currentConversation.id === state.conversationId && window._currentStreamingState?.interrupted) {
                                            console.log('Auto-continuing interrupted stream');
                                            // Clear the interrupted state
                                            window._currentStreamingState = null;
                                            // Send continuation request - ask AI to continue from where it left off
                                            const input = document.getElementById('message-input');
                                            if (input) {
                                                input.value = 'Continue your previous response from: ' + state.partialMessage.slice(-100);
                                                sendMessage();
                                            }
                                        }
                                    }, 1500);
                                }
                            }
                        }
                    } else {
                        // Loading message was removed, clear state
                        window._currentStreamingState = null;
                    }
                }
            } else {
                // Page became hidden - try to keep connection alive
                // The Service Worker should help, but we can also mark state
                if (window._currentStreamingState && window._currentStreamingState.active) {
                    console.log('Page hidden - stream should continue in background via Service Worker');
                }
            }
        });

        // Store footer enforcement interval ID to clear it when needed (must be outside IIFE)
        let footerEnforcementInterval = null;

        // Handle window resize for desktop layout adjustments - clear mobile styles
        let resizeTimeout;
        let lastWindowWidth = window.innerWidth;
        
        function clearMobileStylesOnDesktop() {
            // Only run on desktop (non-mobile)
            if (window.innerWidth <= 768) return;
            
            // CRITICAL: Stop mobile footer enforcement IMMEDIATELY
            if (footerEnforcementInterval) {
                clearInterval(footerEnforcementInterval);
                footerEnforcementInterval = null;
            }
            
            // Also stop handleViewportResize from running
            const visualViewport = window.visualViewport;
            if (visualViewport) {
                visualViewport.removeEventListener('resize', handleViewportResize);
            }
            
            const chatInputArea = document.querySelector('.chat-input-area');
            const chatFooter = document.querySelector('.chat-footer');
            const footerCenter = document.querySelector('.footer-center');
            const inputContainer = document.querySelector('.input-container');
            const chatMessages = document.querySelector('.chat-messages');
            const mainContent = document.querySelector('.main-content');
            
            // Remove keyboard-visible class
            if (inputContainer) {
                inputContainer.classList.remove('keyboard-visible');
            }
            
            // IMMEDIATELY remove ALL inline styles - no delays
            if (chatFooter) {
                chatFooter.removeAttribute('style');
                chatFooter.style.visibility = 'visible';
                chatFooter.style.opacity = '1';
                chatFooter.style.position = 'relative';
                chatFooter.style.bottom = 'auto';
                chatFooter.style.left = 'auto';
                chatFooter.style.right = 'auto';
                chatFooter.style.width = 'auto';
                chatFooter.style.transform = 'none';
                chatFooter.style.padding = '2rem 1.5rem';
                chatFooter.style.paddingTop = '2rem';
                chatFooter.style.paddingBottom = '2rem';
                chatFooter.style.paddingLeft = '1.5rem';
                chatFooter.style.paddingRight = '1.5rem';
                chatFooter.style.minHeight = 'auto';
                chatFooter.style.height = 'auto';
            }
            
            if (footerCenter) {
                footerCenter.removeAttribute('style');
                footerCenter.style.visibility = 'visible';
                footerCenter.style.opacity = '1';
                footerCenter.style.minHeight = 'auto';
                footerCenter.style.height = 'auto';
            }
            
            if (chatInputArea) {
                // Remove all inline styles first
                chatInputArea.removeAttribute('style');
                // Force clear all properties with !important override
                chatInputArea.style.setProperty('position', 'relative', 'important');
                chatInputArea.style.setProperty('bottom', 'auto', 'important');
                chatInputArea.style.setProperty('left', 'auto', 'important');
                chatInputArea.style.setProperty('right', 'auto', 'important');
                chatInputArea.style.setProperty('width', 'auto', 'important');
                chatInputArea.style.setProperty('z-index', 'auto', 'important');
                chatInputArea.style.setProperty('transform', 'none', 'important');
                chatInputArea.style.setProperty('padding', '1.5rem', 'important');
                chatInputArea.style.setProperty('padding-bottom', '1.5rem', 'important');
                chatInputArea.style.setProperty('margin', '0', 'important');
                chatInputArea.style.setProperty('margin-top', '0', 'important');
                chatInputArea.style.setProperty('margin-bottom', '0', 'important');
                chatInputArea.style.setProperty('display', 'block', 'important');
                chatInputArea.style.setProperty('visibility', 'visible', 'important');
                chatInputArea.style.setProperty('opacity', '1', 'important');
            }
            
            if (inputContainer) {
                // Remove all inline styles first
                inputContainer.removeAttribute('style');
                // Force clear all properties with !important override
                inputContainer.style.setProperty('position', 'relative', 'important');
                inputContainer.style.setProperty('transform', 'translateY(0)', 'important');
                inputContainer.style.setProperty('margin-bottom', '0', 'important');
                inputContainer.style.setProperty('margin-top', '0', 'important');
                inputContainer.style.setProperty('margin', '0 auto', 'important');
                inputContainer.style.setProperty('display', 'flex', 'important');
                inputContainer.style.setProperty('visibility', 'visible', 'important');
                inputContainer.style.setProperty('opacity', '1', 'important');
            }
            
            // Reset chat-messages padding that might be pushing content down
            if (chatMessages) {
                chatMessages.style.removeProperty('padding-bottom');
                chatMessages.style.setProperty('padding-bottom', '2rem', 'important');
            }
            
            // Reset main-content height if it was constrained
            if (mainContent) {
                mainContent.style.removeProperty('height');
                mainContent.style.removeProperty('min-height');
                mainContent.style.removeProperty('padding-top');
                mainContent.style.removeProperty('padding-bottom');
            }
            
            // Check for duplicate footers and remove them
            const footers = document.querySelectorAll('.chat-footer');
            if (footers.length > 1) {
                // Keep only the first one, remove the rest
                for (let i = 1; i < footers.length; i++) {
                    footers[i].remove();
                }
            }
            
            // Clear keyboard height CSS variable
            document.documentElement.style.removeProperty('--keyboard-height');
            
            // Force a reflow to ensure styles are applied
            if (chatInputArea) {
                void chatInputArea.offsetHeight;
            }
            if (inputContainer) {
                void inputContainer.offsetHeight;
            }
            if (mainContent) {
                void mainContent.offsetHeight;
            }
        }
        
        // Auto-refresh page on resize (5ms delay) - MUST BE FIRST RESIZE LISTENER
        (function() {
            let refreshTimer = null;
            let lastWidth = window.innerWidth;
            let lastHeight = window.innerHeight;
            
            function handleResizeRefresh() {
                const currentWidth = window.innerWidth;
                const currentHeight = window.innerHeight;
                
                // Only refresh if size actually changed
                if (currentWidth !== lastWidth || currentHeight !== lastHeight) {
                    lastWidth = currentWidth;
                    lastHeight = currentHeight;
                    
                    // Clear any existing timer
                    if (refreshTimer) {
                        clearTimeout(refreshTimer);
                    }
                    
                    // Set timer to reload after 5ms
                    refreshTimer = setTimeout(function() {
                        window.location.reload(true); // Force reload from server
                    }, 5);
                }
            }
            
            // Add as first resize listener with capture phase
            window.addEventListener('resize', handleResizeRefresh, true);
        })();
        
        // Handle window resize - run cleanup IMMEDIATELY
        window.addEventListener('resize', function () {
            initializeSidebar();
            
            const currentWidth = window.innerWidth;
            const wasMobile = lastWindowWidth <= 768;
            const isNowMobile = currentWidth <= 768;
            
            // If we're on desktop or crossing to desktop, run cleanup IMMEDIATELY
            if (!isNowMobile || currentWidth > 768) {
                // Stop footer enforcement FIRST
                if (footerEnforcementInterval) {
                    clearInterval(footerEnforcementInterval);
                    footerEnforcementInterval = null;
                }
                
                // Run cleanup immediately MULTIPLE times to override any re-applied styles
                clearMobileStylesOnDesktop();
                clearMobileStylesOnDesktop();
                clearMobileStylesOnDesktop();
                
                // Run again in next frames to catch any re-applied styles
                requestAnimationFrame(function() {
                    clearMobileStylesOnDesktop();
                    requestAnimationFrame(function() {
                        clearMobileStylesOnDesktop();
                        setTimeout(clearMobileStylesOnDesktop, 0);
                        setTimeout(clearMobileStylesOnDesktop, 10);
                        setTimeout(clearMobileStylesOnDesktop, 50);
                        setTimeout(clearMobileStylesOnDesktop, 100);
                    });
                });
            }
            
            lastWindowWidth = currentWidth;
        });
        
        // Aggressive periodic cleanup on desktop - runs very frequently
        setInterval(function() {
            if (window.innerWidth > 768) {
                // Stop footer enforcement if it somehow started
                if (footerEnforcementInterval) {
                    clearInterval(footerEnforcementInterval);
                    footerEnforcementInterval = null;
                }
                
                // Check if mobile styles are present and clear them
                const footer = document.querySelector('.chat-footer');
                const inputArea = document.querySelector('.chat-input-area');
                const inputContainer = document.querySelector('.input-container');
                
                let needsCleanup = false;
                
                if (footer && footer.hasAttribute('style')) {
                    const computed = window.getComputedStyle(footer);
                    if (computed.position === 'absolute' || computed.bottom !== 'auto') {
                        needsCleanup = true;
                    }
                }
                
                if (inputArea) {
                    const computed = window.getComputedStyle(inputArea);
                    if (computed.position === 'fixed' || 
                        computed.bottom !== 'auto' || 
                        computed.visibility === 'hidden' ||
                        computed.opacity === '0' ||
                        computed.display === 'none') {
                        needsCleanup = true;
                    }
                }
                
                if (inputContainer) {
                    if (inputContainer.classList.contains('keyboard-visible')) {
                        needsCleanup = true;
                    }
                    const computed = window.getComputedStyle(inputContainer);
                    if (computed.visibility === 'hidden' || 
                        computed.opacity === '0' ||
                        computed.display === 'none') {
                        needsCleanup = true;
                    }
                }
                
                if (needsCleanup) {
                    clearMobileStylesOnDesktop();
                }
            }
        }, 100); // Check every 100ms - very aggressive
        
        // Run on initial load if on desktop
        if (window.innerWidth > 768) {
            clearMobileStylesOnDesktop();
            setTimeout(clearMobileStylesOnDesktop, 50);
            setTimeout(clearMobileStylesOnDesktop, 200);
        }

        // Initialize model toggle - default to Coder (off position = model1)
        document.getElementById('model-toggle').classList.remove('active');
        document.getElementById('model-label').textContent = 'Coder';
        currentModel = 'model1'; // Coder when OFF
        document.getElementById('message-input').focus();
        // Initialize auth UI
        updateAuthUI();
        // Load conversations list
        updateConversationsList();

        // Listen for user updates from profile page
        window.addEventListener('message', function (event) {
            if (event.data && event.data.type === 'userUpdated') {
                currentUser = event.data.user;
                localStorage.setItem('currentUser', JSON.stringify(currentUser));
                updateAuthUI();
                console.log('User updated from profile page:', currentUser);
            }
        });
        
        // Refresh user data periodically to ensure profile picture is up-to-date and session stays alive
        setInterval(async () => {
            if (isAuthenticated) {
                try {
                    const response = await fetch(`${API_BASE}/api/user/me`, {
                        credentials: 'include'
                    });
                    if (response.ok) {
                        const userData = await response.json();
                        // Update user data to keep session alive
                        currentUser = {
                            ...currentUser,
                            id: userData.id,
                            email: userData.email,
                            plan: userData.plan || 'free',
                            displayName: userData.displayName || null,
                            emailVerified: userData.emailVerified || false,
                            tokens: userData.remainingToken !== undefined ? userData.remainingToken : (userData.tokens || 0),
                            remainingToken: userData.remainingToken !== undefined ? userData.remainingToken : (userData.tokens || 0)
                        };
                        // Only update UI if profile picture changed
                        if (userData.profilePicture !== currentUser?.profile_picture && userData.profilePicture !== currentUser?.avatar) {
                            currentUser.avatar = userData.profilePicture || null;
                            currentUser.profile_picture = userData.profilePicture || null;
                            updateAuthUI();
                            console.log('User profile picture refreshed:', userData.profilePicture);
                        }
                        // Keep session alive by updating localStorage
                        localStorage.setItem('currentUser', JSON.stringify(currentUser));
                    } else if (response.status === 401) {
                        // Session expired - handle gracefully
                        console.log('Session expired, user logged out');
                        isAuthenticated = false;
                        currentUser = null;
                        localStorage.removeItem('currentUser');
                        localStorage.removeItem('isAuthenticated');
                        updateAuthUI();
                        // Update tokens badge to show "Start a session"
                        updateTokensBadge();
                    }
                } catch (error) {
                    // Silently fail - don't spam console
                }
            }
        }, 30000); // Check every 30 seconds

        // Update UI when returning from profile page
        window.addEventListener('focus', function () {
            const savedUser = JSON.parse(localStorage.getItem('currentUser') || 'null');
            if (savedUser && currentUser && (savedUser.avatar !== currentUser.avatar || savedUser.avatarEmoji !== currentUser.avatarEmoji || savedUser.name !== currentUser.name)) {
                currentUser = savedUser;
                updateAuthUI();
            }
        });
    </script>

    <!-- Auth Modal -->
    <div id="auth-modal" class="auth-modal">
        <div class="auth-modal-content">
            <div class="auth-modal-header">
                <h2>Welcome</h2>
                <button class="auth-modal-close" onclick="closeAuthModal()">&times;</button>
            </div>
            <div class="auth-tabs">
                <button class="auth-tab active" id="login-tab" onclick="switchAuthTab('login')"><strong>Sign
                        In</strong></button>
                <button class="auth-tab" id="register-tab" onclick="switchAuthTab('register')"><strong>Sign
                        Up</strong></button>
            </div>
            <div id="login-content" class="auth-content active">
                <form class="auth-form" id="login-form" onsubmit="handleLogin(event)">
                    <div class="auth-form-group">
                        <label for="login-email">Email</label>
                        <input type="email" id="login-email" required>
                    </div>
                    <div class="auth-form-group">
                        <label for="login-password">Password</label>
                        <input type="password" id="login-password" required>
                        <div style="text-align: right; margin-top: 0.5rem;">
                            <a href="#" id="forgot-password-link" style="color: var(--accent); text-decoration: none; font-size: 0.85rem; cursor: pointer;" onclick="handleForgotPassword(event); return false;">Forgot Your Password?</a>
                        </div>
                    </div>
                    <div class="auth-error" id="auth-error"></div>
                    <button type="submit" class="auth-submit-btn"><strong>Sign In</strong></button>
                </form>
                <div class="auth-divider">OR</div>
                <button class="auth-google-btn" onclick="handleGoogleSignIn()">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                            fill="#4285F4" />
                        <path
                            d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                            fill="#34A853" />
                        <path
                            d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
                            fill="#FBBC05" />
                        <path
                            d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                            fill="#EA4335" />
                    </svg>
                    <strong>Sign in with Google</strong>
                </button>
            </div>
            <div id="register-content" class="auth-content">
                <form class="auth-form" id="register-form" onsubmit="handleRegister(event)">
                    <div class="auth-form-group">
                        <label for="register-email">Email</label>
                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                            <input type="email" id="register-email" required style="flex: 1;">
                            <button type="button" id="send-code-btn" style="padding: 0.4rem 0.6rem; white-space: nowrap; background: var(--accent); color: var(--bg-primary); border: none; border-radius: 4px; font-size: 0.75rem; font-weight: 500; cursor: pointer; transition: all 0.2s; height: fit-content; line-height: 1;">Send Code</button>
                        </div>
                        <small id="code-status" style="color: var(--text-secondary); font-size: 0.85rem; margin-top: 0.25rem; display: block;"></small>
                    </div>
                    <div class="auth-form-group">
                        <label for="register-password">Password</label>
                        <input type="password" id="register-password" required
                            placeholder="Min 8 chars, 1 special or uppercase">
                        <div id="password-requirements" style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-secondary);"></div>
                    </div>
                    <div class="auth-form-group" style="position: relative;">
                        <label for="register-confirm-password">Confirm Password</label>
                        <input type="password" id="register-confirm-password" required>
                        <div class="verification-code-alert" id="password-mismatch-alert">
                            <div class="verification-code-alert-icon">
                                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                                </svg>
                            </div>
                            <div class="verification-code-alert-message" id="password-mismatch-alert-message"></div>
                            <button class="verification-code-alert-close" onclick="hidePasswordMismatchAlert()" aria-label="Close">
                                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="auth-form-group" style="position: relative;">
                        <label for="register-verification-code">Verification Code</label>
                        <input type="text" id="register-verification-code" required placeholder="Enter 6-digit code from email" maxlength="6" pattern="[0-9]{6}">
                        <div class="verification-code-alert" id="verification-code-alert">
                            <div class="verification-code-alert-icon">
                                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                                </svg>
                            </div>
                            <div class="verification-code-alert-message" id="verification-code-alert-message"></div>
                            <button class="verification-code-alert-close" onclick="hideVerificationCodeAlert()" aria-label="Close">
                                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="auth-error" id="auth-error"></div>
                    <button type="submit" class="auth-submit-btn"><strong>Sign Up</strong></button>
                </form>
                <div class="auth-divider">OR</div>
                <button class="auth-google-btn" onclick="handleGoogleSignIn()">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                            fill="#4285F4" />
                        <path
                            d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                            fill="#34A853" />
                        <path
                            d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
                            fill="#FBBC05" />
                        <path
                            d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                            fill="#EA4335" />
                    </svg>
                    <strong>Sign up with Google</strong>
                </button>
            </div>
        </div>
    </div>

    <!-- Token Limit Modal -->
    <div id="token-limit-modal" class="token-limit-modal">
        <div class="token-limit-modal-content">
            <div class="token-limit-modal-header">
                <h2>Oops! Token Limit Reached</h2>
                <button class="token-limit-modal-close" onclick="closeTokenLimitModal()">&times;</button>
            </div>
            <div class="token-limit-modal-body">
                <p>You've used all your free tokens! To continue chatting with our AI models, please upgrade to a paid plan.</p>
                <p>Our paid plans offer:</p>
                <ul style="color: var(--text-primary); margin: 1rem 0; padding-left: 1.5rem; line-height: 1.8;">
                    <li><span class="highlight">Lite Plan:</span> 50,000 tokens</li>
                    <li><span class="highlight">Pro Plan:</span> 200,000 tokens</li>
                    <li><span class="highlight">Ultra Plan:</span> 500,000 tokens</li>
                </ul>
                <div class="token-limit-modal-actions">
                    <a href="/pricing.html" class="token-limit-btn token-limit-btn-primary">View Pricing Plans</a>
                    <button class="token-limit-btn token-limit-btn-secondary" onclick="closeTokenLimitModal()">Maybe Later</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Install Instructions Modal -->
    <div id="install-instructions-modal" class="install-modal-overlay" onclick="closeInstallModal()">
        <div class="install-modal-content" onclick="event.stopPropagation()">
            <button class="install-modal-close" onclick="closeInstallModal()">&times;</button>
            <h2>Install App</h2>
            <div class="install-instructions">
                <div class="install-step">
                    <div class="install-step-icon">
                        <svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
                            <path d="M292.57,124.87v206.35c0,20.18-16.36,36.57-36.57,36.57c-20.18,0-36.57-16.39-36.57-36.57V124.87l-40.96,41.03
                                c-14.32,14.29-37.5,14.29-51.78,0c-14.29-14.32-14.29-37.5,0.04-51.78L230.14,10.73c14.21-14.25,37.28-14.32,51.57-0.14l0.14,0.14
                                l103.46,103.42c14.29,14.32,14.29,37.5,0,51.78c-14.32,14.29-37.5,14.29-51.78-0.04L292.57,124.87z M109.72,219.44
                                c20.21,0,36.57,16.39,36.57,36.57c0,20.21-16.36,36.57-36.57,36.57H73.15v146.28h365.7V292.58h-36.57
                                c-20.18,0-36.57-16.36-36.57-36.57c0-20.18,16.39-36.57,36.57-36.57h36.57c40.43,0,73.14,32.75,73.14,73.14v146.28
                                c0,40.39-32.71,73.14-73.14,73.14H73.15c-40.39,0-73.14-32.75-73.14-73.14V292.58c0-40.39,32.75-73.14,73.14-73.14H109.72z"/>
                        </svg>
                    </div>
                    <p><strong>iOS (Safari) & Chrome:</strong></p>
                    <ol>
                        <li>Tap the <span class="share-icon-inline">
                            <svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="20" height="20">
                                <path d="M292.57,124.87v206.35c0,20.18-16.36,36.57-36.57,36.57c-20.18,0-36.57-16.39-36.57-36.57V124.87l-40.96,41.03
                                    c-14.32,14.29-37.5,14.29-51.78,0c-14.29-14.32-14.29-37.5,0.04-51.78L230.14,10.73c14.21-14.25,37.28-14.32,51.57-0.14l0.14,0.14
                                    l103.46,103.42c14.29,14.32,14.29,37.5,0,51.78c-14.32,14.29-37.5,14.29-51.78-0.04L292.57,124.87z M109.72,219.44
                                    c20.21,0,36.57,16.39,36.57,36.57c0,20.21-16.36,36.57-36.57,36.57H73.15v146.28h365.7V292.58h-36.57
                                    c-20.18,0-36.57-16.36-36.57-36.57c0-20.18,16.39-36.57,36.57-36.57h36.57c40.43,0,73.14,32.75,73.14,73.14v146.28
                                    c0,40.39-32.71,73.14-73.14,73.14H73.15c-40.39,0-73.14-32.75-73.14-73.14V292.58c0-40.39,32.75-73.14,73.14-73.14H109.72z"/>
                            </svg>
                        </span> Share button</li>
                        <li>Select "Add to Home Screen"</li>
                        <li>Tap "Add"</li>
                    </ol>
                </div>
            </div>
            <button class="install-modal-close-btn" onclick="closeInstallModal()">Got it</button>
        </div>
    </div>

</body>

</html>