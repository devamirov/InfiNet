<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-content">
    <meta name="theme-color" content="#000000">
    <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <script>
        // Preload light mode as early as possible to keep bars white if saved
        (function () {
            try {
                const savedTheme = localStorage.getItem('theme');
                const themeMeta = document.querySelector('meta[name="theme-color"]');
                const appleMeta = document.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
                if (savedTheme === 'light') {
                    document.documentElement.classList.add('light-mode-preload');
                    document.documentElement.style.backgroundColor = '#ffffff';
                    document.documentElement.setAttribute('data-force-light', '1');
                    if (themeMeta) themeMeta.setAttribute('content', '#ffffff');
                    if (appleMeta) appleMeta.setAttribute('content', 'default');
                } else {
                    document.documentElement.removeAttribute('data-force-light');
                }
            } catch (e) { }
        })();
    </script>
    <script>
        // Update theme-color immediately based on localStorage
        (function() {
            try {
                const savedTheme = localStorage.getItem('theme');
                const themeColorMeta = document.querySelector('meta[name="theme-color"]');
                const appleStatusBarMeta = document.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
                
                if (savedTheme === 'light' && themeColorMeta && appleStatusBarMeta) {
                    themeColorMeta.setAttribute('content', '#ffffff');
                    appleStatusBarMeta.setAttribute('content', 'default');
                }
            } catch(e) {}
        })();
    </script>
    <title>Uncensored InfiNet AI - Free AI Chat with No Filters</title>
    <meta name="description" content="Experience unrestricted AI conversations with InfiNet AI. Free AI chat with no filters, no limitations. Chat with advanced AI models including Coder and Thinker. Start chatting now!">
    <meta name="keywords" content="AI chat, uncensored AI, free AI, AI assistant, chatbot, AI conversation, InfiNet AI, AI models, Coder AI, Thinker AI, unrestricted AI, AI platform">
    <meta name="author" content="InfiNet Services">
    <meta name="robots" content="index, follow">
    <meta name="googlebot" content="index, follow">
    <link rel="canonical" href="https://ai.infinet.services/">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://ai.infinet.services/">
    <meta property="og:title" content="Uncensored InfiNet AI - Free AI Chat with No Filters">
    <meta property="og:description" content="Experience unrestricted AI conversations with InfiNet AI. Free AI chat with no filters, no limitations. Chat with advanced AI models including Coder and Thinker.">
    <meta property="og:image" content="https://ai.infinet.services/ghost.JPG">
    <meta property="og:site_name" content="InfiNet AI">
    <meta property="og:locale" content="en_US">
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://ai.infinet.services/">
    <meta name="twitter:title" content="Uncensored InfiNet AI - Free AI Chat with No Filters">
    <meta name="twitter:description" content="Experience unrestricted AI conversations with InfiNet AI. Free AI chat with no filters, no limitations.">
    <meta name="twitter:image" content="https://ai.infinet.services/ghost.JPG">
    
    <!-- Favicon and Icons -->
    <link rel="icon" type="image/jpeg" href="/ghost.JPG">
    <link rel="shortcut icon" type="image/jpeg" href="/ghost.JPG">
    <link rel="apple-touch-icon" href="/ghost.JPG">
    <link rel="apple-touch-icon" sizes="180x180" href="/ghost.JPG">
    <link rel="icon" type="image/jpeg" sizes="32x32" href="/ghost.JPG">
    <link rel="icon" type="image/jpeg" sizes="16x16" href="/ghost.JPG">
    <link rel="icon" type="image/x-icon" href="/ghost.JPG">
    <link rel="manifest" href="/manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="InfiNet AI">
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- Structured Data for SEO -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Uncensored InfiNet AI",
        "url": "https://ai.infinet.services",
        "description": "Experience unrestricted AI conversations with InfiNet AI. Free AI chat with no filters, no limitations.",
        "applicationCategory": "ChatApplication",
        "operatingSystem": "Web",
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "featureList": [
            "Uncensored AI conversations",
            "Multiple AI models (Coder & Thinker)",
            "Free tier with 10,000 tokens",
            "No filters or limitations",
            "Real-time chat interface"
        ],
        "aggregateRating": {
            "@type": "AggregateRating",
            "ratingValue": "5",
            "ratingCount": "1"
        }
    }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #000000;
            --bg-secondary: #0a0a0a;
            --bg-tertiary: #1a1a1a;
            --accent: #e5ff3a;
            --accent-hover: #b8cc2e;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --text-muted: #888888;
            --border: #333333;
            --border-light: #222222;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            display: flex;
        }

        /* Keep the very top white on mobile in light mode (behind header/content) */
        .top-safe-area {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 200px;
            background: #ffffff;
            z-index: 0;
            pointer-events: none;
            display: none;
        }

        html {
            background-color: #000000;
        }

        /* Preload helper to keep background white before JS finishes */
        html.light-mode-preload {
            background-color: #ffffff !important;
        }

        html.light-mode-preload body,
        html[data-force-light] body {
            background-color: #ffffff !important;
            color: #000000 !important;
        }

        /* Force white tops for light mode (CSS-only, no JS dependency) */
        body.light-mode html,
        body.light-mode {
            background: #ffffff !important;
            color: #000000 !important;
        }

        body.light-mode .top-safe-area {
            display: block;
        }

        /* Header should be solid white in light mode (no translucency) */
        body.light-mode .chat-header {
            background: #ffffff !important;
            backdrop-filter: none !important;
            padding: 1rem 1.5rem !important;
            padding-top: 1rem !important;
            padding-bottom: 1rem !important;
        }

        body.light-mode html {
            background-color: #ffffff !important;
        }
        @media (max-width: 768px) {
            body {
                height: auto !important;
                min-height: 100dvh;
                overflow-y: auto !important;
                overflow-x: hidden;
                position: relative;
                display: block;
                background: var(--bg-primary);
            }
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background: #121212;
            border-right: none;
            display: flex;
            flex-direction: column;
            height: 100vh;
            transition: transform 0.3s ease;
            position: fixed;
            left: 0;
            top: 0;
            z-index: 100;
            transform: translateX(-100%);
        }

        .sidebar.sidebar-open {
            transform: translateX(0);
        }

        .sidebar.mobile-hidden {
            transform: translateX(-100%);
        }

        /* Hide expanded cards when sidebar is hidden */
        .sidebar.mobile-hidden .info-card-expanded {
            display: none !important;
            opacity: 0 !important;
            visibility: hidden !important;
        }

        /* Mobile Sidebar Overlay */
        .sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 99;
        }

        .sidebar-overlay.show {
            display: block;
        }

        /* Sidebar Bot Handle */
        .sidebar-handle {
            position: absolute;
            right: -45px;
            top: 80px;
            width: 60px;
            height: 80px;
            cursor: pointer;
            z-index: 101;
            transition: all 0.3s ease;
            filter: drop-shadow(0 4px 8px rgba(229, 255, 58, 0.4));
        }

        .sidebar-handle svg {
            width: 100%;
            height: 100%;
            transition: all 0.3s ease;
        }

        .sidebar-handle:hover {
            right: -50px;
            filter: drop-shadow(0 6px 15px rgba(229, 255, 58, 0.7));
            animation: botBounce 0.6s ease-in-out infinite;
        }

        .sidebar-handle:hover svg {
            transform: scale(1.1);
        }

        .sidebar-handle:hover .bot-head {
            animation: botPeek 0.8s ease-in-out infinite;
        }

        .sidebar-handle:hover .bot-hand-left {
            animation: handWave 0.5s ease-in-out infinite;
            transform-origin: top center;
        }

        .sidebar-handle:hover .bot-hand-right {
            animation: handWave 0.5s ease-in-out infinite 0.25s;
            transform-origin: top center;
        }

        .sidebar-handle:hover .bot-eye {
            animation: eyeBlink 2s ease-in-out infinite;
        }

        @keyframes botBounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-5px);
            }
        }

        @keyframes botPeek {

            0%,
            100% {
                transform: translateX(0);
            }

            50% {
                transform: translateX(3px);
            }
        }

        @keyframes handWave {

            0%,
            100% {
                transform: rotate(0deg);
            }

            50% {
                transform: rotate(15deg);
            }
        }

        @keyframes eyeBlink {

            0%,
            90%,
            100% {
                transform: scaleY(1);
            }

            95% {
                transform: scaleY(0.1);
            }
        }

        .sidebar.sidebar-open .sidebar-handle {
            right: -45px;
        }

        .sidebar-header {
            padding: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .sidebar-header img {
            width: 40px;
            height: 40px;
            border-radius: 8px;
        }

        .sidebar-header h1 {
            font-size: 1.25rem;
            color: var(--accent);
            font-weight: 700;
            margin: 0;
            line-height: 1.2;
        }

        .sidebar-actions {
            padding: 1rem;
        }

        .btn-new-chat {
            width: 100%;
            padding: 0.75rem;
            background: var(--accent);
            color: var(--bg-primary);
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.95rem;
        }

        .btn-new-chat:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
        }

        .sidebar-conversations {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .sidebar-info-cards {
            padding: 0.4rem 0.5rem;
            border-top: none;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .sidebar-info-cards .info-card {
            padding: 0.6rem 0.75rem;
            margin: 0;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 12px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            z-index: 1;
        }

        .sidebar-info-cards .info-card:hover,
        .sidebar-info-cards .info-card.expanded-active {
            z-index: 1001;
        }

        .sidebar-info-cards .info-card:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .sidebar-info-cards .info-card:active {
            transform: scale(0.98);
        }

        .sidebar-info-cards .info-card h4 {
            font-size: 0.85rem;
            margin-bottom: 0.3rem;
            color: var(--accent);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .sidebar-info-cards .info-card p {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin: 0;
        }

        .sidebar-info-cards .info-card .lock-icon {
            width: 14px;
            height: 14px;
            flex-shrink: 0;
            fill: currentColor;
        }

        .conversation-item {
            padding: 0.75rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 0.25rem;
            transition: all 0.2s;
            color: var(--text-secondary);
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            position: relative;
        }

        .conversation-item:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .conversation-item.active {
            background: var(--bg-tertiary);
            color: var(--accent);
        }

        .conversation-item-content {
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .conversation-delete-btn {
            opacity: 0;
            transition: opacity 0.2s;
            padding: 0.25rem;
            background: transparent;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            border-radius: 4px;
            flex-shrink: 0;
        }

        .conversation-item:hover .conversation-delete-btn {
            opacity: 1;
        }

        .conversation-delete-btn:hover {
            color: #ff4444;
            background: rgba(255, 68, 68, 0.1);
        }

        .conversation-delete-btn svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
        }

        .sidebar-footer {
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .sidebar-footer a {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.85rem;
            padding: 0.5rem;
            border-radius: 6px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .sidebar-footer a .sidebar-icon {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
            fill: currentColor;
        }

        .sidebar-footer a:hover {
            color: var(--accent);
            background: var(--bg-tertiary);
        }

        .sidebar-socials {
            padding: 0.75rem 1rem calc(3rem + 1cm);
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .sidebar-socials .sidebar-cta-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5mm;
        }

        .sidebar-socials .sidebar-cta {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.4rem;
            padding: 0.45rem 1.25rem;
            border-radius: 8px;
            border: 1px solid #e5ff3a;
            background: #e5ff3a;
            color: #000000;
            transition: all 0.2s;
            text-decoration: none;
            font-size: 0.8rem;
            font-weight: 600;
            line-height: 1;
            white-space: nowrap;
        }

        .sidebar-socials .sidebar-cta:hover {
            color: #000000;
            border-color: #b8cc2e;
            background: #b8cc2e;
        }

        .sidebar-socials .sidebar-cta svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
            flex-shrink: 0;
        }

        .sidebar-socials .sidebar-link-text {
            color: #e5ff3a;
            font-weight: bold;
            text-decoration: none;
            font-size: 0.85rem;
            transition: opacity 0.2s;
        }

        .sidebar-socials .sidebar-link-text:hover {
            opacity: 0.8;
        }

        /* Main Chat Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-primary);
            height: 100vh;
            overflow: hidden;
        }

        @media (max-width: 768px) {
            .main-content {
                height: auto !important;
                min-height: 100dvh;
                overflow: visible !important;
                overflow: visible !important;
                flex: none;
                display: block;
            }
        }

        .chat-header {
            padding: 1rem 1.5rem;
            border-bottom: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-primary);
            position: relative;
            z-index: 10;
        }

        @media (max-width: 768px) {
            .chat-header {
                position: sticky;
                top: 0;
                z-index: 900;
                background: rgba(0, 0, 0, 0.8);
                backdrop-filter: blur(10px);
                border-bottom: 1px solid var(--border);
            }

            body.light-mode .chat-header {
                background: #ffffff !important;
                backdrop-filter: none !important;
            }
        }

        .chat-header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        /* Model Toggle Switch */
        .model-toggle-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .model-toggle-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 500;
            white-space: nowrap;
        }

        .model-toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
            background: var(--border);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            flex-shrink: 0;
        }

        .model-toggle-switch.active {
            background: var(--accent);
        }

        .model-toggle-switch::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffffff;
            top: 3px;
            left: 3px;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .model-toggle-switch.active::after {
            left: 23px;
        }

        body.light-mode .model-toggle-switch.active {
            background: var(--accent);
        }

        body.light-mode .model-toggle-switch::after {
            background: #ffffff;
        }

        .chat-header-right {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }

        .header-btn {
            padding: 0.5rem 1rem;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .header-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .header-btn.primary {
            background: var(--accent);
            color: var(--bg-primary);
            border-color: var(--accent);
        }

        .header-btn.primary:hover {
            background: var(--accent-hover);
        }

        .header-btn.primary[style*="border-radius: 50%"]:hover {
            opacity: 0.9;
            transform: scale(1.05);
        }

        .header-btn.primary[style*="border-radius: 50%"] {
            transition: all 0.2s;
        }

        .tokens-badge {
            padding: 0.5rem 1rem;
            background: rgba(229, 255, 58, 0.1);
            border: 1px solid var(--accent);
            border-radius: 8px;
            color: var(--accent);
            font-size: 0.85rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transform: translateX(-3mm);
        }

        .tokens-badge svg {
            width: 16px;
            height: 16px;
            fill: var(--accent);
        }

        .theme-toggle {
            padding: 0.5rem;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-secondary);
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .theme-toggle:hover {
            border-color: var(--accent);
            color: var(--accent);
            background: var(--bg-tertiary);
        }

        .theme-toggle svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        /* Light Mode Styles */
        body.light-mode {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --bg-tertiary: #e8e8e8;
            --text-primary: #000000;
            --text-secondary: #333333;
            --text-muted: #666666;
            --border: #d0d0d0;
            --border-light: #e0e0e0;
            --accent: #000000;
            --accent-hover: #333333;
        }

        body.light-mode .sidebar {
            background: #f8f8f8;
        }

        body.light-mode .chat-header {
            background: #ffffff !important;
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
            z-index: 10 !important;
            position: relative !important;
            padding: 1rem 1.5rem !important;
            padding-top: 1rem !important;
            padding-bottom: 1rem !important;
            min-height: auto !important;
            height: auto !important;
        }
        
        /* Override for mobile - ensure mobile light mode header matches dark mode */
        @media (max-width: 768px) {
            body.light-mode .chat-header {
                padding: 0.75rem 1rem !important;
                padding-top: calc(0.75rem + env(safe-area-inset-top)) !important;
                padding-bottom: 0.75rem !important;
                padding-left: 1rem !important;
                padding-right: 1rem !important;
                min-height: auto !important;
                height: auto !important;
                position: fixed !important;
            }
        }
        
        body.light-mode .main-content {
            background: #ffffff !important;
        }
        
        body.light-mode body {
            background: #ffffff !important;
        }

        body.light-mode .chat-footer {
            background: #ffffff;
            padding: 2rem 1.5rem !important;
            padding-top: 2rem !important;
            padding-bottom: 2rem !important;
            min-height: auto !important;
            height: auto !important;
        }

        body.light-mode .chat-input-area {
            background: transparent;
        }


        body.light-mode .message-content {
            background: var(--bg-secondary);
        }

        body.light-mode .chat-input {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        body.light-mode h1,
        body.light-mode h2,
        body.light-mode h3,
        body.light-mode .sidebar-header h1,
        body.light-mode .welcome-screen h2,
        body.light-mode .tokens-badge,
        body.light-mode .message-avatar,
        body.light-mode a {
            color: var(--accent) !important;
        }
        
        body.light-mode .welcome-screen {
            margin-top: -1cm !important;
            padding-top: 2rem !important;
        }
        
        body.light-mode .chat-messages {
            padding-top: 2rem !important;
        }

        body.light-mode .tokens-badge {
            border-color: var(--accent);
            background: rgba(0, 0, 0, 0.05);
        }

        body.light-mode .btn-new-chat,
        body.light-mode .send-btn,
        body.light-mode .header-btn.primary {
            background: var(--accent) !important;
            color: #ffffff !important;
        }

        /* Don't override background when profile picture is present */
        body.light-mode .header-btn.primary.has-profile-picture,
        body.light-mode .header-btn.primary[style*="background-image"] {
            background-color: transparent !important;
            background: transparent !important;
        }

        body.light-mode .btn-new-chat:hover,
        body.light-mode .send-btn:hover:not(:disabled),
        body.light-mode .header-btn.primary:hover {
            background: var(--accent-hover) !important;
        }

        /* Preserve profile picture on hover - don't change background */
        body.light-mode .header-btn.primary.has-profile-picture:hover,
        body.light-mode .header-btn.primary[style*="background-image"]:hover {
            background-color: transparent !important;
            background: transparent !important;
            opacity: 0.9;
        }

        body.light-mode .message.user .message-content {
            background: rgba(0, 0, 0, 0.05);
            border-color: var(--accent);
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 2rem;
            padding-top: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            min-height: 0;
        }

        @media (max-width: 768px) {
            .chat-messages {
                flex: none;
                overflow: visible;
                height: auto;
                padding-bottom: 120px;
                /* Space for fixed input */
            }
        }

        .message {
            display: flex;
            gap: 1rem;
            max-width: 85%;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .message-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            font-weight: bold;
            color: var(--accent);
            border: 1px solid var(--border);
        }

        .message.user .message-avatar {
            background: var(--accent);
            color: var(--bg-primary);
            border-color: var(--accent);
        }

        .message-content {
            background: var(--bg-tertiary);
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            border: 1px solid var(--border);
            line-height: 1.6;
            color: var(--text-primary);
            position: relative;
            max-width: 100%;
            word-wrap: break-word;
            overflow-wrap: break-word;
            overflow-x: hidden;
        }
        
        .message-content * {
            max-width: 100%;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        /* Code block container (ChatGPT style) */
        .code-block-container {
            margin: 1rem 0;
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            position: relative;
        }
        
        .code-block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0.75rem;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .code-block-language {
            font-weight: 500;
            text-transform: uppercase;
        }
        
        .code-block-copy-btn {
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            transition: all 0.2s ease;
        }
        
        .code-block-copy-btn:hover {
            background: var(--bg-tertiary);
            color: var(--accent);
            border-color: var(--accent);
        }
        
        .code-block-copy-btn svg {
            width: 14px;
            height: 14px;
        }
        
        .code-block-content {
            padding: 1rem;
            overflow-x: auto;
            background: var(--bg-secondary);
            max-width: 100%;
        }
        
        .code-block-content pre {
            margin: 0;
            padding: 0;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            color: var(--text-primary);
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
        }
        
        .code-block-content code {
            font-family: 'Courier New', Courier, monospace;
            background: transparent;
            padding: 0;
            border-radius: 0;
        }
        
        
        /* Light mode code blocks */
        body.light-mode .code-block-container {
            background: #f5f5f5;
            border-color: #e0e0e0;
        }
        
        body.light-mode .code-block-header {
            background: #e8e8e8;
            border-bottom-color: #d0d0d0;
        }
        
        body.light-mode .code-block-content {
            background: #fafafa;
        }

        .message.user .message-content {
            background: rgba(229, 255, 58, 0.1);
            border-color: var(--accent);
            padding: 0.25rem 0.75rem;
        }

        .message-copy-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.4rem 0.6rem;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            z-index: 10;
        }

        .message-content:hover .message-copy-btn {
            opacity: 1;
        }

        .message-copy-btn:hover {
            background: var(--bg-tertiary);
            color: var(--accent);
            border-color: var(--accent);
        }

        .message-copy-btn svg {
            width: 16px;
            height: 16px;
        }


        .message-content p {
            margin: 0;
            color: var(--text-primary);
        }
        
        /* Inline code styling (backticks) */
        .message-content .inline-code,
        .inline-code {
            background: rgba(229, 255, 58, 0.2);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
            color: var(--text-primary);
        }
        

        .chat-input-area {
            padding: 1.5rem;
            background: transparent;
            position: relative;
            border-top: none;
            flex-shrink: 0;
        }

        @media (max-width: 768px) {
            .chat-input-area {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                z-index: 1000;
                padding-bottom: max(1.5rem, env(safe-area-inset-bottom));
                border-top: none;
            }
        }

        .chat-input-area::before {
            display: none;
        }

        .chat-input-area::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: calc(1.5rem + 28px);
            background: var(--bg-primary);
            z-index: 0;
        }

        .input-container {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
            background: #121212;
            border-radius: 24px;
            padding: 0.5rem 0.75rem;
            border: 2px solid var(--border);
            position: relative;
            transform: translateY(0);
            z-index: 2;
        }
        
        /* Force desktop styles to override mobile !important styles */
        @media (min-width: 769px) {
            .main-content {
                height: 100vh !important;
                overflow: hidden !important;
            }
            
            .chat-header {
                padding: 1rem 1.5rem !important;
                padding-top: 1rem !important;
                padding-bottom: 1rem !important;
                min-height: auto !important;
                height: auto !important;
            }
            
            .chat-footer {
                position: relative !important;
                bottom: auto !important;
                top: auto !important;
                left: auto !important;
                right: auto !important;
                width: auto !important;
                transform: none !important;
                display: flex !important;
                margin: 0 auto !important;
                padding: 2rem 1.5rem !important;
                padding-top: 2rem !important;
                padding-bottom: 2rem !important;
                padding-left: 1.5rem !important;
                padding-right: 1.5rem !important;
                visibility: visible !important;
                opacity: 1 !important;
                min-height: auto !important;
                height: auto !important;
            }
            
            .chat-input-area {
                position: relative !important;
                bottom: auto !important;
                top: auto !important;
                left: auto !important;
                right: auto !important;
                width: auto !important;
                z-index: auto !important;
                transform: none !important;
                visibility: visible !important;
                opacity: 1 !important;
                flex-shrink: 0 !important;
            }
            
            .input-container {
                position: relative !important;
                transform: translateY(0) !important;
                margin-bottom: 0 !important;
                margin-top: 0 !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            .footer-center {
                display: flex !important;
                visibility: visible !important;
                opacity: 1 !important;
                min-height: auto !important;
                height: auto !important;
                flex-shrink: 0 !important;
            }
            
            .chat-messages {
                padding-bottom: 2rem !important;
                padding-top: 2rem !important;
            }
            
            .welcome-screen {
                margin-top: 0 !important;
                padding-top: 2rem !important;
            }
            
            .chat-header {
                position: relative !important;
                z-index: 10 !important;
            }
            
            /* Desktop light mode welcome screen - move down 10mm total */
            body.light-mode .welcome-screen {
                margin-top: calc(-1cm + 10mm) !important;
            }
        }

        body.light-mode .input-container {
            background: #f8f8f8;
            border-color: var(--border);
        }

        .input-left-controls {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            flex-shrink: 0;
        }

        .input-right-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-shrink: 0;
        }

        .chat-input-wrapper {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
        }

        .chat-input {
            flex: 1;
            padding: 0.875rem 1rem 0.875rem 3rem;
            background: #000000;
            border: none;
            border-radius: 24px;
            color: var(--text-primary);
            font-size: 0.95rem;
            font-family: inherit;
            resize: none;
            min-height: 44px;
            max-height: 200px;
            transition: all 0.2s;
            line-height: 1.5;
            width: 100%;
        }

        .chat-input:focus {
            outline: none;
        }

        .input-ghost-icon {
            position: absolute;
            left: 0.75rem;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            object-fit: cover;
            pointer-events: none;
        }

        .chat-input-area {
            padding: 1rem 1.5rem;
            background: transparent;
            position: relative;
        }


        .chat-input::placeholder {
            color: var(--text-muted);
        }

        /* Image to Image Button */
        .img-to-img-btn {
            padding: 0;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 50%;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .img-to-img-btn svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        .img-to-img-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
            background: var(--bg-tertiary);
        }

        /* Send Button - Circular */
        .send-btn {
            padding: 0;
            background: var(--accent);
            color: var(--bg-primary);
            border: none;
            border-radius: 50%;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .send-btn svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        .send-btn:hover:not(:disabled) {
            background: var(--accent-hover);
            transform: scale(1.05);
        }

        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        body.light-mode .send-btn {
            background: var(--accent) !important;
            color: #ffffff !important;
        }

        body.light-mode .send-btn:hover:not(:disabled) {
            background: var(--accent-hover) !important;
        }

        /* Info Cards */
        .info-cards {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            max-width: 1200px;
            margin: 1rem auto 0;
            padding: 0 1.5rem;
        }

        /* Download Buttons */
        .download-buttons {
            display: flex;
            justify-content: center;
            gap: 0.25rem;
            max-width: 1200px;
            margin: calc(-3.5rem - 3mm) auto 0;
            padding: 0 1.5rem;
        }

        .download-btn {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.3rem 0.6rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 0.7rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .download-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
            background: var(--bg-secondary);
            transform: translateY(-1px);
        }

        .download-btn .download-icon {
            width: 14px;
            height: 14px;
            fill: currentColor;
            flex-shrink: 0;
        }

        @media (max-width: 768px) {
            .download-buttons {
                gap: 0.25rem;
                padding: 0 1rem;
                margin: calc(-3.5rem - 3mm) auto 0;
            }

            .download-btn {
                padding: 0.25rem 0.5rem;
                font-size: 0.65rem;
            }

            .download-btn .download-icon {
                width: 12px;
                height: 12px;
            }
        }


        /* Footer */
        .chat-footer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem 1.5rem;
            padding-top: 2rem;
            padding-bottom: 2rem;
            position: relative;
            background: #000000;
            min-height: auto;
            height: auto;
            flex-shrink: 0;
        }

        .footer-link {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            color: var(--text-secondary);
            transition: all 0.2s;
            border-radius: 50%;
            border: 1px solid var(--border);
            background: transparent;
            text-decoration: none;
        }

        .footer-link:hover {
            color: var(--accent);
            border-color: var(--accent);
            background: var(--bg-tertiary);
            transform: scale(1.05);
        }

        .footer-link svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .footer-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
            min-height: auto;
            height: auto;
            flex-shrink: 0;
        }

        .footer-text {
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .footer-copyright {
            color: var(--text-muted);
            font-size: 0.75rem;
            margin: 0;
            margin-top: 0.5rem;
        }

        .footer-logo {
            width: 42px;
            height: 42px;
            border-radius: 6px;
            object-fit: cover;
            vertical-align: middle;
            margin-left: -1mm;
        }

        @media (max-width: 768px) {
            .chat-footer {
                padding: 1.5rem 1rem;
            }

            .footer-link {
                width: 36px;
                height: 36px;
            }

            .footer-link svg {
                width: 18px;
                height: 18px;
            }

            .footer-logo {
                width: 38px;
                height: 38px;
            }

            .footer-text {
                font-size: 0.75rem;
            }

            .footer-copyright {
                font-size: 0.7rem;
            }
        }

        .info-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.25rem;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            z-index: 1;
        }

        .info-card:hover,
        .info-card.expanded-active {
            z-index: 1001;
        }

        .info-card:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .info-card:active {
            transform: scale(0.98);
        }

        @media (max-width: 768px) {
            .info-card {
                padding: 1rem;
            }
        }

        .info-card h4 {
            color: var(--accent);
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .info-card h4 .lock-icon {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
            fill: currentColor;
        }

        .info-card p {
            color: var(--text-secondary);
            font-size: 0.8rem;
            line-height: 1.5;
            margin: 0;
        }

        body.light-mode .info-card h4 {
            color: var(--accent);
        }

        body.light-mode .info-card {
            background: var(--bg-secondary);
        }

        /* Expanded Card Overlay */
        .info-card-expanded {
            display: none;
            position: absolute;
            top: 0;
            left: calc(100% + 0.5rem);
            background: var(--bg-tertiary);
            border: 1px solid var(--accent);
            border-radius: 8px;
            padding: 0.625rem;
            z-index: 1002;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            width: 200px;
            max-width: calc(100vw - 2rem);
        }

        .sidebar-info-cards .info-card-expanded {
            left: calc(100% + 0.5rem);
        }

        @media (max-width: 768px) {
            .info-card-expanded {
                position: absolute;
                top: 0;
                left: 50%;
                transform: translateX(-50%);
                width: 180px;
                max-width: calc(100vw - 2rem);
                max-height: 60vh;
                overflow-y: auto;
                padding: 0.625rem;
                border-radius: 8px;
            }

            .info-card-expanded-header {
                gap: 0.35rem;
                margin-bottom: 0.35rem;
            }

            .info-card-expanded-header svg {
                width: 12px;
                height: 12px;
            }

            .info-card-expanded-header h5 {
                font-size: 0.75rem;
            }

            .info-card-expanded p {
                font-size: 0.65rem;
                line-height: 1.3;
            }

            .info-cards {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.5rem;
                padding: 0 0.75rem;
            }

            .info-card {
                padding: 0.75rem;
            }

            .info-card h4 {
                font-size: 0.8rem;
                margin-bottom: 0.25rem;
            }

            .info-card h4 .lock-icon {
                width: 14px;
                height: 14px;
            }

            .info-card p {
                font-size: 0.7rem;
            }
        }

        .info-card-expanded.show {
            display: block;
            animation: slideDown 0.2s ease;
            z-index: 1003;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @media (max-width: 768px) {
            .info-card-expanded.show {
                animation: fadeIn 0.2s ease;
            }
        }

        .info-card-expanded-header {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-bottom: 0.4rem;
        }

        .info-card-expanded-header svg {
            width: 14px;
            height: 14px;
            fill: var(--accent);
            flex-shrink: 0;
        }

        .info-card-expanded-header h5 {
            color: var(--accent);
            font-size: 0.8rem;
            font-weight: 600;
            margin: 0;
        }

        .info-card-expanded p {
            color: var(--text-secondary);
            font-size: 0.7rem;
            line-height: 1.4;
            margin: 0;
        }

        body.light-mode .info-card-expanded {
            background: var(--bg-secondary);
            border-color: var(--accent);
        }

        body.light-mode .info-card-expanded-header svg {
            fill: var(--accent);
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        body.light-mode ::-webkit-scrollbar-thumb {
            background: var(--accent);
        }

        body.light-mode ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-hover);
        }

        /* Welcome Message */
        .welcome-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            padding: 2rem;
            margin-top: -1cm;
            padding-top: 2rem;
        }

        .welcome-screen h2 {
            font-size: 2rem;
            color: var(--accent);
            margin-bottom: 1rem;
        }

        .welcome-screen p {
            color: var(--text-secondary);
            font-size: 1.1rem;
            max-width: 600px;
        }

        .welcome-screen.hidden {
            display: none;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                width: 280px;
                box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
                z-index: 200;
                transform: translateX(-100%);
            }

            .sidebar.sidebar-open {
                transform: translateX(0);
            }

            .sidebar.mobile-hidden {
                transform: translateX(-100%);
            }

            /* Hide expanded cards when sidebar is hidden on mobile */
            .sidebar.mobile-hidden .info-card-expanded {
                display: none !important;
                opacity: 0 !important;
                visibility: hidden !important;
            }

            .main-content {
                width: 100%;
            }

            .message {
                max-width: 95%;
            }

            /* Header Mobile Styles */
            .chat-header {
                padding: 0.75rem 1rem;
                padding-top: calc(0.75rem + env(safe-area-inset-top));
                padding-bottom: 0.75rem;
                flex-wrap: wrap;
                gap: 0.5rem;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                width: 100%;
                z-index: 150;
                background: var(--bg-primary);
                border-bottom: none;
                min-height: auto;
                height: auto;
            }
            
            body.light-mode .chat-header {
                padding: 0.75rem 1rem !important;
                padding-top: calc(0.75rem + env(safe-area-inset-top)) !important;
                padding-bottom: 0.75rem !important;
                padding-left: 1rem !important;
                padding-right: 1rem !important;
                min-height: auto !important;
                height: auto !important;
                background: #ffffff !important;
            }

            /* Add padding to main content to account for fixed header */
            .main-content {
                padding-top: 70px;
            }

            /* Welcome screen should be centered properly */
            .welcome-screen {
                height: calc(100vh - 70px - 120px);
                min-height: auto;
                padding: 2rem 1rem;
                margin-top: -5mm;
            }

            /* Adjust light mode welcome screen to match dark mode positioning on mobile */
            body.light-mode .welcome-screen {
                padding-top: 1.5rem !important;
                margin-top: -1cm !important;
            }

            .chat-header-left {
                flex: 1;
                min-width: 0;
            }

            .chat-header-right {
                gap: 0.5rem;
                flex-wrap: wrap;
                justify-content: flex-end;
            }

            .tokens-badge {
                padding: 0.4rem 0.6rem;
                font-size: 0.7rem;
                gap: 0.3rem;
            }

            .tokens-badge svg {
                width: 14px;
                height: 14px;
            }

            .theme-toggle {
                width: 36px;
                height: 36px;
                padding: 0.4rem;
            }

            .theme-toggle svg {
                width: 18px;
                height: 18px;
            }

            .header-btn {
                padding: 0.4rem 0.7rem;
                font-size: 0.75rem;
                white-space: nowrap;
            }

            /* Input Container Mobile Styles */
            .chat-input-area {
                padding: 1rem;
                padding-bottom: calc(1rem + env(safe-area-inset-bottom));
                position: fixed !important;
                bottom: 0 !important;
                left: 0;
                right: 0;
                width: 100%;
                background: transparent;
                z-index: 50;
            }

            /* Add padding to chat messages to account for fixed input area */
            .chat-messages {
                padding-bottom: 120px;
            }

            .chat-input-area::before {
                top: calc(1rem + 0.5rem + 20px);
            }

            .chat-input-area::after {
                height: calc(1rem + 0.5rem + 20px);
            }

            .input-container {
                padding: 0.5rem;
                transform: translateY(0);
                transition: transform 0.3s ease-out;
                gap: 0.4rem;
                position: relative;
                z-index: 2;
                margin-bottom: 80px;
                /* Space for footer */
            }

            /* Pure CSS keyboard handling */
            .input-container:focus-within {
                margin-bottom: 0 !important;
            }

            .input-container:focus-within~.chat-footer {
                display: none !important;
            }

            /* Hide footer-center (domain section) when keyboard appears */
            .input-container:focus-within~.chat-footer .footer-center,
            .input-container.keyboard-visible~.chat-footer .footer-center {
                display: none !important;
            }

            .chat-footer .footer-center {
                display: flex;
            }

            /* Prevent body scroll when input is focused */
            @media (max-width: 768px) {

                html:has(.chat-input:focus),
                body:has(.chat-input:focus) {
                    overflow: hidden !important;
                    height: 100% !important;
                    position: fixed !important;
                    width: 100% !important;
                }

                /* Force input to bottom and cover any gaps */
                body:has(.chat-input:focus) .chat-input-area {
                    bottom: 0 !important;
                    padding-bottom: 1rem !important;
                    /* Remove safe-area padding to sit flush */
                }
            }

            .input-left-controls {
                gap: 0.4rem;
            }

            .img-to-img-btn {
                width: 32px;
                height: 32px;
            }

            .img-to-img-btn svg {
                width: 16px;
                height: 16px;
            }

            .model-toggle-container {
                gap: 0.25rem;
            }

            .model-toggle-label {
                font-size: 0.7rem;
            }

            .model-toggle-switch {
                width: 38px;
                height: 20px;
            }

            .model-toggle-switch::after {
                width: 16px;
                height: 16px;
                top: 2px;
                left: 2px;
            }

            .model-toggle-switch.active::after {
                left: 20px;
            }

            .chat-input {
                padding: 0.75rem 0.85rem 0.75rem 2.5rem;
                font-size: 0.9rem;
                min-height: 40px;
            }

            /* Prevent page scroll on input focus */
            .chat-input:focus {
                scroll-margin-top: 0;
            }

            /* Browser UI hiding - window must scroll, not internal elements */
            html {
                height: auto;
                min-height: 100%;
                overflow-y: scroll;
                -webkit-overflow-scrolling: touch;
            }

            body {
                height: auto;
                min-height: 100vh;
                min-height: calc(100vh + 200px);
                /* Body must be taller than viewport */
                overflow-y: scroll;
                -webkit-overflow-scrolling: touch;
                position: relative;
                width: 100%;
            }

            .main-content {
                min-height: 100vh;
                overflow: visible;
                position: relative;
                display: flex;
                flex-direction: column;
            }

            /* Add spacer at bottom to ensure window scrolling */
            body::after {
                content: '';
                display: block;
                height: 200px;
                width: 100%;
            }

            .chat-messages {
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                padding: 1rem;
                padding-top: 0.5rem;
            }

            /* Ensure input area stays at bottom */
            .chat-input-area {
                flex-shrink: 0;
            }

            /* Prevent iOS Safari from zooming on input focus */
            .chat-input {
                font-size: 16px !important;
            }

            /* Prevent page scroll when input is focused */
            .chat-input:focus {
                scroll-margin-top: 0;
            }

            /* Footer on mobile - keep fixed at bottom */
            .chat-footer {
                display: flex;
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                width: 100%;
                padding: 1.5rem 1rem;
                background: #000000;
                z-index: 1;
                transform: translateY(0);
                pointer-events: none;
            }

            .chat-footer * {
                pointer-events: auto;
            }

            /* Ensure sidebar overlay is above input area */
            .sidebar-overlay {
                z-index: 199;
            }


            .input-ghost-icon {
                left: 0.6rem;
                width: 20px;
                height: 20px;
            }

            .send-btn {
                width: 32px;
                height: 32px;
            }

            .send-btn svg {
                width: 16px;
                height: 16px;
            }
        }

        /* Extra Small Mobile Screens */
        @media (max-width: 480px) {
            .chat-header {
                padding: 0.6rem 0.75rem;
            }
            
            body.light-mode .chat-header {
                padding: 0.6rem 0.75rem !important;
                padding-top: calc(0.6rem + env(safe-area-inset-top)) !important;
                padding-bottom: 0.6rem !important;
                padding-left: 0.75rem !important;
                padding-right: 0.75rem !important;
            }

            .chat-header-right {
                gap: 0.4rem;
            }

            .tokens-badge {
                padding: 0.35rem 0.5rem;
                font-size: 0.65rem;
            }

            .tokens-badge svg {
                width: 12px;
                height: 12px;
            }

            .header-btn {
                padding: 0.35rem 0.6rem;
                font-size: 0.7rem;
            }

            .theme-toggle {
                width: 32px;
                height: 32px;
                padding: 0.35rem;
            }

            .theme-toggle svg {
                width: 16px;
                height: 16px;
            }

            .chat-input-area {
                padding: 0.75rem;
            }

            .input-container {
                padding: 0.4rem;
            }

            .chat-input {
                padding: 0.7rem 0.75rem 0.7rem 2.25rem;
                font-size: 0.85rem;
            }

            .input-ghost-icon {
                left: 0.5rem;
                width: 18px;
                height: 18px;
            }

            .model-toggle-label {
                font-size: 0.65rem;
            }
        }

        /* Auth Modal */
        .auth-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .auth-modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            width: 100%;
            max-width: 450px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .auth-modal-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .auth-modal-header h2 {
            color: var(--accent);
            font-size: 1.5rem;
            margin: 0;
        }

        .auth-modal-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .auth-modal-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .auth-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
        }

        .auth-tab {
            flex: 1;
            padding: 1rem;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
        }

        .auth-tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }

        .auth-tab:hover {
            color: var(--text-primary);
        }

        .auth-content {
            display: none;
            padding: 1.5rem;
        }

        .auth-content.active {
            display: block;
        }

        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .auth-form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .auth-form-group label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            font-weight: 500;
        }

        .auth-form-group input {
            padding: 0.75rem;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.95rem;
            font-family: inherit;
        }

        .auth-form-group input:focus {
            outline: none;
            border-color: var(--accent);
        }

        #register-verification-code::placeholder {
            color: #4caf50;
            opacity: 0.8;
        }

        #register-password::placeholder {
            color: #ff4444;
            opacity: 0.8;
        }

        .auth-error {
            color: #ff4444;
            font-size: 0.85rem;
            margin-top: 0.5rem;
            min-height: 1.2rem;
        }

        .auth-submit-btn {
            padding: 0.75rem;
            background: var(--accent);
            color: var(--bg-primary);
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 0.5rem;
        }

        .auth-submit-btn:hover {
            background: var(--accent-hover);
        }

        .auth-divider {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin: 1.5rem 0;
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .auth-divider::before,
        .auth-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--border);
        }

        .auth-google-btn {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-weight: 500;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .auth-google-btn:hover {
            border-color: var(--accent);
            background: var(--bg-tertiary);
        }

        .auth-google-btn svg {
            width: 20px;
            height: 20px;
        }

        body.light-mode .auth-modal-content {
            background: var(--bg-secondary);
            border-color: var(--border);
        }

        body.light-mode .auth-form-group input {
            background: var(--bg-primary);
            border-color: var(--border);
        }

        body.light-mode .auth-google-btn {
            background: var(--bg-primary);
            border-color: var(--border);
        }

        /* Token Limit Modal */
        .token-limit-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1001;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .token-limit-modal.show {
            display: flex;
        }

        .token-limit-modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            width: 100%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .token-limit-modal-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .token-limit-modal-header h2 {
            color: var(--accent);
            font-size: 1.5rem;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .token-limit-modal-header h2::before {
            content: "";
            font-size: 1.8rem;
        }

        .token-limit-modal-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .token-limit-modal-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .token-limit-modal-body {
            padding: 1.5rem;
        }

        .token-limit-modal-body p {
            color: var(--text-primary);
            font-size: 1rem;
            line-height: 1.6;
            margin: 0 0 1.5rem 0;
        }

        .token-limit-modal-body .highlight {
            color: var(--accent);
            font-weight: 600;
        }

        .token-limit-modal-actions {
            display: flex;
            gap: 1rem;
            flex-direction: column;
        }

        .token-limit-btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            text-align: center;
            text-decoration: none;
            display: inline-block;
        }

        .token-limit-btn-primary {
            background: var(--accent);
            color: #000;
        }

        .token-limit-btn-primary:hover {
            background: #d4e500;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(229, 255, 58, 0.4);
        }

        .token-limit-btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .token-limit-btn-secondary:hover {
            background: var(--bg-primary);
        }

        body.light-mode .token-limit-modal-content {
            background: var(--bg-secondary);
            border-color: var(--border);
        }

        body.light-mode .token-limit-btn-primary {
            background: #000000 !important;
            color: #ffffff !important;
        }

        body.light-mode .token-limit-btn-primary:hover {
            background: #1a1a1a !important;
            color: #ffffff !important;
        }

        body.light-mode .token-limit-btn-primary:visited {
            color: #ffffff !important;
        }

        body.light-mode .token-limit-btn-primary:link {
            color: #ffffff !important;
        }
    </style>
</head>

<body>
    <!-- Sidebar Overlay -->
    <!-- White backdrop to keep top area white on mobile light mode -->
    <div class="top-safe-area"></div>

    <div class="sidebar-overlay" id="sidebar-overlay" onclick="closeSidebar()"></div>

    <!-- Left Sidebar -->
    <aside class="sidebar" id="sidebar">
        <!-- Sidebar Handle -->
        <div class="sidebar-handle" onclick="toggleSidebar()" title="Open sidebar">
            <svg viewBox="0 0 60 80" xmlns="http://www.w3.org/2000/svg">
                <!-- Bot Antennas -->
                <g class="bot-antennas">
                    <line x1="22" y1="8" x2="22" y2="12" stroke="#e5ff3a" stroke-width="2" stroke-linecap="round" />
                    <circle cx="22" cy="8" r="2" fill="#e5ff3a" />
                    <line x1="38" y1="8" x2="38" y2="12" stroke="#e5ff3a" stroke-width="2" stroke-linecap="round" />
                    <circle cx="38" cy="8" r="2" fill="#e5ff3a" />
                </g>
                <!-- Bot Head (square, peeking from sidebar) -->
                <g class="bot-head">
                    <rect x="12" y="12" width="36" height="36" rx="3" fill="#e5ff3a" stroke="#121212"
                        stroke-width="2" />
                    <circle cx="24" cy="24" r="3" fill="#121212" class="bot-eye" />
                    <circle cx="36" cy="24" r="3" fill="#121212" class="bot-eye" />
                    <rect x="26" y="32" width="8" height="2" rx="1" fill="#121212" />
                </g>
                <!-- Bot Body (behind sidebar) -->
                <rect x="15" y="48" width="30" height="25" rx="5" fill="#e5ff3a" stroke="#121212" stroke-width="2" />
                <rect x="20" y="53" width="20" height="15" rx="2" fill="#121212" opacity="0.3" />
                <!-- Right Hand (hanging on edge) -->
                <g class="bot-hand-right">
                    <rect x="52" y="58" width="8" height="20" rx="4" fill="#e5ff3a" stroke="#121212" stroke-width="2" />
                    <circle cx="56" cy="60" r="2" fill="#121212" />
                </g>
            </svg>
        </div>
        <div class="sidebar-header">
            <img src="ghost.JPG" alt="Logo" onerror="this.style.display='none'">
            <h1>Uncensored InfiNet AI</h1>
        </div>

        <div class="sidebar-actions">
            <button class="btn-new-chat" onclick="newChat()">+ New Chat</button>
        </div>

        <div class="sidebar-conversations" id="conversations">
            <!-- Conversations will be added here -->
        </div>

        <!-- Info Cards in Sidebar -->
        <div class="sidebar-info-cards">
            <div class="info-card" onmouseenter="showExpandedCard('privacy')" onmouseleave="hideExpandedCard('privacy')"
                ontouchstart="toggleExpandedCard('privacy')" onclick="toggleExpandedCard('privacy')">
                <h4>
                    <svg class="lock-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"
                            fill="currentColor" />
                    </svg>
                    100% Private
                </h4>
                <p>Chats & images deleted automatically</p>
                <div class="info-card-expanded" id="privacy-expanded">
                    <div class="info-card-expanded-header">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path
                                d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"
                                fill="currentColor" />
                        </svg>
                        <h5>100% Private</h5>
                    </div>
                    <p>All your conversations and generated images are automatically and permanently deleted after 24
                        hours. We don't store your data - your privacy is our top priority.</p>
                </div>
            </div>
        </div>

        <div class="sidebar-footer">
             <a href="/profile" id="sidebar-profile-link" onclick="handleProfileLinkClick(event)">
                <svg class="sidebar-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path
                        d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"
                        fill="currentColor" />
                </svg>
                <span id="sidebar-profile-text">Profile</span>
            </a>
            <a href="/pricing">
                <svg class="sidebar-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path
                        d="M11.8 10.9c-2.27-.59-3-1.2-3-2.15 0-1.09 1.01-1.85 2.7-1.85 1.78 0 2.44.85 2.5 2.1h2.21c-.07-1.72-1.12-3.3-3.21-3.81V3h-3v2.16c-1.94.42-3.5 1.68-3.5 3.61 0 2.31 1.91 3.46 4.7 4.13 2.5.6 3 1.48 3 2.41 0 .69-.49 1.79-2.7 1.79-2.06 0-2.87-.92-2.98-2.1h-2.2c.12 2.19 1.76 3.42 3.68 3.83V21h3v-2.15c1.95-.37 3.5-1.5 3.5-3.55 0-2.84-2.43-3.81-4.7-4.4z"
                        fill="currentColor" />
                </svg>
                Pricing
            </a>
            <a href="/features">
                <svg class="sidebar-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"
                        fill="currentColor" />
                </svg>
                Features
            </a>
            <a href="/doc">
                <svg class="sidebar-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path
                        d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z"
                        fill="currentColor" />
                </svg>
                Documentation
            </a>
        </div>

        <div class="sidebar-socials">
            <div class="sidebar-cta-wrapper">
                <a class="sidebar-cta" href="#" id="sidebar-apk-btn" title="APK (Coming Soon)">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M17.523 15.3414c-.5511 0-.9993-.4486-.9993-.9997s.4482-.9993.9993-.9993c.5506 0 .9993.4486.9993.9993.0001.5511-.4486.9997-.9993.9997m-11.046 0c-.5511 0-.9993-.4486-.9993-.9997s.4486-.9993.9993-.9993c.5506 0 .9993.4486.9993.9993 0 .5511-.4486.9997-.9993.9997m11.4045-6.02l1.9973-3.4592a.416.416 0 00-.1521-.5676.416.416 0 00-.5676.1521l-2.0223 3.503C15.5902 8.2439 13.8533 7.8508 12 7.8508s-3.5902.3931-5.1349 1.0989L4.8429 5.4467a.4161.4161 0 00-.5676-.1521.4157.4157 0 00-.1521.5676l1.9973 3.4592C2.6889 11.186.8533 13.2177.8533 15.7404v.9225c0 .2768.2232.5.5.5h22.2934c.2768 0 .5-.2232.5-.5v-.9225c0-2.5227-1.8356-4.5536-4.2668-5.419"
                            fill="currentColor" />
                    </svg>
                    APK
                </a>
                <a href="/privacy" class="sidebar-link-text">Policy</a>
            </div>
            <div class="sidebar-cta-wrapper">
                <a class="sidebar-cta" href="#" id="sidebar-web-btn" onclick="handleWebAppInstall(event)" title="Add to Home Screen">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-5 14H4v-4h11v4zm0-5H4V9h11v4zm5 5h-4V9h4v9z"
                            fill="currentColor" />
                    </svg>
                    Web
                </a>
                <a href="/terms" class="sidebar-link-text">Terms</a>
            </div>
        </div>
    </aside>

    <!-- Main Chat Area -->
    <main class="main-content">
        <div class="chat-header">
            <div class="chat-header-left">
                <select class="model-selector" id="model-select" style="display: none;">
                    <option value="model1">Coder</option>
                    <option value="model2">Thinker</option>
                </select>
            </div>
            <div class="chat-header-right">
                <div class="tokens-badge" id="tokens-badge">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M20 6H17.82C17.93 5.69 18 5.35 18 5C18 3.34 16.66 2 15 2C13.95 2 13.04 2.54 12.5 3.35L12 4.02L11.5 3.34C10.96 2.54 10.05 2 9 2C7.34 2 6 3.34 6 5C6 5.35 6.07 5.69 6.18 6H4C2.89 6 2.01 6.89 2.01 8L2 19C2 20.11 2.89 21 4 21H20C21.11 21 22 20.11 22 19V8C22 6.89 21.11 6 20 6ZM15 4C15.55 4 16 4.45 16 5C16 5.55 15.55 6 15 6C14.45 6 14 5.55 14 5C14 4.45 14.45 4 15 4ZM9 4C9.55 4 10 4.45 10 5C10 5.55 9.55 6 9 6C8.45 6 8 5.55 8 5C8 4.45 8.45 4 9 4ZM20 19H4V17H20V19ZM20 15H4V8H20V15Z"
                            fill="currentColor" />
                    </svg>
                    <span id="tokens-badge-text">Free 10000 Tokens</span>
                </div>
                <button class="theme-toggle" id="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
                    <svg id="theme-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M21.64 13a1 1 0 0 0-1.05-.14 8.05 8.05 0 0 1-3.37.73 8.15 8.15 0 0 1-8.14-8.1 8.59 8.59 0 0 1 .25-2A1 1 0 0 0 8 2.36 10.14 10.14 0 1 0 22 14.05 1 1 0 0 0 21.64 13Z"
                            fill="currentColor" />
                    </svg>
                </button>
                <button class="header-btn" onclick="showPricing()">Pricing</button>
                <button class="header-btn primary" onclick="showRegister()"><strong>Hop In</strong></button>
            </div>
        </div>

        <div class="chat-messages" id="chat-messages">
            <div class="welcome-screen" id="welcome-screen">
                <h2>Welcome to Uncensored InfiNet AI</h2>
                <p>Experience unrestricted AI conversations with no filters or limitations. Start a conversation to
                    begin.</p>
            </div>
        </div>
        <div class="chat-input-area">
            <div class="input-container">
                <div class="input-left-controls">
                    <button class="img-to-img-btn" id="img-to-img-btn" onclick="openImageToImage()"
                        title="Image to Image">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path
                                d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"
                                fill="currentColor" />
                        </svg>
                    </button>
                    <div class="model-toggle-container">
                        <div class="model-toggle-switch" id="model-toggle" onclick="toggleModel()"></div>
                        <span class="model-toggle-label" id="model-label">Coder</span>
                    </div>
                </div>
                <div class="chat-input-wrapper">
                    <img src="ghost.JPG" alt="Ghost" class="input-ghost-icon" onerror="this.style.display='none'">
                    <textarea class="chat-input" id="message-input" placeholder="Ask me anything..." rows="1"
                        enterkeyhint="send" onkeydown="handleKeyDown(event)" oninput="autoResize(this)"></textarea>
                </div>
                <div class="input-right-controls">
                    <button class="send-btn" id="send-btn" onclick="sendMessage()" title="Send">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4l-8 8h5v8h6v-8h5l-8-8z" fill="currentColor" />
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Footer -->
            <footer class="chat-footer">
                <a href="https://infinet.services/" target="_blank" class="footer-link footer-link-left"
                    title="Visit InfiNet Services">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM18.92 8h-2.95c-.32-1.25-.78-2.45-1.38-3.56 1.84.63 3.37 1.91 4.33 3.56zM12 4.04c.83 1.2 1.48 2.53 1.91 3.96h-3.82c.43-1.43 1.08-2.76 1.91-3.96zM4.26 14C4.1 13.36 4 12.69 4 12s.1-1.36.26-2h3.38c-.08.66-.14 1.32-.14 2 0 .68.06 1.34.14 2H4.26zm.82 2h2.95c.32 1.25.78 2.45 1.38 3.56-1.84-.63-3.37-1.9-4.33-3.56zm2.95-8H4.26c.96-1.66 2.49-2.93 4.33-3.56C8.03 5.55 7.57 6.75 7.25 8zM12 19.96c-.83-1.2-1.48-2.53-1.91-3.96h3.82c-.43 1.43-1.08 2.76-1.91 3.96zM14.34 14H9.66c-.09-.66-.16-1.32-.16-2 0-.68.07-1.34.16-2h4.68c.09.66.16 1.32.16 2 0 .68-.07 1.34-.16 2zm.25 5.56c.6-1.11 1.06-2.31 1.38-3.56h2.95c-.96 1.65-2.49 2.93-4.33 3.56zM16.36 14c.08-.66.14-1.32.14-2 0-.68-.06-1.34-.14-2h3.38c.16.64.26 1.31.26 2s-.1 1.36-.26 2h-3.38z"
                            fill="currentColor" />
                    </svg>
                </a>
                <div class="footer-center">
                    <p class="footer-text">Powered by <img src="logo.PNG" alt="InfiNet Logo" class="footer-logo"
                            onerror="this.style.display='none'"></p>
                    <p class="footer-copyright"> 2025 InfiNet AI. All rights reserved.</p>
                </div>
                <a href="mailto:admin@infinet.services" class="footer-link footer-link-right" title="Contact Us">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"
                            fill="currentColor" />
                    </svg>
                </a>
            </footer>

            <input type="file" id="image-upload" accept="image/*" style="display: none;"
                onchange="handleImageUpload(event)">
            <input type="file" id="img-to-img-upload" accept="image/*" style="display: none;"
                onchange="handleImageToImageUpload(event)">
        </div>
    </main>

    <script>
        let currentConversation = null;
        let conversations = [];
        let currentUser = null;
        
        // API Base URL
        const API_BASE = window.location.origin;
        
        // Check authentication and load user
        async function checkAuth() {
            try {
                const response = await fetch(`${API_BASE}/api/user/me`, {
                    credentials: 'include'
                });
                
                if (response.ok) {
                    const userData = await response.json();
                    // Map API response to frontend format
                    currentUser = {
                        id: userData.id,
                        email: userData.email,
                        name: userData.displayName || userData.email.split('@')[0],
                        displayName: userData.displayName || null, // Keep null if not set
                        avatar: userData.profilePicture || null, // Map profilePicture to avatar (API returns profilePicture, not profile_picture)
                        profile_picture: userData.profilePicture || null,
                        plan: userData.plan || 'free',
                        emailVerified: userData.emailVerified || false,
                        googleId: userData.googleId || null
                    };
                    isAuthenticated = true; // Set global flag
                    console.log('User authenticated:', currentUser);
                    console.log('Profile picture:', currentUser.profile_picture);
                    console.log('Display name:', currentUser.displayName);
                    return true;
                } else {
                    // Not authenticated - redirect to login or allow guest mode
                    isAuthenticated = false; // Set global flag
                    currentUser = null;
                    console.log('User not authenticated');
                    return false;
                }
            } catch (error) {
                console.error('Auth check error:', error);
                isAuthenticated = false; // Set global flag
                currentUser = null;
                return false;
            }
        }

        // Update tokens badge in header
        async function updateTokensBadge() {
            const badge = document.getElementById('tokens-badge');
            const badgeText = document.getElementById('tokens-badge-text');
            if (!badge || !badgeText) return;

            try {
                let response;
                if (isAuthenticated && currentUser) {
                    response = await fetch(`${API_BASE}/api/user/tokens`, {
                        credentials: 'include'
                    });
                } else {
                    response = await fetch(`${API_BASE}/api/tokens/ip`, {
                        credentials: 'include'
                    });
                }

                if (response.ok) {
                    const data = await response.json();
                    const tokensRemaining = data.tokens || 0;
                    const plan = data.plan || 'free';
                    // Show "Free" prefix only for free plan
                    if (plan === 'free') {
                        badgeText.textContent = `Free ${tokensRemaining.toLocaleString()} Tokens`;
                    } else {
                        badgeText.textContent = `${tokensRemaining.toLocaleString()} Tokens`;
                    }
                } else {
                    badgeText.textContent = 'Free 10000 Tokens';
                }
            } catch (error) {
                console.error('Error updating tokens badge:', error);
                badgeText.textContent = 'Free 10000 Tokens';
            }
        }
        
        // Load conversations from API
        async function loadConversationsFromAPI() {
            try {
                const response = await fetch(`${API_BASE}/api/conversations`, {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    if (response.status === 401) {
                        // Not authenticated - use localStorage as fallback
                        console.log('Not authenticated, using localStorage fallback');
                        conversations = JSON.parse(localStorage.getItem('conversations') || '[]');
                        updateConversationsList();
                        return;
                    }
                    throw new Error('Failed to load conversations');
                }
                
                const data = await response.json();
                conversations = data.conversations.map(conv => ({
                    id: conv.id,
                    title: conv.title,
                    model: conv.model,
                    createdAt: conv.createdAt,
                    updatedAt: conv.updatedAt,
                    messages: [] // Will be loaded separately when needed
                }));
                
                updateConversationsList();
            } catch (error) {
                console.error('Error loading conversations:', error);
                // Fallback to localStorage
                conversations = JSON.parse(localStorage.getItem('conversations') || '[]');
                updateConversationsList();
            }
        }
        
        // Load a conversation with all messages from API
        async function loadConversationFromAPI(conversationId) {
            try {
                console.log('[loadConversationFromAPI] Fetching conversation:', conversationId);
                const response = await fetch(`${API_BASE}/api/conversations/${conversationId}`, {
                    credentials: 'include'
                });
                
                if (!response.ok) {
                    console.error('[loadConversationFromAPI] Response not OK:', response.status, response.statusText);
                    throw new Error('Failed to load conversation');
                }
                
                const conversation = await response.json();
                console.log('[loadConversationFromAPI] Received conversation:', {
                    id: conversation.id,
                    title: conversation.title,
                    messageCount: conversation.messages?.length || 0
                });
                return conversation;
            } catch (error) {
                console.error('[loadConversationFromAPI] Error loading conversation:', error);
                return null;
            }
        }
        
        // Create a new conversation via API
        async function createConversationAPI(model = 'model1') {
            try {
                const response = await fetch(`${API_BASE}/api/conversations`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        title: 'New Chat',
                        model: model
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to create conversation');
                }
                
                const data = await response.json();
                return data.conversation;
            } catch (error) {
                console.error('Error creating conversation:', error);
                // Fallback: create local conversation
                return {
                    id: 'local_' + Date.now(),
                    title: 'New Chat',
                    model: model,
                    messages: []
                };
            }
        }
        
        // Add a message to conversation via API
        async function addMessageToConversationAPI(conversationId, role, content) {
            try {
                const response = await fetch(`${API_BASE}/api/conversations/${conversationId}/messages`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        role: role,
                        content: content
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to add message');
                }
                
                const data = await response.json();
                return data.message;
            } catch (error) {
                console.error('Error adding message:', error);
                return null;
            }
        }
        
        // Update sidebar profile link based on auth status
        function updateSidebarProfileLink() {
            const profileLink = document.getElementById('sidebar-profile-link');
            const profileText = document.getElementById('sidebar-profile-text');
            
            if (!profileLink || !profileText) return;
            
            if (isAuthenticated && currentUser) {
                profileLink.href = '/profile';
                profileText.textContent = 'Profile';
            } else {
                profileLink.href = '/#auth';
                profileText.textContent = 'Hop In';
            }
        }
        
        // Advanced Device Fingerprinting - Multi-factor identification
        // Uses multiple browser APIs to create a persistent device fingerprint
        // that survives IP changes, cookie clearing, and browser restarts
        async function generateAdvancedFingerprint() {
            const components = [];
            
            // 1. Canvas Fingerprinting (rendering differences)
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 200;
                canvas.height = 50;
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.textBaseline = 'alphabetic';
                ctx.fillStyle = '#f60';
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = '#069';
                ctx.fillText('InfiNetAI-FP', 2, 15);
                ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
                ctx.fillText('InfiNetAI-FP', 4, 17);
                components.push('canvas:' + canvas.toDataURL().substring(0, 100));
            } catch (e) {
                components.push('canvas:error');
            }
            
            // 2. WebGL Fingerprinting
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl) {
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    if (debugInfo) {
                        components.push('webgl_vendor:' + gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL));
                        components.push('webgl_renderer:' + gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL));
                    }
                    components.push('webgl_version:' + gl.getParameter(gl.VERSION));
                    components.push('webgl_shading:' + gl.getParameter(gl.SHADING_LANGUAGE_VERSION));
                }
            } catch (e) {
                components.push('webgl:error');
            }
            
            // 3. Audio Context Fingerprinting
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const analyser = audioContext.createAnalyser();
                const gainNode = audioContext.createGain();
                const scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);
                
                gainNode.gain.value = 0;
                oscillator.connect(analyser);
                analyser.connect(scriptProcessor);
                scriptProcessor.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.start(0);
                scriptProcessor.onaudioprocess = (event) => {
                    const output = event.inputBuffer.getChannelData(0);
                    const hash = Array.from(output.slice(0, 100)).reduce((acc, val) => acc + Math.abs(val), 0);
                    components.push('audio:' + hash.toFixed(2));
                    audioContext.close();
                };
                // Timeout fallback
                setTimeout(() => {
                    if (!components.some(c => c.startsWith('audio:'))) {
                        components.push('audio:timeout');
                    }
                }, 100);
            } catch (e) {
                components.push('audio:error');
            }
            
            // 4. Screen Properties
            components.push('screen:' + screen.width + 'x' + screen.height + 'x' + screen.colorDepth);
            components.push('avail:' + screen.availWidth + 'x' + screen.availHeight);
            components.push('pixelRatio:' + (window.devicePixelRatio || 1));
            
            // 5. Timezone & Language
            components.push('timezone:' + Intl.DateTimeFormat().resolvedOptions().timeZone);
            components.push('language:' + navigator.language);
            components.push('languages:' + (navigator.languages ? navigator.languages.join(',') : navigator.language));
            
            // 6. Hardware Info
            if (navigator.hardwareConcurrency) {
                components.push('cpu:' + navigator.hardwareConcurrency);
            }
            if (navigator.deviceMemory) {
                components.push('memory:' + navigator.deviceMemory);
            }
            if (navigator.maxTouchPoints) {
                components.push('touch:' + navigator.maxTouchPoints);
            }
            
            // 7. Platform Info
            components.push('platform:' + navigator.platform);
            components.push('userAgent:' + navigator.userAgent.substring(0, 50));
            
            // 8. Installed Fonts (via canvas)
            const testFonts = ['Arial', 'Verdana', 'Times New Roman', 'Courier New', 'Georgia', 'Palatino', 'Garamond', 'Bookman', 'Comic Sans MS', 'Trebuchet MS', 'Impact'];
            const fontString = testFonts.map(font => {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const baseline = ctx.measureText('abcdefghijklmnopqrstuvwxyz0123456789').width;
                    ctx.font = `72px ${font}, monospace`;
                    const width = ctx.measureText('abcdefghijklmnopqrstuvwxyz0123456789').width;
                    return width !== baseline ? '1' : '0';
                } catch (e) {
                    return '0';
                }
            }).join('');
            components.push('fonts:' + fontString);
            
            // 9. Browser Plugins
            if (navigator.plugins && navigator.plugins.length > 0) {
                const plugins = Array.from(navigator.plugins).map(p => p.name).join(',');
                components.push('plugins:' + plugins.substring(0, 100));
            }
            
            // 10. WebGL Parameters (additional)
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl');
                if (gl) {
                    components.push('gl_vendor:' + gl.getParameter(gl.VENDOR));
                    components.push('gl_renderer:' + gl.getParameter(gl.RENDERER));
                }
            } catch (e) {}
            
            // Hash all components together
            const fingerprintString = components.join('|');
            const encoder = new TextEncoder();
            const data = encoder.encode(fingerprintString);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const fingerprint = hashArray.map(b => b.toString(16).padStart(2, '0')).join('').substring(0, 64);
            
            return fingerprint;
        }
        
        // Device Fingerprint Management - Multi-layer persistence with advanced fingerprinting
        async function getOrCreateDeviceFingerprint() {
            const STORAGE_KEY = 'device_fingerprint';
            const ADVANCED_FP_KEY = 'advanced_device_fingerprint';
            
            // 1. Try localStorage (simple fingerprint)
            let fingerprint = localStorage.getItem(STORAGE_KEY);
            
            // 2. Try IndexedDB
            if (!fingerprint) {
                try {
                    const db = await new Promise((resolve, reject) => {
                        const request = indexedDB.open('InfiNetAI', 1);
                        request.onerror = () => reject(request.error);
                        request.onsuccess = () => resolve(request.result);
                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains('fingerprints')) {
                                db.createObjectStore('fingerprints');
                            }
                        };
                    });
                    
                    const transaction = db.transaction(['fingerprints'], 'readonly');
                    const store = transaction.objectStore('fingerprints');
                    const request = store.get(STORAGE_KEY);
                    
                    fingerprint = await new Promise((resolve, reject) => {
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                } catch (err) {
                    console.log('[Device Fingerprint] IndexedDB not available:', err);
                }
            }
            
            // 3. Try advanced fingerprint (more persistent)
            if (!fingerprint) {
                try {
                    fingerprint = localStorage.getItem(ADVANCED_FP_KEY);
                    if (!fingerprint) {
                        const db = await new Promise((resolve, reject) => {
                            const request = indexedDB.open('InfiNetAI', 1);
                            request.onerror = () => reject(request.error);
                            request.onsuccess = () => resolve(request.result);
                            request.onupgradeneeded = (event) => {
                                const db = event.target.result;
                                if (!db.objectStoreNames.contains('fingerprints')) {
                                    db.createObjectStore('fingerprints');
                                }
                            };
                        });
                        
                        const transaction = db.transaction(['fingerprints'], 'readonly');
                        const store = transaction.objectStore('fingerprints');
                        const request = store.get(ADVANCED_FP_KEY);
                        
                        fingerprint = await new Promise((resolve, reject) => {
                            request.onsuccess = () => resolve(request.result);
                            request.onerror = () => reject(request.error);
                        });
                    }
                } catch (err) {
                    console.log('[Device Fingerprint] Advanced fingerprint read failed:', err);
                }
            }
            
            // 4. Generate new advanced fingerprint if none found
            if (!fingerprint) {
                console.log('[Device Fingerprint] Generating new advanced fingerprint...');
                fingerprint = await generateAdvancedFingerprint();
                
                // Store in all available locations
                try {
                    localStorage.setItem(STORAGE_KEY, fingerprint);
                    localStorage.setItem(ADVANCED_FP_KEY, fingerprint);
                } catch (e) {
                    console.log('[Device Fingerprint] localStorage not available');
                }
                
                try {
                    const db = await new Promise((resolve, reject) => {
                        const request = indexedDB.open('InfiNetAI', 1);
                        request.onerror = () => reject(request.error);
                        request.onsuccess = () => resolve(request.result);
                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains('fingerprints')) {
                                db.createObjectStore('fingerprints');
                            }
                        };
                    });
                    
                    const transaction = db.transaction(['fingerprints'], 'readwrite');
                    const store = transaction.objectStore('fingerprints');
                    store.put(fingerprint, STORAGE_KEY);
                    store.put(fingerprint, ADVANCED_FP_KEY);
                } catch (err) {
                    console.log('[Device Fingerprint] IndexedDB write failed:', err);
                }
            }
            
            return fingerprint;
        }
        
        // Send device fingerprint in headers for all fetch requests
        const originalFetch = window.fetch;
        window.fetch = async function(...args) {
            const fingerprint = await getOrCreateDeviceFingerprint();
            
            // Add fingerprint to headers if it's a Request object or URL string
            if (args[0] instanceof Request) {
                args[0].headers.set('x-device-fingerprint', fingerprint);
            } else if (typeof args[0] === 'string') {
                if (!args[1]) args[1] = {};
                if (!args[1].headers) args[1].headers = {};
                args[1].headers['x-device-fingerprint'] = fingerprint;
            }
            
            return originalFetch.apply(this, args);
        };
        
        // Handle profile link click
        function handleProfileLinkClick(event) {
            if (!isAuthenticated || !currentUser) {
                event.preventDefault();
                // If we're already on index page, just open the modal
                if (window.location.pathname === '/' || window.location.pathname === '/index.html') {
                    document.getElementById('auth-modal').style.display = 'flex';
                } else {
                    // Redirect to index with auth hash
                    window.location.href = '/#auth';
                }
            }
            // If authenticated, let the default link behavior work
        }

        // Web App Install Handler
        let deferredPrompt = null;

        function handleWebAppInstall(event) {
            event.preventDefault();
            
            // Check if already installed
            if (window.matchMedia('(display-mode: standalone)').matches || 
                window.navigator.standalone === true) {
                alert('This app is already installed on your device!');
                return;
            }

            // Check if browser supports install prompt
            if (deferredPrompt) {
                // Show the install prompt
                deferredPrompt.prompt();
                
                // Wait for the user to respond to the prompt
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('User accepted the install prompt');
                    } else {
                        console.log('User dismissed the install prompt');
                    }
                    deferredPrompt = null;
                });
            } else {
                // Fallback for browsers that don't support beforeinstallprompt
                // Show instructions based on device
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                const isAndroid = /Android/.test(navigator.userAgent);
                
                if (isIOS) {
                    alert('To install this app:\n1. Tap the Share button\n2. Select "Add to Home Screen"\n3. Tap "Add"');
                } else if (isAndroid) {
                    alert('To install this app:\n1. Tap the menu (3 dots) in your browser\n2. Select "Add to Home Screen" or "Install App"\n3. Tap "Add" or "Install"');
                } else {
                    alert('To install this app:\n1. Look for the install icon in your browser\'s address bar\n2. Click it and follow the prompts\n\nOr use your browser\'s menu to find "Install" or "Add to Home Screen"');
                }
            }
        }

        // Listen for the beforeinstallprompt event
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent the mini-infobar from appearing on mobile
            e.preventDefault();
            // Stash the event so it can be triggered later
            deferredPrompt = e;
            
            // Update button text/title to indicate install is available
            const webBtn = document.getElementById('sidebar-web-btn');
            if (webBtn) {
                webBtn.title = 'Add to Home Screen';
            }
        });

        // Listen for app installed event
        window.addEventListener('appinstalled', () => {
            console.log('PWA was installed');
            deferredPrompt = null;
            
            // Update button to show it's installed
            const webBtn = document.getElementById('sidebar-web-btn');
            if (webBtn) {
                webBtn.title = 'App Installed';
            }
        });
        
        // Initialize: Check auth and load conversations
        (async function init() {
            // Check for OAuth redirect parameters
            const urlParams = new URLSearchParams(window.location.search);
            const authStatus = urlParams.get('auth');
            const error = urlParams.get('error');
            
            // Check for #auth hash to open auth modal
            if (window.location.hash === '#auth') {
                // Wait a bit for page to load, then open modal
                setTimeout(() => {
                    document.getElementById('auth-modal').style.display = 'flex';
                    // Remove hash from URL without reload
                    window.history.replaceState(null, null, window.location.pathname + window.location.search);
                }, 100);
            }
            
            if (error === 'oauth_not_configured') {
                alert('Google OAuth is not configured. Please set up Google OAuth credentials.');
            } else if (error === 'auth_failed') {
                alert('Authentication failed. Please try again.');
            } else if (error === 'oauth_error') {
                const message = urlParams.get('message') || 'OAuth error occurred';
                alert('OAuth Error: ' + decodeURIComponent(message));
            } else if (authStatus === 'success') {
                console.log('OAuth authentication successful');
                // Reload auth state after OAuth success
                const authResult = await checkAuth();
                if (authResult) {
                    // checkAuth() already sets isAuthenticated and currentUser
                    await loadConversationsFromAPI();
                    updateAuthUI();
                    updateSidebarProfileLink();
                    // Close auth modal if open
                    const authModal = document.getElementById('authModal');
                    if (authModal) {
                        authModal.style.display = 'none';
                    }
                } else {
                    console.error('Failed to authenticate after OAuth success');
                }
            }
            
            // Clean up URL parameters
            if (authStatus || error) {
                window.history.replaceState({}, document.title, window.location.pathname);
            }
            
            // Only check auth if not already handled by OAuth success
            if (authStatus !== 'success') {
                const isAuthenticated = await checkAuth();
                if (isAuthenticated) {
                    await loadConversationsFromAPI();
                    updateConversationsList();
                    updateAuthUI();
                } else {
                    // Not authenticated - clear conversations and use localStorage
                    conversations = [];
                    const savedConversations = JSON.parse(localStorage.getItem('conversations') || '[]');
                    conversations = savedConversations;
                    updateConversationsList();
                }
                updateSidebarProfileLink();
            } else {
                // Guest mode - use localStorage
                conversations = JSON.parse(localStorage.getItem('conversations') || '[]');
                updateConversationsList();
                updateSidebarProfileLink();
            }
            
            // Update tokens badge (for both authenticated and non-authenticated users)
            await updateTokensBadge();
        })();

        // CRITICAL: Initialize sidebar IMMEDIATELY when script loads
        // This must happen before any conversation loading to prevent state issues
        (function initializeSidebarImmediate() {
            function resetSidebar() {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('sidebar-overlay');

                if (sidebar && overlay) {
                    // Force reset all sidebar states first - always hidden by default
                    sidebar.classList.remove('sidebar-open');
                    sidebar.classList.add('mobile-hidden');
                    overlay.classList.remove('show');
                }
            }

            // Try immediately
            resetSidebar();

            // Also try when DOM is ready (if not already ready)
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', resetSidebar);
            }

            // And on next frame to ensure everything is painted
            requestAnimationFrame(function () {
                setTimeout(resetSidebar, 0);
            });
        })();

        // Load selected conversation if coming from other pages
        // This runs after init() completes
        (async function() {
            // Wait a bit for init() to complete and conversations to load
            await new Promise(resolve => setTimeout(resolve, 500));
            
            const selectedConvId = localStorage.getItem('selectedConversationId');
            if (selectedConvId) {
                // Convert to number if it's a numeric string (from API)
                const convIdNum = isNaN(selectedConvId) ? selectedConvId : parseInt(selectedConvId, 10);
                
                // If authenticated, reload conversations from API first
                if (currentUser) {
                    await loadConversationsFromAPI();
                    updateConversationsList();
                } else {
                    // Not authenticated - reload from localStorage
                    const savedConversations = JSON.parse(localStorage.getItem('conversations') || '[]');
                    if (savedConversations.length > 0) {
                        conversations = savedConversations;
                        updateConversationsList();
                    }
                }

                // Find the conversation by ID (check both string and number)
                const selectedConv = conversations.find(c => c.id == convIdNum || c.id == selectedConvId);
                if (selectedConv || (currentUser && typeof convIdNum === 'number')) {
                    // Load the conversation using ID
                    // Use setTimeout to ensure DOM is fully ready
                    setTimeout(async function () {
                        await loadConversation(convIdNum);
                        localStorage.removeItem('selectedConversationId');
                    }, 200);
                } else {
                    console.error('Selected conversation not found:', selectedConvId);
                    localStorage.removeItem('selectedConversationId');
                }
            }
        })();

        async function newChat() {
            // Create a new conversation via API (if authenticated) or locally
            const model = currentModel || 'model2';
            
            if (currentUser) {
                // Authenticated - create via API
                try {
                    const newConv = await createConversationAPI(model);
            currentConversation = {
                        id: newConv.id,
                        title: newConv.title,
                messages: [],
                        model: newConv.model
                    };
                } catch (error) {
                    console.error('Error creating conversation via API:', error);
                    // Fallback to local
                    currentConversation = {
                        id: 'local_' + Date.now(),
                        messages: [],
                        model: model
                    };
                }
            } else {
                // Guest mode - create local conversation
                currentConversation = {
                    id: 'local_' + Date.now(),
                    messages: [],
                    model: model
                };
            }

            // Clear the chat UI
            clearChat();

            // Focus the input field so user can start typing immediately
            const input = document.getElementById('message-input');
            if (input) {
                setTimeout(() => {
                    input.focus();
                }, 100);
            }

            // Close sidebar on mobile after creating new chat
            if (window.innerWidth <= 768) {
                closeSidebar();
            }
        }

        async function deleteConversation(convId) {
            // Delete from API if authenticated and conversation ID is numeric
            if (currentUser && typeof convId === 'number') {
                try {
                    const response = await fetch(`${API_BASE}/api/conversations/${convId}`, {
                        method: 'DELETE',
                        credentials: 'include'
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to delete conversation');
                    }
                } catch (error) {
                    console.error('Error deleting conversation:', error);
                    alert('Failed to delete conversation. Please try again.');
                    return;
                }
            }
            
            // Remove from local array
            conversations = conversations.filter(conv => conv.id !== convId);
            if (currentConversation && currentConversation.id === convId) {
                currentConversation = null;
                clearChat();
            }
            
            // Update localStorage if guest mode
            if (!currentUser) {
            localStorage.setItem('conversations', JSON.stringify(conversations));
            }
            
            // Reload conversations from API if authenticated
            if (currentUser) {
                await loadConversationsFromAPI();
            } else {
            updateConversationsList();
            }
        }

        function updateConversationsList() {
            const container = document.getElementById('conversations');
            if (!container) return; // Exit if container doesn't exist (not on index page)

            container.innerHTML = '';

            // If authenticated, conversations are already loaded from API
            // If guest mode, use localStorage
            if (!currentUser) {
            const savedConversations = JSON.parse(localStorage.getItem('conversations') || '[]');
            if (savedConversations.length > 0) {
                conversations = savedConversations;

                // If we have a currentConversation, update it with the latest from localStorage
                if (currentConversation) {
                    const updatedConv = conversations.find(c => c.id === currentConversation.id);
                    if (updatedConv) {
                        currentConversation = updatedConv;
                        }
                    }
                }
            }

            if (conversations.length === 0) {
                // Keep same padding structure - container already has padding: 0.5rem
                const emptyDiv = document.createElement('div');
                emptyDiv.style.padding = '0';
                emptyDiv.style.color = 'var(--text-muted)';
                emptyDiv.style.fontSize = '0.85rem';
                emptyDiv.style.textAlign = 'center';
                emptyDiv.textContent = 'No conversations yet';
                container.appendChild(emptyDiv);
                return;
            }

            conversations.forEach(conv => {
                const item = document.createElement('div');
                // Compare by ID instead of reference to ensure correct active state
                item.className = 'conversation-item' + (currentConversation && conv.id === currentConversation.id ? ' active' : '');
                
                // Use title if available, otherwise use first message content, otherwise "New Chat"
                let preview = 'New Chat';
                if (conv.title && conv.title !== 'New Chat' && conv.title.trim() !== '') {
                    preview = conv.title;
                } else if (conv.messages && conv.messages.length > 0 && conv.messages[0].content) {
                    preview = conv.messages[0].content.substring(0, 30) + '...';
                }

                const content = document.createElement('div');
                content.className = 'conversation-item-content';
                content.textContent = preview;
                content.onclick = () => handleConversationClick(conv);

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'conversation-delete-btn';
                deleteBtn.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z" fill="currentColor"/></svg>';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteConversation(conv.id);
                };
                deleteBtn.title = 'Delete conversation';

                item.appendChild(content);
                item.appendChild(deleteBtn);
                container.appendChild(item);
            });
        }

        async function loadConversation(conv) {
            const convId = typeof conv === 'object' ? conv.id : conv;
            console.log('[loadConversation] Loading conversation:', convId, 'Type:', typeof convId);
            
            // Convert to number if it's a numeric string (from API)
            const convIdNum = (typeof convId === 'string' && !isNaN(convId)) ? parseInt(convId, 10) : convId;
            
            // Clear current conversation state first
            currentConversation = null;
            
            // Clear the chat messages container
            const container = document.getElementById('chat-messages');
            if (container) {
                container.innerHTML = '';
            }
            
            // If authenticated and conversation ID is numeric (from database), load from API
            if (currentUser && typeof convIdNum === 'number') {
                console.log('[loadConversation] Loading from API, conversation ID:', convIdNum);
                const loadedConv = await loadConversationFromAPI(convIdNum);
                console.log('[loadConversation] API response:', loadedConv);
                if (loadedConv) {
                    currentConversation = {
                        id: loadedConv.id,
                        title: loadedConv.title,
                        model: loadedConv.model,
                        messages: loadedConv.messages || []
                    };
                    currentModel = loadedConv.model || 'model1';
                    console.log('[loadConversation] Loaded conversation with', currentConversation.messages.length, 'messages');
                } else {
                    console.log('[loadConversation] API load failed, trying local fallback');
                    // Fallback to local - try both number and string comparison
                    const foundConv = conversations.find(c => c.id == convIdNum || c.id == convId);
                    if (!foundConv) {
                        console.error('[loadConversation] Conversation not found locally:', convIdNum);
                        return;
                    }
                    currentConversation = foundConv;
                    currentModel = foundConv.model || 'model1';
                    console.log('[loadConversation] Using local conversation with', currentConversation.messages?.length || 0, 'messages');
                }
            } else {
                console.log('[loadConversation] Loading from local storage, conversation ID:', convIdNum);
                // Guest mode or local conversation - use local data (try both number and string)
                const foundConv = conversations.find(c => c.id == convIdNum || c.id == convId);
                if (!foundConv) {
                    console.error('[loadConversation] Conversation not found:', convIdNum);
                    return;
                }
                currentConversation = foundConv;
                currentModel = foundConv.model || 'model1';
                console.log('[loadConversation] Using local conversation with', currentConversation.messages?.length || 0, 'messages');
            }

            // Update model toggle UI
            const toggle = document.getElementById('model-toggle');
            const label = document.getElementById('model-label');
            if (toggle && label) {
                if (currentModel === 'model2') {
                    toggle.classList.add('active');
                    label.textContent = 'Thinker';
                } else {
                    toggle.classList.remove('active');
                    label.textContent = 'Coder';
                }
            }

            // Refresh conversations list and render messages
            updateConversationsList();
            
            // Always render messages - renderMessages() will handle empty case
            console.log('[loadConversation] Rendering messages, conversation has', currentConversation?.messages?.length || 0, 'messages');
            renderMessages();

            // CRITICAL: Reset expanded cards after loading conversation to ensure hover works
            // This fixes the issue where cards don't pop up on hover after redirect from "New Chat" button
            setTimeout(function () {
                closeAllExpandedCards();
                // Clear any inline styles that might block hover events
                const allExpanded = document.querySelectorAll('.info-card-expanded');
                allExpanded.forEach(expanded => {
                    expanded.style.display = '';
                    expanded.style.opacity = '';
                    expanded.style.visibility = '';
                    expanded.style.pointerEvents = '';
                });
            }, 150);
        }

        function clearChat() {
            const container = document.getElementById('chat-messages');
            const welcome = document.getElementById('welcome-screen');

            if (container) {
                container.innerHTML = '';
            }

            if (welcome) {
                welcome.classList.remove('hidden');
            }
        }

        function renderMessages() {
            const container = document.getElementById('chat-messages');
            const welcome = document.getElementById('welcome-screen');

            if (!container) {
                console.error('[renderMessages] Container not found!');
                return;
            }

            if (!currentConversation) {
                console.log('[renderMessages] No current conversation, showing welcome');
                if (welcome) welcome.classList.remove('hidden');
                return;
            }

            if (!currentConversation.messages || currentConversation.messages.length === 0) {
                console.log('[renderMessages] No messages in conversation, showing welcome');
                if (welcome) welcome.classList.remove('hidden');
                return;
            }

            console.log('[renderMessages] Rendering', currentConversation.messages.length, 'messages');
            if (welcome) welcome.classList.add('hidden');
            container.innerHTML = '';

            currentConversation.messages.forEach((msg, index) => {
                console.log(`[renderMessages] Rendering message ${index + 1}:`, msg.role, msg.content?.substring(0, 50));
                addMessageToUI(msg.role, msg.content, false);
            });
        }

        function addMessageToUI(role, content, isLoading = false) {
            const container = document.getElementById('chat-messages');
            const welcome = document.getElementById('welcome-screen');

            if (!container) {
                console.error('chat-messages container not found!');
                return null;
            }

            if (welcome) {
                welcome.classList.add('hidden');
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;

            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            if (role === 'user') {
                // Check if user has a profile picture
                const avatarUrl = currentUser && (currentUser.profile_picture || currentUser.avatar);
                if (avatarUrl) {
                    // Show user's profile picture
                    const img = document.createElement('img');
                    img.src = avatarUrl;
                    img.alt = 'User';
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    img.style.borderRadius = '50%';
                    avatar.appendChild(img);
                } else {
                    // Fallback to 'U' if no profile picture
                    avatar.textContent = 'U';
                }
            } else {
                // Use ghost.JPG image for AI assistant
                const img = document.createElement('img');
                img.src = 'ghost.JPG';
                img.alt = 'AI';
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'cover';
                img.style.borderRadius = '50%';
                avatar.appendChild(img);
            }

            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';

            if (isLoading) {
                // Different loading text based on model
                const loadingText = (currentModel === 'model2') ? 'Thinking...' : 'Analyzing...';
                contentDiv.innerHTML = `<span class="loading"></span> ${loadingText}`;
            } else {
                // Format message with markdown support
                contentDiv.innerHTML = formatMessage(content);
                
                // Add copy button for assistant messages
                if (role === 'assistant') {
                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'message-copy-btn';
                    copyBtn.title = 'Copy message';
                    copyBtn.innerHTML = `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" fill="currentColor"/>
                    </svg>`;
                    copyBtn.onclick = async (e) => {
                        e.stopPropagation();
                        try {
                            // Get plain text content (strip HTML)
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = content;
                            const plainText = tempDiv.textContent || tempDiv.innerText || content;
                            
                            await navigator.clipboard.writeText(plainText);
                            
                            // Visual feedback
                            const originalHTML = copyBtn.innerHTML;
                            copyBtn.innerHTML = `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" fill="currentColor"/>
                            </svg>`;
                            copyBtn.style.color = 'var(--accent)';
                            
                            setTimeout(() => {
                                copyBtn.innerHTML = originalHTML;
                                copyBtn.style.color = '';
                            }, 2000);
                        } catch (err) {
                            console.error('Failed to copy:', err);
                            // Fallback for older browsers
                            const textArea = document.createElement('textarea');
                            textArea.value = content.replace(/<[^>]*>/g, '');
                            textArea.style.position = 'fixed';
                            textArea.style.opacity = '0';
                            document.body.appendChild(textArea);
                            textArea.select();
                            try {
                                document.execCommand('copy');
                                const originalHTML = copyBtn.innerHTML;
                                copyBtn.innerHTML = `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" fill="currentColor"/>
                                </svg>`;
                                copyBtn.style.color = 'var(--accent)';
                                setTimeout(() => {
                                    copyBtn.innerHTML = originalHTML;
                                    copyBtn.style.color = '';
                                }, 2000);
                            } catch (fallbackErr) {
                                console.error('Fallback copy failed:', fallbackErr);
                            }
                            document.body.removeChild(textArea);
                        }
                    };
                    contentDiv.appendChild(copyBtn);
                }
            }

            messageDiv.appendChild(avatar);
            messageDiv.appendChild(contentDiv);
            container.appendChild(messageDiv);

            container.scrollTop = container.scrollHeight;

            return messageDiv;
        }

        // API Configuration - Update these with your API keys and endpoints
        const API_CONFIG = {
            baseUrl: window.location.origin, // Use current origin
            models: {
                model1: { // Coder model
                    name: 'InfiNet-Coder',
                    apiKey: 'YOUR_WEBUI_API_KEY_1', // Coder API Key
                    endpoint: '/api/ollama/chat', // Use Ollama endpoint
                    modelName: 'hf.co/mradermacher/Huihui-Qwen3-Coder-30B-A3B-Instruct-abliterated-i1-GGUF:Q3_K_M' // Huihui-Qwen3-Coder-30B
                },
                model2: { // Thinker model
                    name: 'InfiNet-Thinker',
                    apiKey: 'YOUR_WEBUI_API_KEY_2', // Thinker API Key
                    endpoint: '/api/ollama/chat', // Use Ollama endpoint
                    modelName: 'hf.co/DavidAU/Qwen3-4B-Gemini-TripleX-High-Reasoning-Thinking-Heretic-Uncensored-GGUF:Q8_0' // Qwen3-4B-Gemini-TripleX (temporary - LFM2 model is corrupted)
                }
            }
        };

        async function sendMessage() {
            console.log('sendMessage called');
            const input = document.getElementById('message-input');
            if (!input) {
                console.error('Input element not found!');
                return;
            }

            const message = input.value.trim();
            console.log('Message:', message);

            if (!message) {
                console.log('Empty message, returning');
                return;
            }

            const sendBtn = document.getElementById('send-btn');
            let loadingMsg = null;

            try {
                // Disable input and button immediately
                input.disabled = true;
                if (sendBtn) sendBtn.disabled = true;

                // Initialize conversation if needed
                if (!currentConversation) {
                    console.log('Creating new conversation');
                    try {
                        await newChat();
                    } catch (error) {
                        console.error('Error in newChat:', error);
                        // Create conversation manually if newChat fails
                        currentConversation = {
                            id: Date.now(),
                            messages: [],
                            model: currentModel || 'model1'
                        };
                    }
                }

                // Ensure currentConversation exists before setting model
                if (!currentConversation) {
                    console.error('Failed to create conversation, cannot send message');
                    throw new Error('Failed to initialize conversation');
                }

                // Ensure currentModel is defined
                if (typeof currentModel === 'undefined') {
                    console.warn('currentModel is undefined, defaulting to model1 (Coder)');
                    currentModel = 'model1';
                }

                console.log('Current model:', currentModel);

                // Use currentModel from toggle
                currentConversation.model = currentModel;

                // Get current model config
                const modelConfig = API_CONFIG.models[currentModel];
                console.log('Model config:', modelConfig);

                if (!modelConfig) {
                    throw new Error('Model configuration not found. Please check your API configuration.');
                }

                // Check if this is the first message (conversation not in list yet)
                const convIndex = conversations.findIndex(c => c.id === currentConversation.id);
                const isFirstMessage = convIndex === -1;

                // Add user message to conversation
                console.log('Adding user message to conversation');
                currentConversation.messages.push({ role: 'user', content: message });

                // Save user message to API if authenticated
                if (currentUser && typeof currentConversation.id === 'number') {
                    await addMessageToConversationAPI(currentConversation.id, 'user', message);
                }

                // Add user message to UI
                addMessageToUI('user', message);

                // Clear input after message is added to UI
                input.value = '';
                autoResize(input);

                // If this is the first message, reload from API to get the new conversation
                if (isFirstMessage) {
                    // Don't add manually - let loadConversationsFromAPI handle it
                    // Reload conversations from API to get the new one (this will add it to the list)
                    if (currentUser) {
                        await loadConversationsFromAPI();
                        // After reloading, update currentConversation to match what's in the list
                        const updatedConv = conversations.find(c => c.id === currentConversation.id);
                        if (updatedConv) {
                            currentConversation = {
                                ...updatedConv,
                                messages: currentConversation.messages // Keep local messages
                            };
                        }
                    } else {
                        // Guest mode - add manually
                        conversations.unshift(currentConversation);
                    }
                } else {
                    // Update the existing conversation in the array
                    conversations[convIndex] = {
                        ...conversations[convIndex],
                        ...currentConversation,
                        messages: currentConversation.messages
                    };
                }

                // Save to localStorage as backup (for guest mode or offline)
                if (!currentUser) {
                localStorage.setItem('conversations', JSON.stringify(conversations));
                }

                // Update sidebar title immediately with first message
                updateConversationsList();

                // Show loading
                console.log('Showing loading message');
                loadingMsg = addMessageToUI('assistant', '', true);

                console.log('Starting API call');
                // Prepare messages for API (include conversation history)
                const messages = currentConversation.messages.map(msg => ({
                    role: msg.role,
                    content: msg.content
                }));

                console.log('Prepared messages:', messages);

                let response;
                let data;

                // Always use /api/ollama/chat endpoint when API key is available
                if (modelConfig.apiKey && modelConfig.apiKey.trim() !== '') {
                    console.log('Making API call to /api/ollama/chat');
                    console.log('API Key (first 10 chars):', modelConfig.apiKey.substring(0, 10) + '...');

                    // Make API call to local /api/ollama/chat endpoint with streaming
                    response = await fetch("/api/ollama/chat", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "X-API-Key": modelConfig.apiKey
                        },
                        credentials: 'include', // Include session cookie for token tracking
                        body: JSON.stringify({
                            type: "conversation",
                            messages: messages,
                            stream: true
                        })
                    });

                    console.log('Response status:', response.status, response.statusText);

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: `API Error: ${response.status} ${response.statusText}` }));
                        console.error('API Error response:', errorData);
                        // Check for insufficient tokens error (status 402)
                        if (response.status === 402 && (errorData.error?.toLowerCase().includes('insufficient tokens') || errorData.error?.toLowerCase().includes('token'))) {
                            throw new Error('Insufficient tokens');
                        }
                        throw new Error(errorData.error || `API Error: ${response.status} ${response.statusText}`);
                    }

                    // Handle streaming response
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let assistantMessage = '';
                    let buffer = '';

                    if (!loadingMsg || !loadingMsg.querySelector('.message-content')) {
                        throw new Error('Loading message element not found in UI');
                    }

                    const messageContent = loadingMsg.querySelector('.message-content');
                    
                    // Throttle UI updates to prevent freezing (declare outside loop)
                    let lastUpdateTime = 0;
                    const UPDATE_THROTTLE = 100; // Update every 100ms max
                    let updateScheduled = false;
                    let pendingUpdate = null;
                    
                    const scheduleUpdate = () => {
                        if (updateScheduled) return;
                        updateScheduled = true;
                        requestAnimationFrame(() => {
                            const now = Date.now();
                            if (now - lastUpdateTime >= UPDATE_THROTTLE) {
                                if (pendingUpdate) {
                                    messageContent.innerHTML = formatMessage(pendingUpdate);
                                    const container = document.getElementById('chat-messages');
                                    if (container) {
                                        container.scrollTop = container.scrollHeight;
                                    }
                                    pendingUpdate = null;
                                    lastUpdateTime = now;
                                }
                                updateScheduled = false;
                            } else {
                                setTimeout(() => {
                                    if (pendingUpdate) {
                                        messageContent.innerHTML = formatMessage(pendingUpdate);
                                        const container = document.getElementById('chat-messages');
                                        if (container) {
                                            container.scrollTop = container.scrollHeight;
                                        }
                                        pendingUpdate = null;
                                    }
                                    lastUpdateTime = Date.now();
                                    updateScheduled = false;
                                }, UPDATE_THROTTLE - (now - lastUpdateTime));
                            }
                        });
                    };

                    while (true) {
                        const { done, value } = await reader.read();

                        if (done) {
                            break;
                        }

                        // Decode the chunk
                        buffer += decoder.decode(value, { stream: true });

                        // Process complete lines
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || ''; // Keep incomplete line in buffer
                        
                        for (const line of lines) {
                            if (line.trim() === '') continue;

                            try {
                                // Ollama streaming format: each line is a JSON object
                                const jsonData = JSON.parse(line);

                                // Extract the response text
                                if (jsonData.response) {
                                    assistantMessage += jsonData.response;
                                    pendingUpdate = assistantMessage;
                                    scheduleUpdate();
                                }
                            } catch (e) {
                                // If it's not JSON, might be plain text, append it
                                if (line.trim()) {
                                    assistantMessage += line + '\n';
                                    pendingUpdate = assistantMessage;
                                    scheduleUpdate();
                                }
                            }
                        }
                    }
                    
                    // Final update after streaming completes
                    messageContent.innerHTML = formatMessage(assistantMessage);
                    const container = document.getElementById('chat-messages');
                    if (container) {
                        container.scrollTop = container.scrollHeight;
                    }

                    // Process any remaining buffer
                    if (buffer.trim()) {
                        try {
                            const jsonData = JSON.parse(buffer);
                            if (jsonData.response) {
                                assistantMessage += jsonData.response;
                            }
                        } catch (e) {
                            if (buffer.trim()) {
                                assistantMessage += buffer;
                            }
                        }
                        messageContent.innerHTML = formatMessage(assistantMessage);
                    }

                    console.log('Final assistant message:', assistantMessage);

                    // Save the complete message
                    currentConversation.messages.push({ role: 'assistant', content: assistantMessage });

                    // Save assistant message to API if authenticated
                    if (currentUser && typeof currentConversation.id === 'number') {
                        await addMessageToConversationAPI(currentConversation.id, 'assistant', assistantMessage);
                    }

                    // Update the existing conversation in the array (don't add it again)
                    const convIndex = conversations.findIndex(c => c.id === currentConversation.id);
                    if (convIndex !== -1) {
                        // Update existing conversation
                        conversations[convIndex] = {
                            ...conversations[convIndex],
                            ...currentConversation,
                            messages: currentConversation.messages
                        };
                    } else {
                        // Only add if it's truly not in the list (shouldn't happen after first message)
                        console.warn('Conversation not found in list after assistant message, this should not happen');
                        // Don't add it - it should already be in the list from the user message
                    }

                    // Save to localStorage as backup (for guest mode or offline)
                    if (!currentUser) {
                    localStorage.setItem('conversations', JSON.stringify(conversations));
                    }
                    updateConversationsList();
                    
                    // Update tokens badge after message
                    await updateTokensBadge();
                } else {
                    // No API key - show error
                    throw new Error('API key is required. Please configure an API key for this model.');
                }

            } catch (error) {
                console.error('Error in sendMessage:', error);
                const errorMessage = error.message || 'Unknown error occurred';
                console.error('Error details:', errorMessage);
                console.error('Error stack:', error.stack);

                // Check if it's an insufficient tokens error
                if (errorMessage.toLowerCase().includes('insufficient tokens') || 
                    errorMessage.toLowerCase().includes('token limit') ||
                    errorMessage.toLowerCase().includes('not enough tokens')) {
                    // Show token limit modal
                    showTokenLimitModal();
                    // Remove loading message
                    if (loadingMsg) {
                        loadingMsg.remove();
                    }
                } else {
                    // Show regular error in UI
                    if (loadingMsg && loadingMsg.querySelector('.message-content')) {
                        loadingMsg.querySelector('.message-content').innerHTML = `<p style="color: var(--accent);">Error: ${escapeHtml(errorMessage)}</p>`;
                        // Remove loading indicator if present
                        const loadingIndicator = loadingMsg.querySelector('.loading');
                        if (loadingIndicator) loadingIndicator.remove();
                    } else {
                        // If loadingMsg doesn't exist, create an error message
                        try {
                            const errorMsg = addMessageToUI('assistant', 'Error: ' + escapeHtml(errorMessage), false);
                            if (errorMsg && errorMsg.querySelector('.message-content')) {
                                errorMsg.querySelector('.message-content').style.color = 'var(--accent)';
                            }
                        } catch (uiError) {
                            console.error('Error displaying error message:', uiError);
                            alert('Error: ' + errorMessage);
                        }
                    }
                }
            } finally {
                // Re-enable input
                input.disabled = false;
                if (sendBtn) sendBtn.disabled = false;
                input.focus();
            }
        }

        function formatMessage(text) {
            if (!text) return '';

            // First escape HTML to prevent XSS
            let formatted = escapeHtml(text);

            // Extract code blocks first (ChatGPT style - separate pills with copy buttons)
            const codeBlocks = [];
            const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
            let codeBlockIndex = 0;
            let match;
            
            while ((match = codeBlockRegex.exec(formatted)) !== null) {
                const language = match[1] || 'text';
                const code = match[2];
                const placeholder = `__CODE_BLOCK_${codeBlockIndex}__`;
                codeBlocks.push({ language, code, placeholder });
                formatted = formatted.replace(match[0], placeholder);
                codeBlockIndex++;
            }

            // Split into lines for processing
            const lines = formatted.split('\n');
            const result = [];
            let inOrderedList = false;
            let inUnorderedList = false;
            let listItems = [];

            function closeList() {
                if (inOrderedList && listItems.length > 0) {
                    result.push('<ol style="margin: 0.5rem 0; padding-left: 1.5rem; list-style-type: decimal;">');
                    result.push(...listItems);
                    result.push('</ol>');
                    listItems = [];
                    inOrderedList = false;
                } else if (inUnorderedList && listItems.length > 0) {
                    result.push('<ul style="margin: 0.5rem 0; padding-left: 1.5rem; list-style-type: disc;">');
                    result.push(...listItems);
                    result.push('</ul>');
                    listItems = [];
                    inUnorderedList = false;
                }
            }

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // Check for code block placeholder
                const codeBlockMatch = line.match(/__CODE_BLOCK_(\d+)__/);
                if (codeBlockMatch) {
                    closeList();
                    const blockIndex = parseInt(codeBlockMatch[1]);
                    const codeBlock = codeBlocks[blockIndex];
                    if (codeBlock) {
                        const codeBlockId = `code-block-${Date.now()}-${blockIndex}`;
                        result.push(`
                            <div class="code-block-container">
                                <div class="code-block-header">
                                    <span class="code-block-language">${codeBlock.language}</span>
                                    <button class="code-block-copy-btn" onclick="copyCodeBlock('${codeBlockId}')" title="Copy code">
                                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                            <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" fill="currentColor"/>
                                        </svg>
                                        Copy
                                    </button>
                                </div>
                                <div class="code-block-content">
                                    <pre><code id="${codeBlockId}">${codeBlock.code}</code></pre>
                                </div>
                            </div>
                        `);
                    }
                    continue;
                }

                // Check for headings
                if (line.match(/^###\s+(.+)$/)) {
                    closeList();
                    result.push(`<h3 style="font-size: 1.1rem; font-weight: 600; margin: 1rem 0 0.5rem 0; color: var(--text-primary);">${line.replace(/^###\s+/, '')}</h3>`);
                } else if (line.match(/^##\s+(.+)$/)) {
                    closeList();
                    result.push(`<h2 style="font-size: 1.3rem; font-weight: 600; margin: 1.2rem 0 0.6rem 0; color: var(--text-primary);">${line.replace(/^##\s+/, '')}</h2>`);
                } else if (line.match(/^#\s+(.+)$/)) {
                    closeList();
                    result.push(`<h1 style="font-size: 1.5rem; font-weight: 700; margin: 1.5rem 0 0.8rem 0; color: var(--text-primary);">${line.replace(/^#\s+/, '')}</h1>`);
                }
                // Check for numbered list
                else if (line.match(/^\d+\.\s+(.+)$/)) {
                    if (!inOrderedList) {
                        closeList();
                        inOrderedList = true;
                    }
                    const content = line.replace(/^\d+\.\s+/, '');
                    listItems.push(`<li style="margin: 0.3rem 0; padding-left: 0.5rem;">${content}</li>`);
                }
                // Check for bullet list
                else if (line.match(/^[\*\-\+]\s+(.+)$/)) {
                    if (!inUnorderedList) {
                        closeList();
                        inUnorderedList = true;
                    }
                    const content = line.replace(/^[\*\-\+]\s+/, '');
                    listItems.push(`<li style="margin: 0.3rem 0; padding-left: 0.5rem;">${content}</li>`);
                }
                // Regular line
                else {
                    closeList();
                    if (line.trim()) {
                        result.push(`<p style="margin: 0.8rem 0; word-wrap: break-word; overflow-wrap: break-word;">${line}</p>`);
                    } else {
                        result.push('<br>');
                    }
                }
            }

            closeList();

            // Join and process inline formatting
            formatted = result.join('');

            // Convert inline code (backticks) - do this before bold/italic
            formatted = formatted.replace(/`([^`]+)`/g, '<code class="inline-code">$1</code>');

            // Convert bold (**text** or __text__)
            formatted = formatted.replace(/\*\*(.*?)\*\*/g, '<strong style="font-weight: 600;">$1</strong>');
            formatted = formatted.replace(/__(.*?)__/g, '<strong style="font-weight: 600;">$1</strong>');

            // Convert italic (*text* or _text_) - but avoid conflicts with bold and list markers
            // Only match single * or _ that are not part of ** or list markers
            formatted = formatted.replace(/(?<!\*)\*([^*]+?)\*(?!\*)/g, '<em style="font-style: italic;">$1</em>');
            formatted = formatted.replace(/(?<!_)_([^_]+?)_(?!_)/g, '<em style="font-style: italic;">$1</em>');

            return formatted;
        }
        
        // Copy code block function
        async function copyCodeBlock(codeBlockId) {
            const codeElement = document.getElementById(codeBlockId);
            if (!codeElement) return;
            
            const code = codeElement.textContent || codeElement.innerText;
            try {
                await navigator.clipboard.writeText(code);
                
                // Visual feedback
                const btn = event.target.closest('.code-block-copy-btn');
                if (btn) {
                    const originalHTML = btn.innerHTML;
                    btn.innerHTML = `
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" fill="currentColor"/>
                        </svg>
                        Copied!
                    `;
                    btn.style.color = 'var(--accent)';
                    
                    setTimeout(() => {
                        btn.innerHTML = originalHTML;
                        btn.style.color = '';
                    }, 2000);
                }
            } catch (err) {
                console.error('Failed to copy:', err);
            }
        }

        function handleKeyDown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        function autoResize(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 200) + 'px';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showPricing() {
            window.location.href = '/pricing';
        }

        // Authentication State (using the global currentUser from above)
        let isAuthenticated = localStorage.getItem('isAuthenticated') === 'true';
        // Note: currentUser is already declared globally above

        function showRegister() {
            document.getElementById('auth-modal').style.display = 'flex';
        }

        function closeAuthModal() {
            document.getElementById('auth-modal').style.display = 'none';
            // Reset forms
            document.getElementById('login-form').reset();
            document.getElementById('register-form').reset();
            document.getElementById('auth-error').textContent = '';
        }

        function switchAuthTab(tab) {
            document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.auth-content').forEach(c => c.classList.remove('active'));

            document.getElementById(tab + '-tab').classList.add('active');
            document.getElementById(tab + '-content').classList.add('active');
            document.getElementById('auth-error').textContent = '';
        }

        // Token Limit Modal Functions
        function showTokenLimitModal() {
            const modal = document.getElementById('token-limit-modal');
            if (modal) {
                modal.classList.add('show');
            }
        }

        function closeTokenLimitModal() {
            const modal = document.getElementById('token-limit-modal');
            if (modal) {
                modal.classList.remove('show');
            }
        }

        // Close token limit modal when clicking outside
        document.addEventListener('DOMContentLoaded', function() {
            const tokenLimitModal = document.getElementById('token-limit-modal');
            if (tokenLimitModal) {
                tokenLimitModal.addEventListener('click', function(event) {
                    if (event.target === tokenLimitModal) {
                        closeTokenLimitModal();
                    }
                });
            }
        });

        function validatePassword(password) {
            if (password.length < 8) {
                return 'Password must be at least 8 characters long';
            }
            const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(password);
            const hasUpperCase = /[A-Z]/.test(password);
            if (!hasSpecial && !hasUpperCase) {
                return 'Password must contain at least one special character or uppercase letter';
            }
            return '';
        }

        async function handleLogin(event) {
            event.preventDefault();
            const email = document.getElementById('login-email').value;
            const password = document.getElementById('login-password').value;
            const errorDiv = document.getElementById('auth-error');

            if (!email || !password) {
                errorDiv.textContent = 'Please enter email and password';
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/api/login`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ email, password })
                });

                const data = await response.json();

                if (!response.ok) {
                    errorDiv.textContent = data.error || 'Login failed';
                    return;
                }

                // Success - reload full user data from /api/user/me to get all fields
                const authResult = await checkAuth();
                if (authResult) {
                    // checkAuth() already sets isAuthenticated and currentUser with full data
                    // Reload conversations from API
                    await loadConversationsFromAPI();
                    updateConversationsList();
                    
                    updateAuthUI();
                    updateSidebarProfileLink();
                    closeAuthModal();
                    
                    console.log('Login successful, user data loaded:', currentUser);
                } else {
                    errorDiv.textContent = 'Login successful but failed to load user data';
                }
            } catch (error) {
                console.error('Login error:', error);
                errorDiv.textContent = 'Network error. Please try again.';
            }
        }

        async function handleRegister(event) {
            event.preventDefault();
            const email = document.getElementById('register-email').value;
            const password = document.getElementById('register-password').value;
            const confirmPassword = document.getElementById('register-confirm-password').value;
            const verificationCode = document.getElementById('register-verification-code').value;
            const errorDiv = document.getElementById('auth-error');

            const passwordError = validatePassword(password);
            if (passwordError) {
                errorDiv.textContent = passwordError;
                return;
            }

            if (password !== confirmPassword) {
                errorDiv.textContent = 'Passwords do not match';
                return;
            }

            // TODO: Verify email code (Phase 2)
            // For now, skip verification code check
            if (verificationCode && verificationCode.length !== 6) {
                errorDiv.textContent = 'Verification code must be 6 digits (Email verification coming in Phase 2)';
                // Don't return - allow registration for now
            }

            try {
                const response = await fetch(`${API_BASE}/api/register`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ 
                        email, 
                        password,
                        displayName: email.split('@')[0]
                    })
                });

                const data = await response.json();

                if (!response.ok) {
                    errorDiv.textContent = data.error || 'Registration failed';
                    return;
                }

                // Success - reload full user data from /api/user/me to get all fields
                const authResult = await checkAuth();
                if (authResult) {
                    // checkAuth() already sets isAuthenticated and currentUser with full data
                    // Reload conversations from API
                    await loadConversationsFromAPI();
                    updateConversationsList();
                    
                    updateAuthUI();
                    updateSidebarProfileLink();
                    closeAuthModal();
                    
                    console.log('Registration successful, user data loaded:', currentUser);
                } else {
                    errorDiv.textContent = 'Registration successful but failed to load user data';
                    return;
                }
            } catch (error) {
                console.error('Registration error:', error);
                errorDiv.textContent = 'Network error. Please try again.';
            }
        }

        function handleGoogleSignIn() {
            // Redirect to Google OAuth endpoint
            window.location.href = `${API_BASE}/api/auth/google`;
        }

        function updateAuthUI() {
            const hopInBtn = document.querySelector('.header-btn.primary');
            if (!hopInBtn) {
                console.warn('Hop In button not found');
                return;
            }
            
            if (isAuthenticated && currentUser) {
                // Extract name from email if not set
                const userName = currentUser.display_name || currentUser.name || (currentUser.email ? currentUser.email.split('@')[0] : 'User');
                if (!currentUser.name) {
                    currentUser.name = userName;
                }

                // Make button circular
                hopInBtn.style.width = '40px';
                hopInBtn.style.height = '40px';
                hopInBtn.style.padding = '0';
                hopInBtn.style.borderRadius = '50%';
                hopInBtn.style.border = '2px solid var(--accent)';
                hopInBtn.style.overflow = 'hidden';
                hopInBtn.style.display = 'flex';
                hopInBtn.style.alignItems = 'center';
                hopInBtn.style.justifyContent = 'center';
                hopInBtn.style.position = 'relative';

                // Get avatar (image, emoji, or default) - prioritize profile_picture from Google
                const avatarUrl = currentUser.profile_picture || currentUser.avatar;
                console.log('Updating avatar UI:', { avatarUrl, profile_picture: currentUser.profile_picture, avatar: currentUser.avatar });
                if (avatarUrl) {
                    // Add class to indicate profile picture is present
                    hopInBtn.classList.add('has-profile-picture');
                    // Show profile picture as background - use !important to override light-mode CSS
                    hopInBtn.style.setProperty('background-image', `url(${avatarUrl})`, 'important');
                    hopInBtn.style.setProperty('background-size', 'cover', 'important');
                    hopInBtn.style.setProperty('background-position', 'center', 'important');
                    hopInBtn.style.setProperty('background-color', 'transparent', 'important');
                    hopInBtn.innerHTML = '';
                    console.log('Profile picture displayed:', avatarUrl);
                } else if (currentUser.avatarEmoji) {
                    hopInBtn.style.backgroundImage = 'none';
                    hopInBtn.style.backgroundColor = 'var(--bg-tertiary)';
                    hopInBtn.innerHTML = `<span style="font-size: 1.5rem;">${currentUser.avatarEmoji}</span>`;
                } else {
                    hopInBtn.style.backgroundImage = 'none';
                    hopInBtn.style.backgroundColor = 'var(--bg-tertiary)';
                    const initial = userName.charAt(0).toUpperCase();
                    hopInBtn.innerHTML = `<span style="font-size: 1rem; font-weight: 600; color: var(--accent);">${initial}</span>`;
                    console.log('Using initial letter:', initial);
                }

                hopInBtn.onclick = () => window.location.href = '/profile';
                hopInBtn.title = userName || 'Profile';
            } else {
                // Remove profile picture class when not authenticated
                hopInBtn.classList.remove('has-profile-picture');
                hopInBtn.style.width = 'auto';
                hopInBtn.style.height = 'auto';
                hopInBtn.style.padding = '0.5rem 1rem';
                hopInBtn.style.borderRadius = '8px';
                hopInBtn.style.border = 'none';
                hopInBtn.style.overflow = 'visible';
                hopInBtn.style.backgroundImage = 'none';
                hopInBtn.style.backgroundColor = 'var(--accent)';
                hopInBtn.innerHTML = '<strong>Hop In</strong>';
                hopInBtn.onclick = showRegister;
                hopInBtn.title = '';
            }
        }

        // Close modal when clicking outside
        window.addEventListener('click', function (event) {
            const modal = document.getElementById('auth-modal');
            if (event.target === modal) {
                closeAuthModal();
            }
        });

        // Model Toggle Function
        let currentModel = 'model1'; // model1 = InfiNet-Coder (OFF/default), model2 = InfiNet-Thinker (ON)

        function toggleModel() {
            const toggle = document.getElementById('model-toggle');
            const label = document.getElementById('model-label');

            if (currentModel === 'model1') {
                // Switch to Thinker (ON)
                currentModel = 'model2';
                toggle.classList.add('active');
                label.textContent = 'Thinker';
            } else {
                // Switch to Coder (OFF)
                currentModel = 'model1';
                toggle.classList.remove('active');
                label.textContent = 'Coder';
            }
        }


        // Image to Image Functions
        function openImageToImage() {
            document.getElementById('img-to-img-upload').click();
        }

        function handleImageToImageUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const imageUrl = e.target.result;
                    addImageToImageToChat(imageUrl);
                    // Update placeholder for image-to-image
                    const input = document.getElementById('message-input');
                    input.placeholder = 'Describe what you want to change in this image...';
                };
                reader.readAsDataURL(file);
            }
        }

        function addImageToImageToChat(imageUrl) {
            const container = document.getElementById('chat-messages');
            const welcome = document.getElementById('welcome-screen');
            welcome.classList.add('hidden');

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message user';

            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            // Check if user has a profile picture
            const avatarUrl = currentUser && (currentUser.profile_picture || currentUser.avatar);
            if (avatarUrl) {
                // Show user's profile picture
                const img = document.createElement('img');
                img.src = avatarUrl;
                img.alt = 'User';
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'cover';
                img.style.borderRadius = '50%';
                avatar.appendChild(img);
            } else {
                // Fallback to 'U' if no profile picture
                avatar.textContent = 'U';
            }

            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.innerHTML = `<p>Image to Image:</p><img src="${imageUrl}" alt="Uploaded image" style="max-width: 300px; border-radius: 8px; margin-top: 0.5rem;">`;

            messageDiv.appendChild(avatar);
            messageDiv.appendChild(contentDiv);
            container.appendChild(messageDiv);

            container.scrollTop = container.scrollHeight;
        }

        // Regular Image Upload (for chat)
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const imageUrl = e.target.result;
                    addImageToChat(imageUrl);
                };
                reader.readAsDataURL(file);
            }
        }

        function addImageToChat(imageUrl) {
            const container = document.getElementById('chat-messages');
            const welcome = document.getElementById('welcome-screen');
            welcome.classList.add('hidden');

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message user';

            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            // Check if user has a profile picture
            const avatarUrl = currentUser && (currentUser.profile_picture || currentUser.avatar);
            if (avatarUrl) {
                // Show user's profile picture
                const img = document.createElement('img');
                img.src = avatarUrl;
                img.alt = 'User';
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'cover';
                img.style.borderRadius = '50%';
                avatar.appendChild(img);
            } else {
                // Fallback to 'U' if no profile picture
                avatar.textContent = 'U';
            }

            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.innerHTML = `<img src="${imageUrl}" alt="Uploaded image" style="max-width: 300px; border-radius: 8px; margin-top: 0.5rem;">`;

            messageDiv.appendChild(avatar);
            messageDiv.appendChild(contentDiv);
            container.appendChild(messageDiv);

            container.scrollTop = container.scrollHeight;
        }

        // Update theme-color meta tag
        function updateThemeColor(isLight) {
            let themeColorMeta = document.querySelector('meta[name="theme-color"]');
            let appleStatusBarMeta = document.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
            
            if (!themeColorMeta) {
                themeColorMeta = document.createElement('meta');
                themeColorMeta.setAttribute('name', 'theme-color');
                document.head.appendChild(themeColorMeta);
            }
            if (!appleStatusBarMeta) {
                appleStatusBarMeta = document.createElement('meta');
                appleStatusBarMeta.setAttribute('name', 'apple-mobile-web-app-status-bar-style');
                document.head.appendChild(appleStatusBarMeta);
            }
            
            if (isLight) {
                themeColorMeta.setAttribute('content', '#ffffff');
                appleStatusBarMeta.setAttribute('content', 'default');
            } else {
                themeColorMeta.setAttribute('content', '#000000');
                appleStatusBarMeta.setAttribute('content', 'black');
            }
        }

        // Theme Toggle Function
        function toggleTheme() {
            const body = document.body;
            const themeIcon = document.getElementById('theme-icon');

            if (body.classList.contains('light-mode')) {
                body.classList.remove('light-mode');
                // Moon icon for dark mode (crescent moon)
                themeIcon.innerHTML = '<path d="M21.64 13a1 1 0 0 0-1.05-.14 8.05 8.05 0 0 1-3.37.73 8.15 8.15 0 0 1-8.14-8.1 8.59 8.59 0 0 1 .25-2A1 1 0 0 0 8 2.36 10.14 10.14 0 1 0 22 14.05 1 1 0 0 0 21.64 13Z" fill="currentColor"/>';
                localStorage.setItem('theme', 'dark');
                updateThemeColor(false);
            } else {
                body.classList.add('light-mode');
                // Sun icon for light mode
                themeIcon.innerHTML = '<circle cx="12" cy="12" r="5" fill="currentColor"/><path d="M12 1V3M12 21V23M4.22 4.22L5.64 5.64M18.36 18.36L19.78 19.78M1 12H3M21 12H23M4.22 19.78L5.64 18.36M18.36 5.64L19.78 4.22" stroke="currentColor" stroke-width="2" stroke-linecap="round" fill="none"/>';
                localStorage.setItem('theme', 'light');
                updateThemeColor(true);
            }
        }

        // Load saved theme on page load
        function loadTheme() {
            const savedTheme = localStorage.getItem('theme');
            const themeIcon = document.getElementById('theme-icon');

            if (savedTheme === 'light') {
                document.body.classList.add('light-mode');
                document.documentElement.setAttribute('data-force-light', '1');
                // Sun icon for light mode
                themeIcon.innerHTML = '<circle cx="12" cy="12" r="5" fill="currentColor"/><path d="M12 1V3M12 21V23M4.22 4.22L5.64 5.64M18.36 18.36L19.78 19.78M1 12H3M21 12H23M4.22 19.78L5.64 18.36M18.36 5.64L19.78 4.22" stroke="currentColor" stroke-width="2" stroke-linecap="round" fill="none"/>';
                updateThemeColor(true);
            } else {
                document.body.classList.remove('light-mode');
                document.documentElement.removeAttribute('data-force-light');
                // Moon icon for dark mode (crescent moon)
                themeIcon.innerHTML = '<path d="M21.64 13a1 1 0 0 0-1.05-.14 8.05 8.05 0 0 1-3.37.73 8.15 8.15 0 0 1-8.14-8.1 8.59 8.59 0 0 1 .25-2A1 1 0 0 0 8 2.36 10.14 10.14 0 1 0 22 14.05 1 1 0 0 0 21.64 13Z" fill="currentColor"/>';
                updateThemeColor(false);
            }
        }

        // Maintain theme-color on scroll (immediate, no debounce)
        function refreshThemeColor() {
            const isLightMode = document.body.classList.contains('light-mode');
            updateThemeColor(isLightMode);
            const topSafe = document.querySelector('.top-safe-area');
            if (topSafe) topSafe.style.display = isLightMode ? 'block' : 'none';
        }
        window.addEventListener('scroll', refreshThemeColor, { passive: true });
        window.addEventListener('pageshow', refreshThemeColor, { passive: true });
        document.addEventListener('visibilitychange', function () {
            if (!document.hidden) refreshThemeColor();
        }, { passive: true });
        window.addEventListener('resize', refreshThemeColor, { passive: true });
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', refreshThemeColor, { once: true });
        } else {
            refreshThemeColor();
        }
        
        


        // Expanded Card Functions
        let activeExpandedCard = null;

        function closeAllExpandedCards() {
            // Close all expanded cards and reset state
            const allExpanded = document.querySelectorAll('.info-card-expanded');
            allExpanded.forEach(expanded => {
                expanded.classList.remove('show');
            });

            const allCards = document.querySelectorAll('.info-card');
            allCards.forEach(card => {
                card.classList.remove('expanded-active');
            });

            activeExpandedCard = null;

            // IMPORTANT: Remove any inline styles that might block hover
            setTimeout(function () {
                allExpanded.forEach(expanded => {
                    expanded.style.display = '';
                    expanded.style.opacity = '';
                    expanded.style.visibility = '';
                });
            }, 50);
        }

        function showExpandedCard(type) {
            // Only show on hover for desktop (not touch devices)
            if ('ontouchstart' in window) {
                return; // Don't show on hover for mobile
            }

            // IMMEDIATELY close ALL other cards first (no matter which one)
            if (activeExpandedCard && activeExpandedCard !== type) {
                const otherExpanded = document.getElementById(activeExpandedCard + '-expanded');
                if (otherExpanded) {
                    otherExpanded.classList.remove('show');
                    // Don't set inline display - let CSS handle it
                    const otherParentCard = otherExpanded.closest('.info-card');
                    if (otherParentCard) {
                        otherParentCard.classList.remove('expanded-active');
                    }
                }
            }

            const expanded = document.getElementById(type + '-expanded');
            if (expanded) {
                // Ensure no inline styles are blocking it
                expanded.style.display = '';
                expanded.style.opacity = '';
                expanded.style.visibility = '';
                expanded.style.pointerEvents = '';

                expanded.classList.add('show');
                activeExpandedCard = type;
                // Add class to parent card for z-index
                const parentCard = expanded.closest('.info-card');
                if (parentCard) {
                    parentCard.classList.add('expanded-active');
                }
            }
        }

        function hideExpandedCard(type) {
            // Only hide on mouse leave for desktop (not touch devices)
            if ('ontouchstart' in window) {
                return; // Don't hide on mouse leave for mobile
            }

            // Immediately close if this is the active card
            if (activeExpandedCard === type) {
                const expanded = document.getElementById(type + '-expanded');
                if (expanded) {
                    // Small delay to allow mouse to move to expanded area
                    setTimeout(function () {
                        const card = expanded.closest('.info-card');
                        const isOverCard = card && card.matches(':hover');
                        const isOverExpanded = expanded && expanded.matches(':hover');

                        // Only close if mouse is not over card or expanded area
                        if (!isOverCard && !isOverExpanded && activeExpandedCard === type) {
                            expanded.classList.remove('show');
                            activeExpandedCard = null;
                            if (card) {
                                card.classList.remove('expanded-active');
                            }
                        }
                    }, 150);
                }
            }
        }

        function toggleExpandedCard(type) {
            const expanded = document.getElementById(type + '-expanded');
            if (expanded) {
                const isCurrentlyOpen = expanded.classList.contains('show');

                // ALWAYS close ALL other expanded cards first (force with inline styles)
                const allExpanded = document.querySelectorAll('.info-card-expanded');
                allExpanded.forEach(exp => {
                    if (exp !== expanded) {
                        exp.classList.remove('show');
                        exp.style.display = 'none';
                        const parentCard = exp.closest('.info-card');
                        if (parentCard) {
                            parentCard.classList.remove('expanded-active');
                        }
                    }
                });

                // Toggle current card
                const parentCard = expanded.closest('.info-card');
                if (isCurrentlyOpen) {
                    // If currently open, close it
                    expanded.classList.remove('show');
                    expanded.style.display = 'none';
                    activeExpandedCard = null;
                    if (parentCard) {
                        parentCard.classList.remove('expanded-active');
                    }

                    // Reset display style after a moment
                    setTimeout(function () {
                        expanded.style.display = '';
                    }, 200);
                } else {
                    // If closed, open it - reset display first
                    expanded.style.display = '';
                    expanded.classList.add('show');
                    activeExpandedCard = type;
                    if (parentCard) {
                        parentCard.classList.add('expanded-active');
                    }
                }
            }
        }

        // Sidebar Toggle Functions
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebar-overlay');

            const isOpen = sidebar.classList.contains('sidebar-open');

            if (isOpen) {
                // Closing sidebar - close all expanded cards
                closeAllExpandedCards();
                sidebar.classList.remove('sidebar-open');
                sidebar.classList.add('mobile-hidden');
                overlay.classList.remove('show');
            } else {
                // Opening sidebar
                sidebar.classList.remove('mobile-hidden');
                sidebar.classList.add('sidebar-open');
                overlay.classList.add('show');
            }
        }

        function closeSidebar() {
            // Always close expanded cards when closing sidebar
            closeAllExpandedCards();
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebar-overlay');

            sidebar.classList.remove('sidebar-open');
            sidebar.classList.add('mobile-hidden');
            overlay.classList.remove('show');
        }

        // Close sidebar when clicking on a conversation item
        async function handleConversationClick(conv) {
            await loadConversation(conv);
            closeSidebar();
        }

        // Close sidebar when clicking anywhere outside (but not on sidebar itself)
        document.addEventListener('click', function (event) {
            const sidebar = document.getElementById('sidebar');
            const sidebarHandle = sidebar ? sidebar.querySelector('.sidebar-handle') : null;

            // Check if sidebar is open
            if (sidebar && sidebar.classList.contains('sidebar-open')) {
                // If click is on the handle, let toggleSidebar handle it
                if (sidebarHandle && sidebarHandle.contains(event.target)) {
                    return;
                }

                // If click is inside sidebar, don't close
                if (sidebar.contains(event.target)) {
                    return;
                }

                // Otherwise, close the sidebar
                closeSidebar();
            }
        });

        // Close expanded card when clicking outside (mobile and desktop)
        document.addEventListener('click', function (event) {
            if (activeExpandedCard) {
                const card = event.target.closest('.info-card');
                const expanded = event.target.closest('.info-card-expanded');

                // If click is outside both card and expanded area, close it
                if (!card && !expanded) {
                    closeAllExpandedCards();
                }
            }
        });

        // Close expanded cards when clicking on a conversation item (to prevent conflicts)
        document.addEventListener('click', function (event) {
            if (event.target.closest('.conversation-item-content')) {
                closeAllExpandedCards();
            }
        });

        // Close expanded cards when sidebar overlay is clicked
        document.addEventListener('click', function (event) {
            if (event.target.classList.contains('sidebar-overlay')) {
                closeAllExpandedCards();
            }
        });

        // Watch for sidebar visibility changes and close cards
        const sidebar = document.getElementById('sidebar');
        if (sidebar) {
            const observer = new MutationObserver(function (mutations) {
                mutations.forEach(function (mutation) {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                        const isHidden = sidebar.classList.contains('mobile-hidden');
                        if (isHidden) {
                            closeAllExpandedCards();
                        }
                    }
                });
            });

            observer.observe(sidebar, {
                attributes: true,
                attributeFilter: ['class']
            });
        }

        // Initialize sidebar - always hidden by default
        function initializeSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebar-overlay');

            if (sidebar && overlay) {
                // Always hide sidebar by default (both mobile and desktop)
                sidebar.classList.remove('sidebar-open');
                sidebar.classList.add('mobile-hidden');
                overlay.classList.remove('show');
            }
        }

        // Initialize
        loadTheme();

        // CRITICAL: Force close ALL expanded cards immediately on page load
        // Reset activeExpandedCard state first
        activeExpandedCard = null;

        // Function to aggressively close all cards (only for initialization)
        function forceCloseAllCards() {
            activeExpandedCard = null;
            const allExpanded = document.querySelectorAll('.info-card-expanded');
            allExpanded.forEach(expanded => {
                expanded.classList.remove('show');
                // Don't set inline styles - let CSS handle it
            });

            const allCards = document.querySelectorAll('.info-card');
            allCards.forEach(card => {
                card.classList.remove('expanded-active');
            });

            // Clear any lingering inline styles immediately
            setTimeout(function () {
                allExpanded.forEach(expanded => {
                    expanded.style.display = '';
                    expanded.style.opacity = '';
                    expanded.style.visibility = '';
                });
            }, 100);
        }

        // Close cards immediately
        forceCloseAllCards();
        closeAllExpandedCards();

        // CRITICAL: Initialize sidebar state FIRST, before anything else
        // This must happen before loading conversations to prevent state conflicts
        initializeSidebar();

        // Force sidebar reset on page load (especially important for redirects)
        (function () {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebar-overlay');

            // Reset all sidebar-related classes and states - always hidden by default
            if (sidebar && overlay) {
                sidebar.classList.remove('sidebar-open');
                sidebar.classList.add('mobile-hidden');
                overlay.classList.remove('show');
            }

            // Then apply correct state based on screen size
            const menuToggle = document.getElementById('menu-toggle') || document.querySelector('.menu-toggle');
            if (window.innerWidth <= 768) {
                sidebar.classList.add('mobile-hidden');
                if (menuToggle) {
                menuToggle.style.display = '';
                }
            } else {
                if (menuToggle) {
                menuToggle.style.display = 'none';
                }
            }

            // Ensure all expanded cards are closed AGAIN
            forceCloseAllCards();
            closeAllExpandedCards();
        })();

        // Also run on DOM ready and window load as backup
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function () {
                initializeSidebar();
                forceCloseAllCards();
                closeAllExpandedCards();
            });
        }
        window.addEventListener('load', function () {
            initializeSidebar();
            forceCloseAllCards();
            closeAllExpandedCards();
        });

        // Mobile browser UI hiding - minimize bottom bar on touch/click
        (function () {
            function isMobile() {
                return window.innerWidth <= 768;
            }

            // Set body height to full viewport to enable browser UI hiding
            function setFullHeight() {
                if (!isMobile()) return;
                const vh = window.innerHeight * 0.01;
                document.documentElement.style.setProperty('--vh', `${vh}px`);
                // Make body slightly taller to enable scrolling
                document.body.style.minHeight = `${window.innerHeight + 1}px`;
            }

            setFullHeight();
            window.addEventListener('resize', setFullHeight);
            window.addEventListener('orientationchange', function () {
                setTimeout(setFullHeight, 100);
            });

            // Browser UI hiding - ensure window is scrollable
            if (isMobile()) {
                // Force window to be scrollable by ensuring body is taller than viewport
                function ensureWindowScrollable() {
                    const vh = window.innerHeight;
                    const bodyHeight = document.body.scrollHeight;
                    const htmlHeight = document.documentElement.scrollHeight;

                    // Ensure both html and body are taller than viewport
                    if (htmlHeight <= vh) {
                        document.documentElement.style.minHeight = `${vh + 200}px`;
                    }
                    if (bodyHeight <= vh) {
                        document.body.style.minHeight = `${vh + 200}px`;
                    }
                }

                // Run immediately
                ensureWindowScrollable();

                // Run on resize
                window.addEventListener('resize', ensureWindowScrollable);
                window.addEventListener('orientationchange', function () {
                    setTimeout(ensureWindowScrollable, 200);
                });
            }


            // Prevent viewport shift on input focus
            const chatInput = document.getElementById('message-input');
            if (chatInput) {
                chatInput.addEventListener('focus', function () {
                    if (isMobile()) {
                        // Prevent iOS Safari from scrolling
                        setTimeout(() => {
                            const mainContent = document.querySelector('.main-content');
                            if (mainContent) {
                                mainContent.scrollTop = mainContent.scrollHeight;
                            }
                        }, 300);
                    }
                }, { passive: true });
            }

            // Handle viewport height changes (when browser UI shows/hides)
            let viewportHeight = window.innerHeight;
            function updateViewportHeight() {
                if (isMobile()) {
                    const newHeight = window.innerHeight;
                    if (Math.abs(newHeight - viewportHeight) > 50) {
                        viewportHeight = newHeight;
                        document.documentElement.style.setProperty('--vh', `${newHeight * 0.01}px`);
                        // Update main content height
                        const mainContent = document.querySelector('.main-content');
                        if (mainContent) {
                            mainContent.style.height = `${newHeight}px`;
                        }
                    }
                }
            }

            window.addEventListener('resize', updateViewportHeight, { passive: true });
            window.addEventListener('orientationchange', function () {
                setTimeout(updateViewportHeight, 100);
            });

            // Initial call
            if (isMobile()) {
                updateViewportHeight();
            }

            // Handle keyboard visibility for input container transform and footer position
            function handleViewportResize() {
                // CRITICAL: Don't run on desktop - let clearMobileStylesOnDesktop handle it
                if (!isMobile() || window.innerWidth > 768) {
                    // Clear any mobile styles if we're on desktop
                    if (window.innerWidth > 768) {
                        clearMobileStylesOnDesktop();
                    }
                    return;
                }

                const inputContainer = document.querySelector('.input-container');
                const footer = document.querySelector('.chat-footer');
                if (!inputContainer) return;

                if (window.visualViewport) {
                    const viewport = window.visualViewport;
                    const windowHeight = window.innerHeight;
                    const viewportHeight = viewport.height;
                    const keyboardHeight = windowHeight - viewportHeight;

                    // Set CSS variable for keyboard height
                    document.documentElement.style.setProperty('--keyboard-height', `${keyboardHeight}px`);

                    // Toggle keyboard-visible class based on keyboard presence
                    if (keyboardHeight > 150) {
                        inputContainer.classList.add('keyboard-visible');
                        // Hide footer and footer-center when keyboard appears
                        if (footer) {
                            footer.style.display = 'none';
                            footer.style.position = 'absolute';
                            footer.style.bottom = '0';
                            footer.style.transform = 'translateY(0)';
                        }
                        const footerCenter = document.querySelector('.footer-center');
                        if (footerCenter) {
                            footerCenter.style.display = 'none';
                        }
                    } else {
                        inputContainer.classList.remove('keyboard-visible');
                        // Show footer and footer-center when keyboard hides
                        if (footer) {
                            footer.style.display = '';
                            footer.style.position = 'absolute';
                            footer.style.bottom = '0';
                            footer.style.transform = 'translateY(0)';
                        }
                        const footerCenter = document.querySelector('.footer-center');
                        if (footerCenter) {
                            footerCenter.style.display = '';
                        }
                    }
                } else {
                    // Fallback for browsers without visualViewport
                    const chatInput = document.getElementById('message-input');
                    if (chatInput && document.activeElement === chatInput) {
                        const windowHeight = window.innerHeight;
                        const screenHeight = screen.height;
                        const keyboardHeight = screenHeight - windowHeight;

                        if (keyboardHeight > 150) {
                            document.documentElement.style.setProperty('--keyboard-height', `${keyboardHeight}px`);
                            inputContainer.classList.add('keyboard-visible');
                            // Hide footer and footer-center when keyboard appears
                            if (footer) {
                                footer.style.display = 'none';
                                footer.style.position = 'absolute';
                                footer.style.bottom = '0';
                                footer.style.transform = 'translateY(0)';
                            }
                            const footerCenter = document.querySelector('.footer-center');
                            if (footerCenter) {
                                footerCenter.style.display = 'none';
                            }
                        } else {
                            inputContainer.classList.remove('keyboard-visible');
                            // Show footer and footer-center when keyboard hides
                            if (footer) {
                                footer.style.display = '';
                                footer.style.position = 'absolute';
                                footer.style.bottom = '0';
                                footer.style.transform = 'translateY(0)';
                            }
                            const footerCenter = document.querySelector('.footer-center');
                            if (footerCenter) {
                                footerCenter.style.display = '';
                            }
                        }
                    } else {
                        inputContainer.classList.remove('keyboard-visible');
                        // Show footer and footer-center when keyboard is not visible
                        if (footer) {
                            footer.style.display = '';
                            footer.style.position = 'absolute';
                            footer.style.bottom = '0';
                            footer.style.transform = 'translateY(0)';
                        }
                        const footerCenter = document.querySelector('.footer-center');
                        if (footerCenter) {
                            footerCenter.style.display = '';
                        }
                    }
                }
            }

            // Listen for visual viewport changes
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', handleViewportResize);
                window.visualViewport.addEventListener('scroll', handleViewportResize);
            } else {
                window.addEventListener('resize', handleViewportResize);
            }

            // Persistent footer position enforcement (runs continuously but not too aggressively)
            function enforceFooterPosition() {
                if (!isMobile()) return;

                const footer = document.querySelector('.chat-footer');
                const footerCenter = document.querySelector('.footer-center');
                const inputContainer = document.querySelector('.input-container');
                const chatInput = document.getElementById('message-input');
                
                // Check if keyboard is visible
                const isKeyboardVisible = inputContainer && (
                    inputContainer.classList.contains('keyboard-visible') ||
                    (chatInput && document.activeElement === chatInput)
                );

                if (footer) {
                    // Hide footer when keyboard is visible, show when hidden
                    if (isKeyboardVisible) {
                        footer.style.setProperty('display', 'none', 'important');
                    } else {
                        footer.style.setProperty('display', 'flex', 'important');
                    }
                    // Always enforce footer position
                    footer.style.setProperty('position', 'absolute', 'important');
                    footer.style.setProperty('bottom', '0', 'important');
                    footer.style.setProperty('transform', 'translateY(0)', 'important');
                    footer.style.setProperty('left', '0', 'important');
                    footer.style.setProperty('right', '0', 'important');
                }

                // Hide footer-center when keyboard is visible
                if (footerCenter) {
                    if (isKeyboardVisible) {
                        footerCenter.style.setProperty('display', 'none', 'important');
                    } else {
                        footerCenter.style.setProperty('display', 'flex', 'important');
                    }
                }
            }

            // Run footer enforcement periodically (every 200ms) to catch any changes
            if (isMobile()) {
                // Clear any existing interval first
                if (footerEnforcementInterval) {
                    clearInterval(footerEnforcementInterval);
                }
                footerEnforcementInterval = setInterval(enforceFooterPosition, 200);
                // Also enforce immediately
                enforceFooterPosition();
            } else {
                // Stop footer enforcement on desktop
                if (footerEnforcementInterval) {
                    clearInterval(footerEnforcementInterval);
                    footerEnforcementInterval = null;
                }
            }

            // Handle input focus/blur for keyboard detection - ensure it works every time
            if (chatInput) {
                chatInput.addEventListener('focus', function () {
                    if (isMobile()) {
                        // Call multiple times to ensure it works consistently
                        handleViewportResize();
                        enforceFooterPosition();
                        setTimeout(function () {
                            handleViewportResize();
                            enforceFooterPosition();
                        }, 100);
                        setTimeout(function () {
                            handleViewportResize();
                            enforceFooterPosition();
                        }, 300);
                        setTimeout(function () {
                            handleViewportResize();
                            enforceFooterPosition();
                        }, 500);
                    }
                }, { passive: true });

                chatInput.addEventListener('blur', function () {
                    if (isMobile()) {
                        const inputContainer = document.querySelector('.input-container');
                        if (inputContainer) {
                            inputContainer.classList.remove('keyboard-visible');
                        }
                        // Show footer and footer-center when keyboard hides
                        const footer = document.querySelector('.chat-footer');
                        const footerCenter = document.querySelector('.footer-center');
                        if (footer) {
                            footer.style.display = '';
                        }
                        if (footerCenter) {
                            footerCenter.style.display = '';
                        }
                        // Enforce footer position multiple times
                        enforceFooterPosition();
                        setTimeout(enforceFooterPosition, 50);
                        setTimeout(enforceFooterPosition, 100);
                        setTimeout(enforceFooterPosition, 200);
                    }
                }, { passive: true });
            }

            // Also enforce footer on every viewport resize
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', function () {
                    if (isMobile()) {
                        handleViewportResize();
                        enforceFooterPosition();
                    }
                });
                window.visualViewport.addEventListener('scroll', function () {
                    if (isMobile()) {
                        handleViewportResize();
                        enforceFooterPosition();
                    }
                });
            } else {
                window.addEventListener('resize', function () {
                    if (isMobile()) {
                        handleViewportResize();
                        enforceFooterPosition();
                    }
                });
            }
        })();

        // Close cards on page visibility change
        document.addEventListener('visibilitychange', function () {
            if (!document.hidden) {
                forceCloseAllCards();
            }
        });

        // Store footer enforcement interval ID to clear it when needed (must be outside IIFE)
        let footerEnforcementInterval = null;

        // Handle window resize for desktop layout adjustments - clear mobile styles
        let resizeTimeout;
        let lastWindowWidth = window.innerWidth;
        
        function clearMobileStylesOnDesktop() {
            // Only run on desktop (non-mobile)
            if (window.innerWidth <= 768) return;
            
            // CRITICAL: Stop mobile footer enforcement IMMEDIATELY
            if (footerEnforcementInterval) {
                clearInterval(footerEnforcementInterval);
                footerEnforcementInterval = null;
            }
            
            // Also stop handleViewportResize from running
            const visualViewport = window.visualViewport;
            if (visualViewport) {
                visualViewport.removeEventListener('resize', handleViewportResize);
            }
            
            const chatInputArea = document.querySelector('.chat-input-area');
            const chatFooter = document.querySelector('.chat-footer');
            const footerCenter = document.querySelector('.footer-center');
            const inputContainer = document.querySelector('.input-container');
            const chatMessages = document.querySelector('.chat-messages');
            const mainContent = document.querySelector('.main-content');
            
            // Remove keyboard-visible class
            if (inputContainer) {
                inputContainer.classList.remove('keyboard-visible');
            }
            
            // IMMEDIATELY remove ALL inline styles - no delays
            if (chatFooter) {
                chatFooter.removeAttribute('style');
                chatFooter.style.visibility = 'visible';
                chatFooter.style.opacity = '1';
                chatFooter.style.position = 'relative';
                chatFooter.style.bottom = 'auto';
                chatFooter.style.left = 'auto';
                chatFooter.style.right = 'auto';
                chatFooter.style.width = 'auto';
                chatFooter.style.transform = 'none';
                chatFooter.style.padding = '2rem 1.5rem';
                chatFooter.style.paddingTop = '2rem';
                chatFooter.style.paddingBottom = '2rem';
                chatFooter.style.paddingLeft = '1.5rem';
                chatFooter.style.paddingRight = '1.5rem';
                chatFooter.style.minHeight = 'auto';
                chatFooter.style.height = 'auto';
            }
            
            if (footerCenter) {
                footerCenter.removeAttribute('style');
                footerCenter.style.visibility = 'visible';
                footerCenter.style.opacity = '1';
                footerCenter.style.minHeight = 'auto';
                footerCenter.style.height = 'auto';
            }
            
            if (chatInputArea) {
                // Remove all inline styles first
                chatInputArea.removeAttribute('style');
                // Force clear all properties with !important override
                chatInputArea.style.setProperty('position', 'relative', 'important');
                chatInputArea.style.setProperty('bottom', 'auto', 'important');
                chatInputArea.style.setProperty('left', 'auto', 'important');
                chatInputArea.style.setProperty('right', 'auto', 'important');
                chatInputArea.style.setProperty('width', 'auto', 'important');
                chatInputArea.style.setProperty('z-index', 'auto', 'important');
                chatInputArea.style.setProperty('transform', 'none', 'important');
                chatInputArea.style.setProperty('padding', '1.5rem', 'important');
                chatInputArea.style.setProperty('padding-bottom', '1.5rem', 'important');
                chatInputArea.style.setProperty('margin', '0', 'important');
                chatInputArea.style.setProperty('margin-top', '0', 'important');
                chatInputArea.style.setProperty('margin-bottom', '0', 'important');
                chatInputArea.style.setProperty('display', 'block', 'important');
                chatInputArea.style.setProperty('visibility', 'visible', 'important');
                chatInputArea.style.setProperty('opacity', '1', 'important');
            }
            
            if (inputContainer) {
                // Remove all inline styles first
                inputContainer.removeAttribute('style');
                // Force clear all properties with !important override
                inputContainer.style.setProperty('position', 'relative', 'important');
                inputContainer.style.setProperty('transform', 'translateY(0)', 'important');
                inputContainer.style.setProperty('margin-bottom', '0', 'important');
                inputContainer.style.setProperty('margin-top', '0', 'important');
                inputContainer.style.setProperty('margin', '0 auto', 'important');
                inputContainer.style.setProperty('display', 'flex', 'important');
                inputContainer.style.setProperty('visibility', 'visible', 'important');
                inputContainer.style.setProperty('opacity', '1', 'important');
            }
            
            // Reset chat-messages padding that might be pushing content down
            if (chatMessages) {
                chatMessages.style.removeProperty('padding-bottom');
                chatMessages.style.setProperty('padding-bottom', '2rem', 'important');
            }
            
            // Reset main-content height if it was constrained
            if (mainContent) {
                mainContent.style.removeProperty('height');
                mainContent.style.removeProperty('min-height');
                mainContent.style.removeProperty('padding-top');
                mainContent.style.removeProperty('padding-bottom');
            }
            
            // Check for duplicate footers and remove them
            const footers = document.querySelectorAll('.chat-footer');
            if (footers.length > 1) {
                // Keep only the first one, remove the rest
                for (let i = 1; i < footers.length; i++) {
                    footers[i].remove();
                }
            }
            
            // Clear keyboard height CSS variable
            document.documentElement.style.removeProperty('--keyboard-height');
            
            // Force a reflow to ensure styles are applied
            if (chatInputArea) {
                void chatInputArea.offsetHeight;
            }
            if (inputContainer) {
                void inputContainer.offsetHeight;
            }
            if (mainContent) {
                void mainContent.offsetHeight;
            }
        }
        
        // Auto-refresh page on resize (5ms delay) - MUST BE FIRST RESIZE LISTENER
        (function() {
            let refreshTimer = null;
            let lastWidth = window.innerWidth;
            let lastHeight = window.innerHeight;
            
            function handleResizeRefresh() {
                const currentWidth = window.innerWidth;
                const currentHeight = window.innerHeight;
                
                // Only refresh if size actually changed
                if (currentWidth !== lastWidth || currentHeight !== lastHeight) {
                    lastWidth = currentWidth;
                    lastHeight = currentHeight;
                    
                    // Clear any existing timer
                    if (refreshTimer) {
                        clearTimeout(refreshTimer);
                    }
                    
                    // Set timer to reload after 5ms
                    refreshTimer = setTimeout(function() {
                        window.location.reload(true); // Force reload from server
                    }, 5);
                }
            }
            
            // Add as first resize listener with capture phase
            window.addEventListener('resize', handleResizeRefresh, true);
        })();
        
        // Handle window resize - run cleanup IMMEDIATELY
        window.addEventListener('resize', function () {
            initializeSidebar();
            
            const currentWidth = window.innerWidth;
            const wasMobile = lastWindowWidth <= 768;
            const isNowMobile = currentWidth <= 768;
            
            // If we're on desktop or crossing to desktop, run cleanup IMMEDIATELY
            if (!isNowMobile || currentWidth > 768) {
                // Stop footer enforcement FIRST
                if (footerEnforcementInterval) {
                    clearInterval(footerEnforcementInterval);
                    footerEnforcementInterval = null;
                }
                
                // Run cleanup immediately MULTIPLE times to override any re-applied styles
                clearMobileStylesOnDesktop();
                clearMobileStylesOnDesktop();
                clearMobileStylesOnDesktop();
                
                // Run again in next frames to catch any re-applied styles
                requestAnimationFrame(function() {
                    clearMobileStylesOnDesktop();
                    requestAnimationFrame(function() {
                        clearMobileStylesOnDesktop();
                        setTimeout(clearMobileStylesOnDesktop, 0);
                        setTimeout(clearMobileStylesOnDesktop, 10);
                        setTimeout(clearMobileStylesOnDesktop, 50);
                        setTimeout(clearMobileStylesOnDesktop, 100);
                    });
                });
            }
            
            lastWindowWidth = currentWidth;
        });
        
        // Aggressive periodic cleanup on desktop - runs very frequently
        setInterval(function() {
            if (window.innerWidth > 768) {
                // Stop footer enforcement if it somehow started
                if (footerEnforcementInterval) {
                    clearInterval(footerEnforcementInterval);
                    footerEnforcementInterval = null;
                }
                
                // Check if mobile styles are present and clear them
                const footer = document.querySelector('.chat-footer');
                const inputArea = document.querySelector('.chat-input-area');
                const inputContainer = document.querySelector('.input-container');
                
                let needsCleanup = false;
                
                if (footer && footer.hasAttribute('style')) {
                    const computed = window.getComputedStyle(footer);
                    if (computed.position === 'absolute' || computed.bottom !== 'auto') {
                        needsCleanup = true;
                    }
                }
                
                if (inputArea) {
                    const computed = window.getComputedStyle(inputArea);
                    if (computed.position === 'fixed' || 
                        computed.bottom !== 'auto' || 
                        computed.visibility === 'hidden' ||
                        computed.opacity === '0' ||
                        computed.display === 'none') {
                        needsCleanup = true;
                    }
                }
                
                if (inputContainer) {
                    if (inputContainer.classList.contains('keyboard-visible')) {
                        needsCleanup = true;
                    }
                    const computed = window.getComputedStyle(inputContainer);
                    if (computed.visibility === 'hidden' || 
                        computed.opacity === '0' ||
                        computed.display === 'none') {
                        needsCleanup = true;
                    }
                }
                
                if (needsCleanup) {
                    clearMobileStylesOnDesktop();
                }
            }
        }, 100); // Check every 100ms - very aggressive
        
        // Run on initial load if on desktop
        if (window.innerWidth > 768) {
            clearMobileStylesOnDesktop();
            setTimeout(clearMobileStylesOnDesktop, 50);
            setTimeout(clearMobileStylesOnDesktop, 200);
        }

        // Initialize model toggle - default to Coder (off position = model1)
        document.getElementById('model-toggle').classList.remove('active');
        document.getElementById('model-label').textContent = 'Coder';
        currentModel = 'model1'; // Coder when OFF
        document.getElementById('message-input').focus();
        // Initialize auth UI
        updateAuthUI();
        // Load conversations list
        updateConversationsList();

        // Listen for user updates from profile page
        window.addEventListener('message', function (event) {
            if (event.data && event.data.type === 'userUpdated') {
                currentUser = event.data.user;
                localStorage.setItem('currentUser', JSON.stringify(currentUser));
                updateAuthUI();
            }
        });

        // Update UI when returning from profile page
        window.addEventListener('focus', function () {
            const savedUser = JSON.parse(localStorage.getItem('currentUser') || 'null');
            if (savedUser && currentUser && (savedUser.avatar !== currentUser.avatar || savedUser.avatarEmoji !== currentUser.avatarEmoji || savedUser.name !== currentUser.name)) {
                currentUser = savedUser;
                updateAuthUI();
            }
        });
    </script>

    <!-- Auth Modal -->
    <div id="auth-modal" class="auth-modal">
        <div class="auth-modal-content">
            <div class="auth-modal-header">
                <h2>Welcome</h2>
                <button class="auth-modal-close" onclick="closeAuthModal()">&times;</button>
            </div>
            <div class="auth-tabs">
                <button class="auth-tab active" id="login-tab" onclick="switchAuthTab('login')"><strong>Sign
                        In</strong></button>
                <button class="auth-tab" id="register-tab" onclick="switchAuthTab('register')"><strong>Sign
                        Up</strong></button>
            </div>
            <div id="login-content" class="auth-content active">
                <form class="auth-form" id="login-form" onsubmit="handleLogin(event)">
                    <div class="auth-form-group">
                        <label for="login-email">Email</label>
                        <input type="email" id="login-email" required>
                    </div>
                    <div class="auth-form-group">
                        <label for="login-password">Password</label>
                        <input type="password" id="login-password" required>
                    </div>
                    <div class="auth-error" id="auth-error"></div>
                    <button type="submit" class="auth-submit-btn"><strong>Sign In</strong></button>
                </form>
                <div class="auth-divider">OR</div>
                <button class="auth-google-btn" onclick="handleGoogleSignIn()">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                            fill="#4285F4" />
                        <path
                            d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                            fill="#34A853" />
                        <path
                            d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
                            fill="#FBBC05" />
                        <path
                            d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                            fill="#EA4335" />
                    </svg>
                    <strong>Sign in with Google</strong>
                </button>
            </div>
            <div id="register-content" class="auth-content">
                <form class="auth-form" id="register-form" onsubmit="handleRegister(event)">
                    <div class="auth-form-group">
                        <label for="register-email">Email</label>
                        <input type="email" id="register-email" required>
                    </div>
                    <div class="auth-form-group">
                        <label for="register-password">Password</label>
                        <input type="password" id="register-password" required
                            placeholder="Min 8 chars, 1 special or uppercase">
                    </div>
                    <div class="auth-form-group">
                        <label for="register-confirm-password">Confirm Password</label>
                        <input type="password" id="register-confirm-password" required>
                    </div>
                    <div class="auth-form-group">
                        <label for="register-verification-code">Verification Code</label>
                        <input type="text" id="register-verification-code" required placeholder="Check your email">
                    </div>
                    <div class="auth-error" id="auth-error"></div>
                    <button type="submit" class="auth-submit-btn"><strong>Sign Up</strong></button>
                </form>
                <div class="auth-divider">OR</div>
                <button class="auth-google-btn" onclick="handleGoogleSignIn()">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                            fill="#4285F4" />
                        <path
                            d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                            fill="#34A853" />
                        <path
                            d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
                            fill="#FBBC05" />
                        <path
                            d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                            fill="#EA4335" />
                    </svg>
                    <strong>Sign up with Google</strong>
                </button>
            </div>
        </div>
    </div>

    <!-- Token Limit Modal -->
    <div id="token-limit-modal" class="token-limit-modal">
        <div class="token-limit-modal-content">
            <div class="token-limit-modal-header">
                <h2>Oops! Token Limit Reached</h2>
                <button class="token-limit-modal-close" onclick="closeTokenLimitModal()">&times;</button>
            </div>
            <div class="token-limit-modal-body">
                <p>You've used all your free tokens! To continue chatting with our AI models, please upgrade to a paid plan.</p>
                <p>Our paid plans offer:</p>
                <ul style="color: var(--text-primary); margin: 1rem 0; padding-left: 1.5rem; line-height: 1.8;">
                    <li><span class="highlight">Lite Plan:</span> 25,000 tokens</li>
                    <li><span class="highlight">Pro Plan:</span> 100,000 tokens</li>
                    <li><span class="highlight">Ultra Plan:</span> 250,000 tokens</li>
                </ul>
                <div class="token-limit-modal-actions">
                    <a href="/pricing.html" class="token-limit-btn token-limit-btn-primary">View Pricing Plans</a>
                    <button class="token-limit-btn token-limit-btn-secondary" onclick="closeTokenLimitModal()">Maybe Later</button>
                </div>
            </div>
        </div>
    </div>
</body>

</html>